---
date: 2025-10-09 13:49
title: husky
tags:
  - git
  - automatizacion
  - husky
  - linters
  - scripting
keywords:
source:
status: üåü
Parent: "[[Area-Sistemas]]"
cssclasses:
  - hide-embedded-header1
categories:
  - Automatizacion y Build
public_note: "true"
category: Automatizacion y Build
---
# husky
`$= dv.current().file.tags.join(" ")`

## Documentaci√≥n y recursos
- docs
	- Husky info web
	- ¬øC√≥mo usar Git Hooks-como-usar-git-hooks
	- Get started  Husky-get-started.html
	- gpt uso basico de husky
- [monorepo](/backend/monorepo/)
## Relaci√≥n con el ecosistema
- Complementa herramientas de:
	- [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
	- control de versiones con [git](/software%20engineering/git/)
	- calidad de c√≥digo con eslint
	- flujos CI con github workflow
## Descripci√≥n general
- **Husky** es una herramienta para **gestionar Git Hooks** de forma declarativa dentro de proyectos JavaScript/TypeScript.
- Permite **automatizar flujos de trabajo** relacionados con:
	- validaci√≥n de c√≥digo
	- ejecuci√≥n de tests
	- linting
	- formateo
	- checks de calidad antes de commits y pushes
- Se integra de forma natural con:
	- [git](/software%20engineering/git/)
	- github workflow
	- eslint
	- [Automatizacion y Build](/uncategorized/automatizacion-y-build/)

## Objetivos principales
- Prevenir que c√≥digo incorrecto llegue al repositorio
- Estandarizar reglas de calidad en equipos
- Reducir errores humanos en commits y pushes
- Automatizar tareas repetitivas del ciclo de desarrollo

## Conceptos clave
- **Git Hooks**
	- Scripts que Git ejecuta autom√°ticamente en eventos espec√≠ficos
	- Ejemplos comunes:
		- pre-commit
		- commit-msg
		- pre-push
		- post-merge
- **Hooks locales**
	- Se ejecutan en el entorno del desarrollador
	- No dependen de CI
	- Complementan pero no sustituyen pipelines remotos
- **Hooks versionados**
	- Husky permite que los hooks formen parte del repositorio
	- Garantiza comportamiento consistente entre desarrolladores

## Arquitectura y funcionamiento
- Husky crea un directorio `.husky/`
- Cada hook es un archivo ejecutable
- Los hooks llaman scripts definidos en `package.json` o comandos directos
- Basado en shell scripts, compatible con:
	- bash
	- sh
	- zsh

## Hooks m√°s utilizados
- **pre-commit**
	- Validaciones r√°pidas antes de crear un commit
	- Uso t√≠pico:
		- lint
		- format
		- type-check
- **commit-msg**
	- Validaci√≥n del mensaje de commit
	- Integraci√≥n frecuente con commitlint
- **pre-push**
	- Checks m√°s pesados
	- Ejecuci√≥n de tests completos
	- Validaciones de build
- **post-merge**
	- Reinstalaci√≥n de dependencias
	- Regeneraci√≥n de archivos

## Integraci√≥n con herramientas comunes
- **ESLint**
	- Evita commits con errores de lint
	- Refuerza reglas de estilo
- **Prettier**
	- Formateo autom√°tico antes del commit
- **Jest / Vitest / Mocha**
	- Ejecuci√≥n de tests unitarios
- **TypeScript**
	- Verificaci√≥n de tipos
- **lint-staged**
	- Ejecuta comandos solo sobre archivos modificados
	- Optimiza el tiempo de ejecuci√≥n

## Relaci√≥n con CI/CD
- Husky act√∫a como **primera l√≠nea de defensa**
- Evita fallos tempranos antes de llegar a:
	- github workflow
	- pipelines de CI
- Buenas pr√°cticas:
	- No confiar solo en Husky
	- Replicar validaciones cr√≠ticas en CI

## Instalaci√≥n y configuraci√≥n
- Se instala como dependencia de desarrollo
- Se inicializa creando el directorio `.husky`
- Los hooks se gestionan como archivos ejecutables
- Compatible con:
	- npm
	- yarn
	- pnpm

## Ejemplo: estructura de proyecto
- `.husky/`
	- `pre-commit`
	- `commit-msg`
	- `pre-push`
- `package.json`
	- scripts reutilizables
- `.eslintrc`
- `.prettierrc`

## Buenas pr√°cticas
- Mantener hooks r√°pidos
- Evitar procesos pesados en pre-commit
- Usar lint-staged para optimizaci√≥n
- Documentar los hooks en el repositorio
- Alinear reglas locales con CI
- Evitar l√≥gica compleja dentro del hook

## Casos de uso comunes
- Equipos grandes con m√∫ltiples contribuidores
- Proyectos con est√°ndares estrictos de calidad
- Monorepos
- Librer√≠as p√∫blicas
- Proyectos open-source

## Limitaciones y consideraciones
- Se ejecuta solo en entornos locales
- Puede ser deshabilitado manualmente por el usuario
- Depende del entorno del desarrollador
- No sustituye validaciones remotas

# husky ‚Äî conceptos avanzados y temas complementarios

## Hooks menos comunes y avanzados
- **applypatch-msg**
	- Valida mensajes cuando se aplican parches (`git am`)
	- √ötil en flujos basados en parches o mailing lists
- **pre-applypatch**
	- Se ejecuta antes de aplicar un patch
	- Permite validaciones de seguridad o estructura
- **prepare-commit-msg**
	- Modifica o autocompleta el mensaje de commit
	- Integraci√≥n con templates y convenciones internas
- **post-checkout**
	- Reacciona a cambios de rama
	- Casos comunes:
		- regenerar archivos
		- limpiar builds
		- reinstalar dependencias
- **pre-rebase**
	- Validaciones antes de un rebase
	- Prevenci√≥n de rebase en ramas protegidas

## Control de ejecuci√≥n y bypass
- **Salto manual de hooks**
	- Uso de flags de Git para omitir hooks
	- Importante en:
		- hotfixes urgentes
		- recuperaci√≥n de errores
- **Variables de entorno**
	- Permiten habilitar o deshabilitar hooks condicionalmente
	- Ejemplo:
		- desactivar tests en commits autom√°ticos
- **Hooks contextuales**
	- Ejecuci√≥n basada en:
		- rama actual
		- tipo de commit
		- usuario o entorno

## Husky en monorepos
- Centralizaci√≥n de hooks
- Coordinaci√≥n con workspaces
- Ejecuci√≥n selectiva por paquete
- Integraci√≥n frecuente con:
	- gestores de monorepo
	- scripts compartidos
- Retos comunes:
	- tiempos de ejecuci√≥n
	- paths relativos
	- dependencias cruzadas

## Rendimiento y optimizaci√≥n
- Uso de **lint-staged** como capa intermedia
- Paralelizaci√≥n de tareas ligeras
- Cacheo de resultados de lint y tests
- Evitar:
	- builds completos
	- tests e2e
	- tareas de larga duraci√≥n

## Seguridad y cumplimiento
- Prevenci√≥n de commits con:
	- secretos
	- credenciales
	- tokens
- Integraci√≥n con esc√°neres de seguridad
- Validaciones de licencias
- Cumplimiento de pol√≠ticas internas antes del push

## Convenciones de commits
- Enforcement de est√°ndares:
	- Conventional Commits
	- mensajes sem√°nticos
- Automatizaci√≥n de:
	- versionado
	- generaci√≥n de changelog
	- releases
- Relaci√≥n directa con:
	- versionado sem√°ntico
	- pipelines de publicaci√≥n

## Husky y scripting avanzado
- Uso de scripts shell complejos
- Delegaci√≥n de l√≥gica a:
	- scripts Node.js
	- scripts bash reutilizables
- Manejo de errores expl√≠cito
- Logs claros para el desarrollador

## Compatibilidad multiplataforma
- Consideraciones en:
	- Windows
	- macOS
	- Linux
- Uso de shells compatibles
- Evitar dependencias espec√≠ficas del SO
- Normalizaci√≥n de paths

## Versionado y mantenimiento
- Cambios relevantes entre versiones de Husky
- Eliminaci√≥n de configuraciones obsoletas
- Migraciones entre versiones mayores
- Auditor√≠a peri√≥dica de hooks

## Experiencia de desarrollador (DX)
- Mensajes claros y accionables
- Fallos r√°pidos con feedback inmediato
- Documentaci√≥n interna de hooks
- Onboarding m√°s r√°pido para nuevos miembros

## Anti-patrones comunes
- Hooks demasiado lentos
- Duplicar l√≥gica de CI
- Falta de documentaci√≥n
- Dependencia excesiva de bypass
- Scripts no deterministas

## Estrategias de adopci√≥n en equipos
- Introducci√≥n progresiva de hooks
- Hooks informativos antes de ser bloqueantes
- Alineaci√≥n con l√≠deres t√©cnicos
- Revisi√≥n peri√≥dica de reglas

## Comparativa conceptual
- Husky vs validaciones en CI
- Husky vs herramientas de scaffolding
- Hooks locales vs server-side hooks
- Automatizaci√≥n preventiva vs correctiva

## Relaci√≥n con automatizaci√≥n avanzada
- Parte de pipelines locales
- Pre-validaci√≥n antes de CI
- Integraci√≥n con flujos de:
	- [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
	- [git](/software%20engineering/git/)
	- github workflow

## Casos extremos y edge cases
- Commits autom√°ticos por bots
- Rebases masivos
- Cherry-picks
- Subm√≥dulos Git
- Repositorios heredados

## Escenarios donde NO usar Husky
- Proyectos muy peque√±os
- Scripts de un solo desarrollador
- Repositorios sin est√°ndares definidos
- Entornos altamente restrictivos

## Evoluci√≥n y tendencias
- Mayor enfoque en DX
- Hooks m√°s declarativos
- Integraci√≥n m√°s estrecha con CI
- Automatizaci√≥n local como est√°ndar

# husky ‚Äî ejemplos de c√≥digo y casos de uso

## Pre-commit: lint y formato r√°pido
- Caso de uso:
	- Evitar commits con errores de lint o formato
	- Feedback inmediato al desarrollador

### C√≥digo: pre-commit con ESLint y Prettier
```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run lint
npm run format
````

## Pre-commit optimizado con lint-staged

* Caso de uso:

  * Reducir tiempo de ejecuci√≥n
  * Ejecutar validaciones solo sobre archivos modificados

### C√≥digo: configuraci√≥n lint-staged

```json
{
	"lint-staged": {
		"*.{js,ts}": [
			"eslint --fix",
			"prettier --write"
		]
	}
}
```

### C√≥digo: pre-commit usando lint-staged

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged
```

## Commit-msg: validaci√≥n de mensajes

* Caso de uso:

  * Forzar convenciones de commits
  * Facilitar changelogs y versionado autom√°tico

### C√≥digo: commit-msg con commitlint

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx commitlint --edit "$1"
```

## Pre-push: ejecuci√≥n de tests

* Caso de uso:

  * Evitar subir c√≥digo que rompe tests
  * A√±adir una capa extra antes del CI

### C√≥digo: pre-push con tests

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm test
```

## Pre-push condicionado por rama

* Caso de uso:

  * Ejecutar checks m√°s pesados solo en ramas cr√≠ticas
  * Optimizar el flujo diario

### C√≥digo: pre-push condicional

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

branch="$(git branch --show-current)"

if [ "$branch" = "main" ] || [ "$branch" = "develop" ]; then
	npm test
fi
```

## Commit autom√°tico seguro

* Caso de uso:

  * Scripts o bots que realizan commits
  * Evitar bloqueos por hooks

### C√≥digo: bypass controlado

```sh
HUSKY=0 git commit -m "chore: auto update"
```

## Pre-commit: chequeo de TypeScript

* Caso de uso:

  * Prevenir errores de tipos antes del commit
  * Mantener consistencia en proyectos TS

### C√≥digo: type-check

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run type-check
```

## Seguridad: detecci√≥n de secretos

* Caso de uso:

  * Evitar subir tokens, claves o credenciales
  * Cumplimiento de pol√≠ticas de seguridad

### C√≥digo: pre-commit con esc√°ner de secretos

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run scan:secrets
```

## Post-merge: sincronizaci√≥n del entorno

* Caso de uso:

  * Actualizar dependencias tras cambiar de rama
  * Evitar errores por dependencias desalineadas

### C√≥digo: post-merge

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm install
```

## Monorepo: ejecuci√≥n selectiva

* Caso de uso:

  * Validar solo paquetes afectados
  * Escalar Husky en repositorios grandes

### C√≥digo: pre-commit en monorepo

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run affected:lint
```

## Pre-rebase: protecci√≥n de ramas

* Caso de uso:

  * Evitar rebases peligrosos
  * Proteger historial en ramas compartidas

### C√≥digo: pre-rebase

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

branch="$(git branch --show-current)"

if [ "$branch" = "main" ]; then
	echo "Rebase bloqueado en main"
	exit 1
fi
```

## Automatizaci√≥n de versionado

* Caso de uso:

  * Releases consistentes
  * Versionado sem√°ntico autom√°tico

### C√≥digo: pre-push para release

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run release:check
```

## Casos de uso por tipo de proyecto

* **Aplicaciones web**

  * Lint + format en pre-commit
  * Tests unitarios en pre-push
* **Librer√≠as**

  * commit-msg estricto
  * type-check obligatorio
* **Monorepos**

  * lint-staged
  * ejecuci√≥n por paquetes afectados
* **Open-source**

  * Convenciones estrictas
  * Seguridad y calidad como prioridad

## Relaci√≥n con el ecosistema

* Integraci√≥n directa con:
  * eslint
  * [git](/software%20engineering/git/)
  * github workflow
  * [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
* Refuerza la calidad antes de CI sin sustituirlo

