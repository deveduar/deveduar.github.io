---
date: 2024-11-23 16:52
title: cypress
tags:
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
public_note: "true"
category: cypress
categories:
  - cypress
  - e2e
  - testing
  - hide-embedded-header1
  - wide
  - Testing
---
# Cypress

``$= dv.current().file.tags.join(" ")``

## üîó Recursos y Documentaci√≥n

* [Cypress Official Docs: Comprehensive Test Automation Guide](https://docs.cypress.io/guides/overview/why-cypress)
* [Repositorio de Ejemplo Cypress RealWorld App](https://github.com/cypress-io/cypress-realworld-app)
* [Testing](/testing/testing/)
* [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
* [E2E - End to End Testing](/testing/e2e---end-to-end-testing/)
## üìö Conceptos Fundamentales

Cypress es un **framework de testing E2E (End-to-End)** moderno y robusto que permite testear aplicaciones web directamente en el navegador real, con acceso total al DOM, red, y componentes del frontend. Combina caracter√≠sticas de **framework, runner y aserciones** en una sola herramienta, facilitando el flujo completo de automatizaci√≥n de pruebas.

Est√° enfocado en la experiencia del desarrollador: r√°pido, con recarga autom√°tica y depuraci√≥n integrada. Se utiliza tanto para **pruebas E2E**, **pruebas de integraci√≥n** y **pruebas unitarias**, cubriendo el ciclo completo de validaci√≥n de UI y l√≥gica de negocio.

En su esencia, Cypress act√∫a como un **task runner** que ejecuta tests directamente en el mismo ciclo de ejecuci√≥n que la aplicaci√≥n, lo que permite observar y controlar cada interacci√≥n del usuario de forma precisa.

## ‚öôÔ∏è Integraci√≥n con el Ecosistema

Cypress puede integrarse f√°cilmente en pipelines de CI/CD y con herramientas de automatizaci√≥n como GitHub Actions, Jenkins, CircleCI o GitLab CI. Su soporte nativo para **reportes en tiempo real**, **screenshots autom√°ticos**, y **videos de ejecuci√≥n** permite diagnosticar r√°pidamente fallos en entornos de integraci√≥n continua.

Adem√°s, al trabajar sobre Node.js, puede extenderse mediante plugins personalizados para manipular datos, autenticar usuarios, o preparar entornos antes del test.

## üéØ Tipos de Pruebas

### Pruebas E2E
Permiten simular el flujo completo del usuario desde el frontend hasta el backend. Cypress puede verificar la navegaci√≥n, autenticaci√≥n, y persistencia de datos.

{% raw %}
```javascript
describe('Flujo completo de usuario', () => {
	it('Permite registrarse y acceder al panel', () => {
		cy.visit('/register')
		cy.get('input[name="email"]').type('user@test.com')
		cy.get('input[name="password"]').type('password123')
		cy.get('form').submit()
		cy.url().should('include', '/dashboard')
	})
})
```
{% endraw %}`

### Pruebas de Integraci√≥n

Eval√∫an c√≥mo interact√∫an componentes individuales dentro de una aplicaci√≥n. √ötil para frameworks como React, Vue o Angular, donde se puede montar un componente y validar su comportamiento.

{% raw %}
```javascript
import TodoList from '../../src/components/TodoList'

describe('Componente TodoList', () => {
	it('A√±ade una tarea correctamente', () => {
		cy.mount(<TodoList />)
		cy.get('input').type('Nueva tarea{enter}')
		cy.get('li').should('contain', 'Nueva tarea')
	})
})
```
{% endraw %}

### Pruebas Unitarias

Aunque Cypress se dise√±√≥ para E2E, tambi√©n soporta pruebas unitarias en componentes individuales, aprovechando su entorno de ejecuci√≥n en navegador y la capacidad de renderizar UI directamente.

## üß© Caracter√≠sticas Clave

* **Recarga en caliente:** Los tests se actualizan autom√°ticamente con cada cambio en el c√≥digo.
* **Snapshots autom√°ticos:** Cada paso del test genera una instant√°nea visual.
* **Control total del entorno:** Permite interceptar peticiones HTTP, manipular el DOM o simular respuestas de servidor.
* **Asincron√≠a simplificada:** Cypress maneja autom√°ticamente los tiempos de espera y sincronizaci√≥n entre acciones.
* **Time travel:** Permite navegar visualmente por el estado de la app en cada paso del test.

## üîÑ Automatizaci√≥n y Flujo de Trabajo

Cypress se integra con scripts de automatizaci√≥n y pipelines CI/CD para ejecutar tests en entornos headless, recolectar resultados y publicar reportes.

Ejemplo de ejecuci√≥n headless en CI:

{% raw %}
```bash
npx cypress run --browser chrome --headless
```
{% endraw %}

Se puede combinar con herramientas de build y automatizaci√≥n:

* **npm scripts**: `"test:e2e": "cypress run"`
* **Docker**: para entornos de testing reproducibles.
* **Git hooks (Husky)**: para ejecutar pruebas antes de los commits.

## üß≠ Mejores Pr√°cticas

* Estructura los tests seg√∫n el flujo de usuario, no por archivos.
* Usa `cy.intercept()` para aislar dependencias externas.
* Mant√©n datos de prueba en `fixtures` y configura estados con `beforeEach()`.
* Desacopla la l√≥gica de test del UI para mejorar la mantenibilidad.
* Configura variables sensibles en `cypress.env.json` o mediante CI secrets.

## üìà Estrategias Avanzadas

* **Mocking y Stubbing:** Controla respuestas HTTP para aislar escenarios.
* **Test de rendimiento b√°sico:** Mide tiempos de carga y respuesta.
* **Reportes personalizados:** Integra mochawesome o Allure para reportes detallados.
* **Testing visual:** Usa herramientas como Percy o Applitools junto con Cypress.
* **Integraci√≥n con API:** Ejecuta pruebas mixtas frontend-backend en un mismo flujo.


# Cypress - Patrones Avanzados, Rendimiento y Estrategias de Escalabilidad en Testing E2E

## üß† Enfoque Avanzado del Ecosistema Cypress

Cypress no es solo un framework de testing, sino una **plataforma de automatizaci√≥n integral**. En entornos empresariales y CI/CD complejos, su verdadero poder surge al combinarlo con herramientas de gesti√≥n de entornos, control de datos, an√°lisis de resultados y paralelizaci√≥n inteligente.

## üß© Patrones Avanzados de Arquitectura en Testing

### Patr√≥n Page Object (PO)
Permite mantener la l√≥gica de interacci√≥n separada del test, evitando duplicaci√≥n y facilitando la reutilizaci√≥n.

{% raw %}
```javascript
// pageObjects/LoginPage.js
class LoginPage {
	visit() {
		cy.visit('/login')
	}
	login(email, password) {
		cy.get('#email').type(email)
		cy.get('#password').type(password)
		cy.get('form').submit()
	}
}

export default new LoginPage()
```
{% endraw %}`

{% raw %}
```javascript
// tests/login.cy.js
import LoginPage from '../pageObjects/LoginPage'

describe('Autenticaci√≥n de usuarios', () => {
	it('Permite iniciar sesi√≥n con credenciales v√°lidas', () => {
		LoginPage.visit()
		LoginPage.login('admin@test.com', '123456')
		cy.url().should('include', '/dashboard')
	})
})
```
{% endraw %}

### Patr√≥n Command Custom

Encapsula acciones comunes o flujos repetidos, extendiendo `cy` con comandos personalizados.

{% raw %}
```javascript
// support/commands.js
Cypress.Commands.add('loginAsAdmin', () => {
	cy.request('POST', '/api/auth/login', {
		email: 'admin@test.com',
		password: '123456'
	})
})
```
{% endraw %}

{% raw %}
```javascript
// ejemplo de uso
cy.loginAsAdmin()
cy.visit('/dashboard')
```
{% endraw %}

### Patr√≥n de Configuraci√≥n Din√°mica

Permite adaptar el entorno de ejecuci√≥n seg√∫n la rama, build o entorno (`staging`, `dev`, `prod`).

{% raw %}
```javascript
// cypress.config.js
module.exports = {
	e2e: {
		baseUrl: process.env.CYPRESS_BASE_URL || 'http://localhost:3000',
		env: {
			apiUrl: process.env.API_URL
		}
	}
}
```
{% endraw %}

## üöÄ Optimizaci√≥n y Escalabilidad

### Ejecuci√≥n Paralela y Balance de Carga

Cypress Cloud (antes Dashboard) permite distribuir tests en m√∫ltiples m√°quinas:

{% raw %}
```bash
npx cypress run --record --parallel --group "UI tests"
```
{% endraw %}

Beneficios:

* Reducci√≥n dr√°stica del tiempo total de test suite.
* Balanceo inteligente entre m√°quinas CI.
* Reportes centralizados por commit o rama.

### Minimizaci√≥n de Dependencias

Evita pruebas fr√°giles reduciendo dependencias externas:

* Usa `cy.intercept()` para simular API responses.
* Prepara fixtures realistas pero deterministas.
* Evita depender del backend en flujos cr√≠ticos.

### Limpieza de Estado

Emplea `beforeEach()` y `afterEach()` para restaurar estados previos:

{% raw %}
```javascript
beforeEach(() => cy.task('db:seed'))
afterEach(() => cy.clearCookies())
```
{% endraw %}

## üß∞ Estrategias de Datos y Fixtures

* Usa **fixtures din√°micos** para datos variables:

  {% raw %}
```javascript
  cy.fixture('users').then((user) => {
  	cy.get('#email').type(user.valid.email)
  })
  ```
{% endraw %}

* Integra **factories** o **seeders** para generar datos a medida.

* Crea **data layers** separados que abstraen los datos de test, similar a un ORM.

## üîí Testing de Seguridad y Permisos

* Simula roles y scopes JWT para validar acceso a rutas.
* Testea headers de seguridad (`X-Frame-Options`, `Content-Security-Policy`).
* Usa `cy.request()` para verificar endpoints protegidos:

  {% raw %}
```javascript
  cy.request({
  	url: '/api/admin',
  	failOnStatusCode: false
  }).its('status').should('eq', 401)
  ```
{% endraw %}

## üìä An√°lisis de Resultados y Mantenimiento de Suites

* Genera reportes con **Mochawesome**, **Allure**, o **JUnit**.
* Automatiza la exportaci√≥n a dashboards o herramientas BI.
* Analiza m√©tricas como:

  * Tiempo medio por test.
  * Frecuencia de fallos.
  * Tests intermitentes ("flaky tests").

{% raw %}
```bash
npx cypress run --reporter mochawesome
```
{% endraw %}

## üß¨ Testing Visual y Regresi√≥n

* Integra **Percy**, **Applitools** o **Happo** para comparar snapshots visuales.
* Detecta cambios en UI, layout o estilos.
* Ideal para flujos de frontend intensivo (dashboards, landing pages, formularios).

## üîÅ Integraci√≥n con Pipelines CI/CD

Ejemplo de pipeline CI (GitHub Actions):

{% raw %}
```yaml
name: E2E Tests

on: [push, pull_request]

jobs:
	e2e:
		runs-on: ubuntu-latest
		steps:
			- uses: actions/checkout@v4
			- uses: actions/setup-node@v4
			  with:
			  	node-version: 20
			- run: npm ci
			- run: npx cypress install
			- run: npx cypress run --record --headless
			  env:
			  	CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_KEY }}
```
{% endraw %}

## üß≠ Estrategias de Mantenimiento y Escalabilidad de Suites

* Divide suites por dominio (autenticaci√≥n, navegaci√≥n, API, UI).
* Implementa etiquetas o `grep` para ejecutar subconjuntos:

  {% raw %}
```bash
  npx cypress run --env grepTags=@critical
  ```
{% endraw %}
* Programa ejecuciones peri√≥dicas para monitorear regresiones.
* Prioriza tests cr√≠ticos en pipelines y difiere los secundarios a cron jobs.

## üß± Integraci√≥n con Backend y API Testing

Cypress puede usarse tambi√©n para testing de endpoints sin UI:

{% raw %}
```javascript
describe('API de productos', () => {
	it('Devuelve lista de productos', () => {
		cy.request('/api/products')
			.its('status')
			.should('eq', 200)
	})
})
```
{% endraw %}

Esto permite validar la coherencia entre backend y frontend sin necesidad de frameworks externos.

## üîó Enlaces y Referencias

* [Cypress Best Practices](https://docs.cypress.io/guides/references/best-practices)
* [Flaky Test Management](https://docs.cypress.io/guides/references/error-messages)
* [Cypress Cloud (Dashboard)](https://www.cypress.io/cloud)
* [Testing](/testing/testing/)
* [E2E - End to End Testing](/testing/e2e---end-to-end-testing/)
* [Automatizacion y Build](/uncategorized/automatizacion-y-build/)

# üß© Cypress - Testing Visual, Accesibilidad (a11y) y Estrategias de Observabilidad

## üëÅÔ∏è Testing Visual y Detecci√≥n de Regresiones de Interfaz

El testing visual en Cypress permite validar que **los cambios de c√≥digo no alteren la apariencia esperada de la interfaz**. Este enfoque se basa en comparar capturas de pantalla o snapshots generados autom√°ticamente durante la ejecuci√≥n de los tests.

### üß± Snapshot Testing con Plugins Visuales

Cypress puede integrarse con herramientas de comparaci√≥n visual para detectar diferencias p√≠xel a p√≠xel:

- **Percy**: comparaci√≥n autom√°tica de capturas de pantalla en m√∫ltiples resoluciones.
- **Applitools Eyes**: an√°lisis visual con inteligencia artificial.
- **Happo** o **Chromatic**: ideales para componentes de React o Storybook.

{% raw %}
```javascript
describe('Validaci√≥n visual del dashboard', () => {
	it('El dise√±o no cambia tras el despliegue', () => {
		cy.visit('/dashboard')
		cy.percySnapshot('dashboard-estado-inicial')
	})
})
```
{% endraw %}`

### üñºÔ∏è Capturas y Videos

Cypress genera autom√°ticamente:

* **Screenshots** en fallos (`cypress/screenshots`).
* **Videos** de la ejecuci√≥n (`cypress/videos`).

Configuraci√≥n en `cypress.config.js`:

{% raw %}
```javascript
module.exports = {
	video: true,
	screenshotOnRunFailure: true
}
```
{% endraw %}

Esto es esencial en CI/CD, ya que permite **auditar visualmente los errores** y detectar flujos rotos o UI corruptas sin necesidad de reproducir manualmente los pasos.

---

## ‚ôø Testing de Accesibilidad (a11y)

Cypress puede integrar herramientas como **axe-core** o **cypress-axe** para validar la accesibilidad de una aplicaci√≥n seg√∫n las pautas **WCAG** (Web Content Accessibility Guidelines).

### Ejemplo de Validaci√≥n Autom√°tica

{% raw %}
```javascript
import 'cypress-axe'

describe('Accesibilidad de la p√°gina de inicio', () => {
	beforeEach(() => {
		cy.visit('/')
		cy.injectAxe()
	})
	it('No tiene violaciones de accesibilidad', () => {
		cy.checkA11y()
	})
})
```
{% endraw %}

### Buenas Pr√°cticas de a11y con Cypress

* Ejecutar validaciones a11y como parte de los tests E2E regulares.
* Integrar validaciones por flujo: formularios, modales, navegaci√≥n.
* Aplicar reglas personalizadas seg√∫n roles o componentes cr√≠ticos.
* Configurar reportes accesibles en HTML o JSON para CI/CD.

---

## üîç Observabilidad y Trazabilidad en Cypress

### Logs y Depuraci√≥n Avanzada

Cypress ofrece **trazabilidad completa** del flujo de prueba:

* `cy.log()` para mensajes contextuales.
* `cy.task()` para ejecutar scripts Node.js durante el test.
* Integraci√≥n con herramientas como **Sentry** o **Datadog RUM** para correlacionar errores.

{% raw %}
```javascript
cy.task('log', 'Inicio de test de registro')
cy.log('Se complet√≥ el flujo correctamente')
```
{% endraw %}

### Registro de Eventos del Navegador

Se puede capturar errores de consola o peticiones fallidas:

{% raw %}
```javascript
Cypress.on('uncaught:exception', (err) => {
	cy.task('log', `Error detectado: ${err.message}`)
	return false
})
```
{% endraw %}

### Recolecci√≥n de M√©tricas de Ejecuci√≥n

* Tiempo total por test.
* Latencia en peticiones `cy.intercept()`.
* Captura de performance con `PerformanceObserver` del navegador.

Esto permite **analizar la degradaci√≥n progresiva** de la aplicaci√≥n y actuar antes de que el rendimiento afecte a los usuarios.

---

## üßÆ Estrategias de Rendimiento en E2E Testing

### Control de Recursos y Tiempo de Ejecuci√≥n

* Usa `cy.intercept()` para mockear respuestas lentas o err√°ticas.
* Limita la ejecuci√≥n con `CYPRESS_TEST_GROUP` o `grepTags`.
* Prioriza flujos cr√≠ticos y ejecuta los secundarios de forma diferida.

{% raw %}
```bash
npx cypress run --env grepTags=@smoke
```
{% endraw %}

### Pruebas Basadas en M√©tricas

Integra Cypress con APIs de rendimiento (`window.performance`) para registrar m√©tricas clave:

* **TTFB (Time to First Byte)**
* **FCP (First Contentful Paint)**
* **LCP (Largest Contentful Paint)**

{% raw %}
```javascript
cy.window().then((win) => {
	const timing = win.performance.timing
	const loadTime = timing.loadEventEnd - timing.navigationStart
	cy.log(`Tiempo de carga: ${loadTime}ms`)
})
```
{% endraw %}

---

## üß± Integraci√≥n con Storybook y Component Testing

Cypress puede integrarse con **Storybook** para validar componentes UI en aislamiento, combinando documentaci√≥n y testing.

{% raw %}
```javascript
cy.visitStory('Bot√≥n/Primario')
cy.get('button').should('have.text', 'Enviar')
```
{% endraw %}

Ventajas:

* Detecci√≥n temprana de roturas en componentes.
* Testing visual acoplado a la documentaci√≥n del dise√±o.
* Mejora de la comunicaci√≥n entre dise√±adores y desarrolladores.

---

## ü§ñ Integraci√≥n con AI y Generaci√≥n Autom√°tica de Tests

Emergen herramientas que complementan Cypress con IA:

* Generaci√≥n autom√°tica de flujos E2E a partir de la navegaci√≥n del usuario.
* An√°lisis de cobertura y sugerencias de test faltantes.
* Validaci√≥n predictiva de flujos m√°s propensos a fallar.

Ejemplos: **Testim.io**, **Reflect.run**, **Mabl** ‚Äî herramientas que usan Cypress o frameworks similares para aprendizaje de patrones de interacci√≥n.

---

## üß∞ Ecosistema Extendido

Complementos √∫tiles para entornos avanzados:

| Plugin / Tool                   | Descripci√≥n                                         |
| ------------------------------- | --------------------------------------------------- |
| `cypress-grep`                  | Ejecuta subconjuntos de tests por etiqueta o nombre |
| `cypress-real-events`           | Simula eventos reales del navegador                 |
| `cypress-fail-fast`             | Detiene la ejecuci√≥n tras el primer fallo cr√≠tico   |
| `cypress-wait-until`            | Control avanzado de asincron√≠a                      |
| `cypress-axe`                   | Validaciones de accesibilidad (a11y)                |
| `cypress-localstorage-commands` | Manejo simplificado de `localStorage`               |

---

## üîó Recursos y Notas Relacionadas

* [Cypress Component Testing](https://docs.cypress.io/guides/component-testing/overview)
* [Integraci√≥n con Storybook y UI Design Systems](https://storybook.js.org/docs/react/workflows/automated-testing)
* [Axe-core + Cypress Accessibility Testing](https://www.deque.com/axe/core-documentation/api-documentation/#api-name-check)
* [Testing](/testing/testing/)
* [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
* [E2E - End to End Testing](/testing/e2e---end-to-end-testing/)
* Frontend Testing
* QA Observability


# üß† Cypress - Integraci√≥n con APIs, Microservicios y Mocks de Infraestructura

$= dv.current().file.tags.join(" ")

## üåê Introducci√≥n

En entornos modernos basados en **microservicios y APIs distribuidas**, Cypress puede ser una herramienta clave para validar la **integraci√≥n entre frontend, backend y servicios externos**, sin depender de entornos productivos.

Su capacidad para interceptar peticiones, inyectar datos simulados y comunicarse con procesos Node.js permite **replicar comportamientos de red y dependencias complejas** (bases de datos, colas, autenticaci√≥n, etc.) de forma controlada.

---

## üîó Testing de Integraci√≥n entre Frontend y API

Cypress puede interactuar directamente con endpoints REST o GraphQL sin necesidad de UI. Esto permite verificar:
- Consistencia de datos devueltos por el backend.
- Autenticaci√≥n y permisos de acceso.
- Validaci√≥n de payloads y respuestas en diferentes estados (200, 404, 500).

{% raw %}
```javascript
describe('API de usuarios', () => {
	it('Devuelve la lista de usuarios activos', () => {
		cy.request('/api/users?status=active')
			.its('body')
			.should('be.an', 'array')
			.and('have.length.greaterThan', 0)
	})
})
```
{% endraw %}`

Tambi√©n es posible **encadenar acciones**:

1. Crear un registro mediante `cy.request(POST)`.
2. Consultarlo mediante `cy.request(GET)`.
3. Validar que el cambio se refleja en la UI.

{% raw %}
```javascript
cy.request('POST', '/api/users', { name: 'TestUser' })
cy.visit('/dashboard')
cy.contains('TestUser').should('exist')
```
{% endraw %}

---

## üß© Testing en Arquitecturas de Microservicios

### Estrategias

* **Testing de contratos (contract testing)**: valida que el frontend consuma las APIs con el formato esperado, usando herramientas como **Pact** junto con Cypress.
* **Simulaci√≥n de microservicios**: permite reemplazar temporalmente endpoints de terceros durante el test.
* **Validaci√≥n de flujos transversales**: verificar interacciones entre servicios (ej. autenticaci√≥n + notificaci√≥n + persistencia).

{% raw %}
```javascript
cy.intercept('POST', '/api/orders', {
	statusCode: 201,
	body: { id: 'mocked-001', status: 'CREATED' }
}).as('createOrder')

cy.visit('/checkout')
cy.get('button.confirm').click()
cy.wait('@createOrder').its('response.statusCode').should('eq', 201)
```
{% endraw %}

Ventajas:

* Control total sobre las dependencias.
* Mayor velocidad de ejecuci√≥n.
* Reducci√≥n de flakiness por servicios externos inestables.

---

## üß± Mocks de Infraestructura y Dependencias

### üßÆ Bases de Datos

Cypress puede interactuar con la base de datos de prueba usando tareas Node.js.
Por ejemplo, para restaurar datos o generar fixtures directamente antes del test:

{% raw %}
```javascript
// cypress/plugins/index.js
module.exports = (on, config) => {
	on('task', {
		'db:reset': () => {
			const { execSync } = require('child_process')
			execSync('npm run db:seed:test')
			return null
		}
	})
}
```
{% endraw %}

{% raw %}
```javascript
beforeEach(() => cy.task('db:reset'))
```
{% endraw %}

Esto permite mantener un **estado determinista** en cada ejecuci√≥n, esencial para suites E2E extensas.

### üí¨ Colas de Mensajer√≠a (RabbitMQ, Kafka, SQS)

En flujos que dependen de eventos as√≠ncronos, puedes usar tareas Node.js para **publicar o consumir mensajes simulados**:

{% raw %}
```javascript
cy.task('mockQueueEvent', {
	type: 'order.created',
	payload: { id: 123, user: 'test' }
})
```
{% endraw %}

O interceptar las APIs intermedias que simulan la publicaci√≥n del mensaje:

{% raw %}
```javascript
cy.intercept('POST', '/api/events', { statusCode: 200 }).as('mockEvent')
```
{% endraw %}

Esto evita depender de una infraestructura real de colas en el entorno de testing.

---

## üîÑ Integraci√≥n con Servicios Externos

### Ejemplo: APIs de terceros (Stripe, Google Maps, Twilio)

En entornos CI/CD o pruebas locales, se deben **mockear respuestas externas** para evitar costos o efectos colaterales:

{% raw %}
```javascript
cy.intercept('POST', 'https://api.stripe.com/v1/payment_intents', {
	statusCode: 200,
	body: { id: 'pi_mock_123', status: 'succeeded' }
}).as('stripeMock')
```
{% endraw %}

De igual modo, se pueden interceptar APIs de autenticaci√≥n (OAuth, Firebase, Auth0):

{% raw %}
```javascript
cy.intercept('POST', 'https://auth0.com/oauth/token', {
	body: { access_token: 'fake-token-123' }
})
```
{% endraw %}

Ventajas:

* Pruebas seguras y reproducibles.
* No se exponen credenciales reales.
* Reducci√≥n de latencia y dependencia de red.

---

## üß† Mocking Din√°mico de Respuestas

Cypress permite alterar din√°micamente respuestas seg√∫n el escenario de prueba:

{% raw %}
```javascript
cy.intercept('GET', '/api/profile', (req) => {
	if (req.headers['x-test-scenario'] === 'error') {
		req.reply({ statusCode: 500, body: { error: 'Server error' } })
	} else {
		req.reply({ statusCode: 200, body: { name: 'Eduardo' } })
	}
})
```
{% endraw %}

Esto permite crear suites flexibles para:

* Escenarios felices (happy path).
* Casos de error (errores 4xx, 5xx).
* Tests de resiliencia.

---

## üß∞ Testing de Integraci√≥n Multi-Capa

Cypress puede integrarse con **Postman collections**, **Swagger/OpenAPI**, o **GraphQL schemas** para validar coherencia entre capas.

### GraphQL

{% raw %}
```javascript
cy.request('POST', '/graphql', {
	query: `{ getUser(id: "123") { id name email } }`
}).its('body.data.getUser').should('have.property', 'email')
```
{% endraw %}

### Validaci√≥n con OpenAPI

Puedes usar `cy.task()` para comparar respuestas reales con el contrato OpenAPI (por ejemplo, mediante `openapi-schema-validator`).

---

## üß¨ Estrategias para Entornos Complejos

1. **Mocks h√≠bridos**: combinar respuestas reales con simulaciones parciales.
2. **Test de integraci√≥n incremental**: validar cada microservicio por separado antes del flujo completo.
3. **Capa de precondiciones** (`setup tasks`): inicializa datos, mocks o colas antes del test.
4. **Snapshot de infraestructura**: guardar y restaurar estados de base de datos o colas antes/despu√©s de suites.

---

## üßæ Reportes y Auditor√≠a en Arquitecturas Distribuidas

En pipelines distribuidos, Cypress puede:

* Exportar logs y m√©tricas de requests interceptadas.
* Integrarse con **Elastic Stack (ELK)**, **Grafana Loki**, o **Datadog** para centralizar m√©tricas.
* Registrar correlaciones entre microservicios mediante IDs o `trace headers`.

{% raw %}
```javascript
cy.intercept('*', (req) => {
	console.log(`[TRACE] ${req.method} ${req.url}`)
})
```
{% endraw %}

---

## üß© Casos Reales de Uso

| Caso                    | Descripci√≥n                                | Beneficio                               |
| ----------------------- | ------------------------------------------ | --------------------------------------- |
| **E-commerce**          | Mock de pagos Stripe y simulaci√≥n de stock | Evita errores costosos en sandbox       |
| **Aplicaci√≥n SaaS**     | Validaci√≥n multiusuario y roles en Auth0   | Pruebas seguras sin tokens reales       |
| **Microservicios IoT**  | Simulaci√≥n de colas MQTT/Kafka             | Testing de flujos asincr√≥nicos          |
| **Plataformas Fintech** | Validaci√≥n de APIs bancarias REST          | Cumplimiento regulatorio y consistencia |

---

## üß≠ Conclusiones

El poder real de Cypress en entornos distribuidos surge cuando se usa **no solo como framework de UI testing**, sino como **orquestador de escenarios complejos** que involucran red, bases de datos y microservicios.

Su integraci√≥n con APIs, colas y servicios externos permite:

* Probar resiliencia del sistema.
* Simular fallos de infraestructura.
* Mantener consistencia de datos entre capas.
* Validar contratos entre frontend y backend sin dependencias reales.

---

## üîó Referencias y Notas Relacionadas

* [Cypress Intercept API](https://docs.cypress.io/api/commands/intercept)
* [Cypress Network Testing Strategies](https://docs.cypress.io/guides/guides/network-requests)
* [Pact Contract Testing](https://docs.pact.io/)
* [Mocking External APIs in Cypress](https://www.cypress.io/blog/2022/06/21/how-to-mock-http-requests/)
* [Testing](/testing/testing/)
* Microservicios
* [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
* Integracion Continua
* [E2E - End to End Testing](/testing/e2e---end-to-end-testing/)
* Arquitectura Distribuida
* QA Observability

# üß© Integraci√≥n Cypress + APIs Externas + Microservicios + Mocks de Infraestructura

## üîó Testing de Integraciones Complejas

Cypress no solo sirve para probar la interfaz de usuario; tambi√©n permite validar la **integraci√≥n entre el frontend, las APIs y los microservicios** que conforman una arquitectura distribuida moderna.  
El objetivo es garantizar la coherencia entre capas, incluso cuando existen **dependencias externas o servicios no disponibles** en el entorno local.

### Estrategias Generales

- **Simular ecosistemas reales**: probar flujos que atraviesan m√∫ltiples servicios (frontend ‚Üí API Gateway ‚Üí microservicios).
- **Aislar servicios no cr√≠ticos** mediante mocks o stubs, evitando dependencias vol√°tiles.
- **Sincronizar estados** entre bases de datos, colas o cach√©s para garantizar resultados deterministas.
- **Automatizar pipelines** de prueba donde Cypress valide tanto la UI como las respuestas de los microservicios simulados o reales.

---

## üß† Mocking y Stubbing de Infraestructura

Cuando una aplicaci√≥n interact√∫a con m√∫ltiples capas, es necesario **mockear los puntos de integraci√≥n** sin romper la coherencia del sistema.

### Tipos de Mocks

- **Mocks de API REST / GraphQL**  
Cypress permite interceptar peticiones HTTP con `cy.intercept()`, respondiendo con datos predefinidos:
{% raw %}
```javascript
cy.intercept('GET', '/api/users', { fixture: 'users.json' }).as('getUsers')
cy.visit('/users')
cy.wait('@getUsers').its('response.statusCode').should('eq', 200)
```
{% endraw %}

- **Mocks de bases de datos**  
Simular resultados de queries o estados de entidad mediante fixtures o endpoints falsos:
{% raw %}
```javascript
cy.intercept('POST', '/api/db/query', { body: { result: [] } })
```
{% endraw %}
Ideal cuando no hay acceso directo a la DB o se usa un **Data Mock Layer** (p. ej., SQLite in-memory).

- **Mocks de colas y mensajer√≠a**  
Simular flujos de **RabbitMQ, Kafka o Redis Streams** mediante endpoints HTTP intermedios o eventos WebSocket falsos:
{% raw %}
```javascript
cy.intercept('POST', '/events/publish', { statusCode: 200, body: { ok: true } })
```
{% endraw %}

- **Mocks de servicios externos (APIs p√∫blicas o SaaS)**  
Evitar consumo de APIs reales (Stripe, SendGrid, etc.) con respuestas almacenadas:
{% raw %}
```javascript
cy.intercept('POST', 'https://api.stripe.com/**', { fixture: 'stripe/charge_success.json' })
```
{% endraw %}

---

## ‚öôÔ∏è Testing en Arquitecturas de Microservicios

En entornos donde los servicios se comunican entre s√≠, el testeo requiere una estrategia **gradual y distribuida**.

### Enfoques de Prueba

1. **Pruebas Contractuales (Consumer-Driven Contracts)**  
	Validar que los microservicios cumplan con los contratos definidos entre consumidor y proveedor (p. ej. con Pact).  
	Puede integrarse en Cypress ejecutando validaciones en endpoints antes de probar la UI.

2. **Pruebas de Integraci√≥n Parcial**  
	Levantar solo los microservicios necesarios (API Gateway + servicio A), y mockear el resto.  
	Cypress act√∫a como cliente final y verifica el flujo sin necesidad de desplegar toda la red.

3. **Pruebas End-to-End distribuidas**  
	Se ejecutan contra la infraestructura completa en un entorno de staging.  
	Cypress puede orquestar las pruebas mientras monitorea logs o m√©tricas externas (via Grafana o Prometheus) para correlacionar eventos.

---

## üß™ Testing de APIs en Conjunto con la UI

Cypress permite **verificar las APIs directamente desde el mismo flujo E2E** que testea la interfaz.

{% raw %}
```javascript
cy.request('/api/orders')
	.its('status')
	.should('eq', 200)

cy.get('[data-cy=order-list]').should('contain', 'Pedido #1234')
```
{% endraw %}`

Esto garantiza que el **dato mostrado en la UI coincide con la respuesta real de la API**.
Adem√°s, se pueden **encadenar validaciones** que comparen resultados entre capas.

---

## üîÑ Integraci√≥n con Entornos Dockerizados y Mock Servers

En arquitecturas distribuidas, es com√∫n levantar entornos de prueba con **Docker Compose** o herramientas como WireMock o MockServer.

Ejemplo de configuraci√≥n minimalista:

{% raw %}
```yaml
version: '3'
services:
	api:
		image: my-api:latest
	mock-server:
		image: wiremock/wiremock
		ports:
			- "8080:8080"
	cypress:
		image: cypress/included:13.2.0
		depends_on:
			- api
			- mock-server
```
{% endraw %}

Esto permite a Cypress ejecutar los tests **contra endpoints simulados**, garantizando repetibilidad.

---

## üìä Monitoreo y Validaci√≥n de Infraestructura

En entornos reales, los test E2E pueden incluir validaciones de **logs, colas o m√©tricas**.

Ejemplo: comprobar que un evento fue publicado en una cola simulada o API de tracking.

{% raw %}
```javascript
cy.request('/mock-queue/events')
	.its('body')
	.should('include', { type: 'USER_CREATED' })
```
{% endraw %}

Esto permite garantizar que los flujos as√≠ncronos funcionan correctamente, incluso cuando el backend no expone feedback inmediato en la UI.

---

## üß∞ Buenas Pr√°cticas

* Centralizar los mocks en una carpeta `cypress/fixtures/infra/` con nombres consistentes.
* Usar alias (`cy.intercept().as()`) para sincronizar flujos complejos.
* Mantener configuraciones por entorno (dev, staging, ci) en `cypress.config.js`.
* Validar contratos y esquemas JSON con AJV o Zod dentro de los tests.
* Desacoplar dependencias mediante interfaces de prueba (`/__mock__/` endpoints).
* Automatizar pruebas distribuidas con pipelines CI/CD que desplieguen los servicios necesarios antes del test.

---

## üîÆ Extensiones y Ecosistema

* WireMock / MockServer ‚Üí mock de APIs externas.
* Pact ‚Üí contract testing entre microservicios.
* Docker Compose / Testcontainers ‚Üí orquestaci√≥n de entornos ef√≠meros.
* Nock / MSW ‚Üí mocks HTTP en Node.js (para usar junto a Cypress Component Testing).
* Postman Collections + Cypress ‚Üí validaci√≥n dual UI/API.
* Grafana Loki + Prometheus ‚Üí correlaci√≥n entre tests y m√©tricas.

---

## üß≠ Conclusi√≥n

La integraci√≥n de **Cypress con ecosistemas de microservicios y APIs externas** expande el alcance del testing E2E a escenarios de infraestructura real.
El uso de **mocks, entornos orquestados y validaci√≥n distribuida** permite asegurar que el sistema completo, desde la UI hasta las capas m√°s profundas, **funciona de forma coherente, resiliente y predecible**, incluso en entornos altamente desacoplados.
√ß




