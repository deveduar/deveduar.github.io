---
date: 2024-11-18 21:27
title: api
tags:
  - api
  - swagger
  - openapi
  - fastapi
  - webservices
keywords:
source:
status: üöÄ
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Backend
public_note: "true"
category: Backend
---
# API
`$= dv.current().file.tags.join(" ")`

- [Backend](/uncategorized/backend/)
- [FastApi](/backend/fastapi/)
- [OpenAPI](/backend/openapi/)
- [web services](/backend/web-services/)
- [webhooks](/backend/webhooks/)
- [microservicios](/backend/microservicios/)
- [GraphQL](/backend/graphql/)
- [XML](/databases/xml/)
- [JMeter](/testing/jmeter/)
- [axios](/backend/axios/)
- [ngrok](/backend/ngrok/)
- SOAP
- Rest
- fetch

---

## Concepto general

Una **API** (Application Programming Interface) define un conjunto de reglas que permiten la comunicaci√≥n entre diferentes sistemas, aplicaciones o servicios. Es una capa de abstracci√≥n que facilita la interoperabilidad y desacopla los componentes.  
Su dise√±o adecuado influye directamente en la **escalabilidad**, **seguridad**, **rendimiento** y **mantenibilidad** del sistema.

---

## Tipos principales de APIs

- **APIs locales**: entre m√≥dulos o librer√≠as dentro del mismo proceso o aplicaci√≥n.  
- **APIs remotas**: comunicaci√≥n entre sistemas a trav√©s de red, generalmente sobre HTTP o gRPC.  
- **APIs abiertas (Open API / Public APIs)**: expuestas p√∫blicamente para que otros desarrolladores las utilicen.  
- **APIs privadas**: usadas internamente dentro de una organizaci√≥n.  
- **APIs de partners**: restringidas a socios o clientes espec√≠ficos, con control de acceso.

---

## Estilos y tecnolog√≠as

### REST
- Basado en el protocolo HTTP y el concepto de **transferencia de estado representacional**.  
- Cada recurso tiene un **URI** √∫nico y se accede mediante **verbos HTTP** (`GET`, `POST`, `PUT`, `DELETE`, `PATCH`).  
- Se apoya en formatos ligeros como **JSON**.  
- Escalable y f√°cil de cachear.

#### Buenas pr√°cticas
- Versionar rutas (`/api/v1/...`)
- Usar respuestas consistentes con c√≥digos HTTP adecuados.
- Incluir **paginaci√≥n**, **filtros** y **ordenamiento**.
- Evitar sobrecargar endpoints.

---

### SOAP
- Basado en **XML** y **mensajer√≠a estructurada** mediante el protocolo HTTP o SMTP.  
- Enfocado en **transacciones seguras y complejas** (banca, seguros, etc.).  
- Requiere un **WSDL (Web Services Description Language)** para describir los m√©todos disponibles.  
- M√°s estricto y pesado que REST, pero m√°s formal y estandarizado.

---

### [GraphQL](/backend/graphql/)
- Define un **lenguaje de consultas** que permite al cliente especificar exactamente qu√© datos necesita.  
- Optimiza las llamadas, evitando **overfetching** y **underfetching**.  
- Ideal para **frontends modernos** (React, Vue, etc.) y microservicios.  
- Requiere un **schema** fuertemente tipado y un **resolutor** por cada campo o tipo.  

---

### [FastApi](/backend/fastapi/)
- Framework de Python moderno y as√≠ncrono para construir APIs REST o h√≠bridas.  
- Integraci√≥n nativa con [OpenAPI](/backend/openapi/) y [swagger](/backend/swagger/) para documentaci√≥n autom√°tica.  
- Soporta validaci√≥n mediante `Pydantic` y es altamente eficiente gracias a `Starlette`.

---

## Documentaci√≥n

### [OpenAPI](/backend/openapi/) y [swagger](/backend/swagger/)
- Permiten **describir, probar y documentar** APIs REST de forma estandarizada.  
- Swagger UI genera interfaces visuales para interactuar con los endpoints.  
- OpenAPI define un formato JSON/YAML que describe rutas, modelos y respuestas.  

Ejemplo b√°sico de definici√≥n OpenAPI (YAML):

{% raw %}
```yaml
openapi: 3.0.0
info:
	title: Sample API
	version: 1.0.0
paths:
	/users:
		get:
			summary: Get all users
			responses:
				'200':
					description: List of users
```
{% endraw %}`

---

## Pruebas de APIs

### [JMeter](/testing/jmeter/)

* Herramienta para pruebas de **rendimiento, carga y estr√©s** en servicios web.
* Permite crear **escenarios concurrentes** y analizar m√©tricas de latencia, throughput y errores.

---

## Clientes y testing local

### [axios](/backend/axios/)

* Cliente HTTP basado en Promesas para JavaScript.
* Facilita las peticiones AJAX o RESTful desde frontend o Node.js.
* Soporta interceptores, cancelaci√≥n de peticiones y configuraci√≥n global de cabeceras.

Ejemplo b√°sico:

{% raw %}
```js
axios.get('/api/users')
	.then(response => console.log(response.data))
	.catch(error => console.error(error));
```
{% endraw %}

---

### fetch

* API nativa de JavaScript para realizar solicitudes HTTP.
* Basada en Promesas, m√°s moderna que `XMLHttpRequest`.

Ejemplo b√°sico:

{% raw %}
```js
fetch('/api/users')
	.then(res => res.json())
	.then(data => console.log(data))
	.catch(err => console.error(err));
```
{% endraw %}

---

### [ngrok](/backend/ngrok/)

* T√∫nel seguro que expone servicios locales a Internet mediante una URL p√∫blica.
* Ideal para probar **webhooks** o APIs en desarrollo sin desplegarlas.

---

## APIs y [microservicios](/backend/microservicios/)

* Cada microservicio suele exponer su propia API independiente.
* Comunicaci√≥n entre ellos mediante REST, GraphQL, gRPC o colas de mensajes (RabbitMQ, Kafka).
* Es com√∫n usar **API Gateways** para unificar rutas, aplicar pol√≠ticas de seguridad y manejar versiones.

---

## [web services](/backend/web-services/)

* T√©rmino general para describir servicios accesibles v√≠a red.
* Incluye tanto REST como SOAP.
* Pueden implementarse en arquitecturas monol√≠ticas, distribuidas o basadas en microservicios.

---

## Consideraciones finales

* Aplicar **seguridad** con OAuth2, [JWT](/autenticacion/jwt/) o API Keys.
* Implementar **rate limiting** y **monitorizaci√≥n**.
* Usar **versionado** y **documentaci√≥n viva** para mantener compatibilidad.
* Adoptar pr√°cticas de **observabilidad**: logs estructurados, m√©tricas y trazas distribuidas.

# API  Nuevos Conceptos y Temas Complementarios

### Escalabilidad, rendimiento y estado
- **Estado y ‚Äústateless‚Äù**  
	- Un sistema que sigue los principios de Representational State Transfer (REST) debe ser *stateless*: cada petici√≥n del cliente al servidor debe contener toda la informaci√≥n necesaria para procesarla. :contentReference[oaicite:2]{index=2}  
	- Esto permite mejor escalabilidad horizontal, ya que cualquier nodo puede responder sin dependencias del estado de otros nodos.  
- **Cacheado y rendimiento**  
	- En REST se puede aprovechar el cach√© HTTP (ETags, Cache-Control) para reducir la carga del servidor.  
	- En arquitecturas de microservicios opcionales, se deben considerar tambi√©n colas, mensajer√≠a as√≠ncrona o WebSockets para mejorar la tolerancia a fallos.

### Modelo de madurez de las APIs
- Richardson Maturity Model (RMM) eval√∫a qu√© tan ‚ÄúRESTful‚Äù es una API seg√∫n niveles de adopci√≥n de recursos, verbos HTTP, hipermedia. :contentReference[oaicite:4]{index=4}  
	- Nivel 0: todo pasa por un √∫nico endpoint (como RPC).  
	- Nivel 1: recursos con URIs distintas.  
	- Nivel 2: uso de verbos HTTP correctos.  
	- Nivel 3: hipermedia (HATEOAS) ‚Äî enlaces din√°micos en las respuestas.  
- Este modelo ayuda a dise√±ar y valorar APIs m√°s maduras y flexibles.

### Gesti√≥n y ciclo de vida de APIs
- API management engloba la administraci√≥n del ciclo de vida de una API: dise√±o, publicaci√≥n, versiones, seguridad, anal√≠tica. :contentReference[oaicite:6]{index=6}  
- Componentes clave:  
	- Puerta de enlace de API (API Gateway) para autenticar, limitar peticiones, enrutar.  
	- Portal de desarrolladores y comunidad para que terceros descubran, prueben y usen tus APIs.  
	- Versionado de API: mantener compatibilidad retroactiva mientras avanzas con nuevas versiones (/v1, /v2, etc.).  
	- M√©tricas de uso: latencia, tasa de errores, volumen de datos, usuarios activos.

### Seguridad, autenticaci√≥n y autorizaci√≥n
- Autenticaci√≥n: Verificar identidad (por ejemplo, mediante OAuth 2.0, JWT).  
- Autorizaci√≥n: Determinar qu√© puede hacer ese usuario/cliente.  
- TLS/HTTPS obligatorio para APIs p√∫blicas.  
- Pol√≠ticas de **rate limiting** y **throttling** para prevenir abuso.  
- Sanitizaci√≥n de entradas, validaci√≥n de esquemas, uso de CORS (cuando proceda).

### Protocolos y formatos alternativos
- M√°s all√° de REST, SOAP y GraphQL, hay otros enfoques:  
	- RPC con formatos binarios: gRPC + Protocol Buffers (alto rendimiento en microservicios internos).  
	- WebSockets para comunicaci√≥n bidireccional cont√≠nua (chat, colaboraci√≥n en tiempo real).  
	- HTTP/2 o HTTP/3 para mejorar multiplexado y latencia.  
- Formatos de datos: JSON, XML, YAML, o binarios (Protocol Buffers, MessagePack).

### Contratos de API, esquemas y generaci√≥n de c√≥digo
- Una especificaci√≥n como OpenAPI Specification (OAS) describe rutas, par√°metros, respuestas, esquemas de datos. :contentReference[oaicite:10]{index=10}  
- Se puede generar autom√°ticamente:  
	- Documentaci√≥n interactiva (como Swagger UI) :contentReference[oaicite:12]{index=12}  
	- SDKs cliente en varios lenguajes.  
	- Validaci√≥n de solicitudes/respuestas contra el contrato.  
- Importante para lograr coherencia entre servidor, cliente y documentaci√≥n.

### Arquitecturas basadas en microservicios y APIs internas
- En una arquitectura de microservicios:  
	- Las APIs internas pueden comunicarse mediante REST, GraphQL, eventos o colas de mensajes.  
	- Se suele usar un **API Gateway** para exponer un ‚Äúfrente unificado‚Äù al exterior.  
	- Considerar **desacoplamiento**, **tolerancia a fallos**, **fallbacks**, **circuit breaker** (patr√≥n de resiliencia).  
- Importante gestionar la observabilidad: logs distribuidos, trazas (Distributed Tracing), m√©tricas (latencia, fallo), alertas.

### Versionado y compatibilidad
- Versionar tu API ayuda a evitar romper clientes cuando cambias la l√≥gica.  
	- Estrategias: rutas (/v1), encabezados (Accept), par√°metros de consulta (version=).  
- Mantener backward‚Äêcompatibility siempre que sea posible: agregar campos nuevos opcionalmente, no eliminar existentes sin aviso.

### Errores, respuestas y consistencia
- Respuestas consistentes: cuerpo estructurado de errores, c√≥digos HTTP correctos (400, 401, 404, 500, etc).  
- Ejemplo de estructura de error:

	{% raw %}
```json
	{
		"error": {
			"code": "INVALID_PARAMETER",
			"message": "El par√°metro ‚Äòemail‚Äô debe ser v√°lido",
			"parameter": "email"
		}
	}
	```
{% endraw %}

- Documentar claramente qu√© errores puede devolver tu API y en qu√© condiciones.

### Automatizaci√≥n, testing y CI/CD
- Automatizar tests de integraci√≥n de APIs: asegurar que los endpoints funcionen como se espera.  
- Integrar pruebas de rendimiento/carga (como con JMeter) para medir escalabilidad.  
- Monitorear en producci√≥n: latencia, errores, uso de recursos, cumplimiento de SLA.  
- Desplegar mediante pipelines de CI/CD: aseg√∫rate de que al hacer una nueva versi√≥n se ejecuten tests, validaci√≥n de contrato, rollback en caso de fallo.

### Tendencias y retos actuales
- APIs basadas en eventos (Event-driven). En lugar de solo peticiones, los servicios emiten eventos que otros consumen.  
- API First design: definir el contrato (OpenAPI) antes de implementar.  
- Integraci√≥n con arquitectura serverless o funciones como servicio (FaaS).  
- Documentaci√≥n generada autom√°ticamente, ‚Äúdocs as code‚Äù, esquemas versionados.  
- Uso de Inteligencia Artificial para generar y mantener APIs/documentaci√≥n.  
- Retos de gobernanza: m√∫ltiples microservicios, gran n√∫mero de APIs internas/expuestas, control de pol√≠ticas, seguridad, costes.

## Resumen ampliado
Esta ampliaci√≥n aborda aspectos que facilitan la creaci√≥n, mantenimiento y operaci√≥n de APIs en entornos reales y complejos: desde dise√±o avanzado, operaci√≥n, escalabilidad, seguridad, hasta gobernanza y futuras direcciones. A√±ade un marco m√°s completo para que la nota en Obsidian tenga tambi√©n los ‚Äúaspectos de producci√≥n‚Äù que muchas veces se pasan por alto.

# API ‚Äî Extensi√≥n Avanzada  
`$= dv.current().file.tags.join(" ")`

### API Gateway y patrones de integraci√≥n
- **API Gateway**  
	- Es el punto de entrada √∫nico para todas las peticiones hacia los microservicios.  
	- Funciones clave: autenticaci√≥n centralizada, limitaci√≥n de tr√°fico, compresi√≥n, enrutamiento, logging, agregaci√≥n de respuestas y control de versiones.  
	- Ejemplos: **Kong**, **NGINX**, **Traefik**, **Apigee**, **AWS API Gateway**, **Istio Ingress**.  
- **Patrones comunes**  
	- *Backend for Frontend (BFF)*: API espec√≠fica para un tipo de cliente (m√≥vil, web, IoT).  
	- *API Composition*: combinar varias APIs internas en una sola respuesta externa.  
	- *Service Mesh*: delegar la comunicaci√≥n entre microservicios a un plano de datos (Istio, Linkerd).  
	- *Circuit Breaker*: proteger de cascadas de errores mediante l√≠mites de reintentos o respuestas por defecto.

---

### Observabilidad y monitoreo
- **Logs estructurados**: emitir en formato JSON con campos est√°ndar (`timestamp`, `service`, `trace_id`, `status`, etc.).  
- **M√©tricas**: latencia, throughput, tasa de error, tama√±o de payload, tiempos de respuesta por endpoint.  
- **Trazas distribuidas**: con sistemas como **OpenTelemetry**, **Jaeger** o **Zipkin** para seguir peticiones entre microservicios.  
- **Dashboards**: Prometheus + Grafana para visualizar m√©tricas.  
- **Alertas**: definir umbrales de rendimiento, errores 5xx o tiempos de respuesta elevados.

---

### Gobernanza y control de versiones
- **Cat√°logo de APIs**: repositorio central que lista todas las APIs disponibles, sus propietarios, versiones, esquemas y pol√≠ticas.  
- **Pol√≠ticas de publicaci√≥n**: definir qui√©n puede exponer nuevas APIs o modificar existentes.  
- **Control de acceso**: integraci√≥n con IAM (Identity & Access Management).  
- **Deprecaci√≥n controlada**: anunciar cambios con tiempo, ofrecer periodo de coexistencia, automatizar eliminaci√≥n de endpoints antiguos.  

---

### Estrategias de dise√±o de contrato
- **Design-first (API First)**: escribir la especificaci√≥n OpenAPI antes del c√≥digo, validando el dise√±o con clientes internos.  
- **Code-first**: generar la especificaci√≥n a partir del c√≥digo de los endpoints existentes.  
- **Hybrid approach**: sincronizar contrato y c√≥digo en pipelines autom√°ticos.  
- **Contratos como fuente de verdad**: centralizar validaciones, generaci√≥n de SDKs y documentaci√≥n a partir de un solo esquema.  

---

### Testing avanzado de APIs
- **Tipos de pruebas**  
	- *Unitarias*: validan controladores y l√≥gica interna.  
	- *Integraci√≥n*: verifican dependencias con bases de datos o servicios externos.  
	- *Contract testing*: verifica que cliente y servidor cumplen el contrato (con herramientas como **Pact**).  
	- *Smoke testing*: comprobar que las rutas principales responden tras despliegue.  
	- *End-to-end*: flujo completo del usuario o consumidor.  
- **Automatizaci√≥n**  
	- Integrar tests en CI/CD.  
	- Generar datos de prueba realistas.  
	- Analizar cobertura por endpoint.  

---

### Seguridad avanzada
- **OAuth 2.0 / OpenID Connect**: autenticaci√≥n y autorizaci√≥n delegada, tokens de acceso y refresh.  
- **JWT (JSON Web Token)**: portadores de identidad firmados que permiten autenticaci√≥n sin estado.  
- **API Keys y scopes**: control de permisos granular.  
- **HMAC / firmas**: verificaci√≥n de integridad en webhooks.  
- **CORS avanzado**: definir or√≠genes, m√©todos y cabeceras permitidos; evitar exposici√≥n excesiva.  
- **Auditor√≠a y trazabilidad**: registrar qui√©n accede a qu√© endpoint y cu√°ndo.  
- **Rate-limiting din√°mico**: basado en roles o planes de suscripci√≥n.  

---

### APIs en tiempo real
- **WebSockets**: comunicaci√≥n persistente full-duplex entre cliente y servidor.  
- **Server-Sent Events (SSE)**: flujo unidireccional desde servidor hacia cliente.  
- **gRPC streaming**: env√≠o continuo de mensajes binarios de alto rendimiento.  
- **MQTT / AMQP**: protocolos ligeros para IoT y mensajer√≠a en entornos distribuidos.  
- **Webhook**: mecanismo de *push* basado en HTTP; √∫til para notificaciones, integraciones externas y eventos.  

Ejemplo b√°sico de webhook en Flask:

{% raw %}
```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def receive_webhook():
	data = request.json
	print("Evento recibido:", data)
	return '', 204
```
{% endraw %}`

---

### Versionado sem√°ntico y evoluci√≥n

* **Versionado sem√°ntico (semver)** aplicado a APIs:

  * Cambios incompatibles ‚Üí versi√≥n mayor (v2).
  * Nuevas funcionalidades compatibles ‚Üí menor (v1.1).
  * Parches o correcciones ‚Üí parche (v1.0.1).
* **Gesti√≥n de compatibilidad**

  * Feature flags para activar gradualmente nuevas versiones.
  * Gateways que enrutan por versi√≥n.
  * Documentaci√≥n que indique diferencias por versi√≥n.

---

### API Analytics y m√©tricas de negocio

* Analizar datos de consumo:

  * Endpoints m√°s usados, usuarios activos, tasa de error.
  * Impacto en ingresos (para APIs comerciales).
* Correlacionar m√©tricas t√©cnicas con m√©tricas de negocio: tiempo medio de respuesta vs retenci√≥n de usuarios.
* Uso de herramientas de API Analytics: **Kong Enterprise**, **Apigee**, **AWS CloudWatch**, **Elastic Stack**.

---

### APIs comerciales y monetizaci√≥n

* **Modelos de negocio**

  * *Freemium*: uso limitado gratuito, pago por volumen.
  * *Subscription*: tarifa fija mensual o anual.
  * *Pay-per-use*: cobro por llamada o recurso consumido.
* **Gesti√≥n de clientes**

  * Portales de desarrolladores con registro, documentaci√≥n y claves de acceso.
  * Paneles de facturaci√≥n y cuotas.
* **Integraci√≥n con pasarelas de pago** y sistemas de facturaci√≥n autom√°ticos.

---

### API Design Patterns

* **Collection Pattern**: recursos representados como colecciones y elementos (`/users` ‚Üí lista, `/users/{id}` ‚Üí detalle).
* **Sub-resources**: reflejar jerarqu√≠as (`/users/{id}/orders`).
* **Batching**: varias operaciones en una sola petici√≥n.
* **Pagination**: `limit`, `offset`, `nextCursor`.
* **Filtering y sorting**: `?status=active&sort=-date`.
* **Partial update (PATCH)**: modificaci√≥n parcial del recurso.
* **Error-envelope pattern**: estructura consistente de errores.
* **Hypermedia links (HATEOAS)**: respuestas con enlaces a operaciones relacionadas.

---

### API Documentation as Code

* Mantener la documentaci√≥n junto al c√≥digo fuente.
* Validaci√≥n autom√°tica en cada commit (linting de OpenAPI).
* Generaci√≥n de portales est√°ticos (ReDoc, Swagger UI, Docusaurus).
* Versionado de documentaci√≥n en paralelo al c√≥digo.
* Pruebas automatizadas que comparen ejemplos documentados con respuestas reales.

---

### Seguridad de transporte y cifrado

* **TLS obligatorio** para todas las conexiones externas.
* Renovaci√≥n y rotaci√≥n autom√°tica de certificados (ACME, Let‚Äôs Encrypt).
* Validaci√≥n mutua (mTLS) en entornos internos sensibles.
* Protecci√≥n frente a ataques comunes:

  * *Replay Attack*: tokens de un solo uso o timestamps.
  * *Injection*: validaci√≥n estricta de entrada.
  * *Cross-Site Scripting (XSS)* y *CSRF*: cabeceras seguras y tokens.

---

### Integraciones h√≠bridas y legacy

* Adaptadores (API Adapters) que exponen sistemas antiguos como REST/GraphQL.
* Uso de **API Orchestration Layers** para integrar m√∫ltiples backends dispares.
* *API Facades*: crear interfaces simplificadas sobre servicios complejos.
* Migraci√≥n progresiva de SOAP a REST o GraphQL mediante gateways h√≠bridos.

---

### Futuro de las APIs

* **Declarative APIs**: definir comportamiento en YAML/JSON, ejecutado por plataformas sin servidor.
* **Machine-Generated APIs**: creaci√≥n y actualizaci√≥n autom√°tica mediante IA.
* **Zero-code / Low-code APIs**: plataformas que permiten exponer datos sin escribir c√≥digo.
* **Interoperabilidad sem√°ntica**: uso de vocabularios y esquemas compartidos (JSON-LD, Schema.org).
* **API Contracts Validation at Runtime**: validar en producci√≥n que las respuestas cumplen el contrato.
* **Edge APIs**: ejecuci√≥n distribuida cerca del usuario (Cloudflare Workers, Vercel Edge).

---

## Conclusi√≥n extendida

Esta ampliaci√≥n cubre las capas de **operaci√≥n, gobierno, observabilidad, seguridad avanzada, monetizaci√≥n, dise√±o y tendencias futuras**.
Con ello, el documento ofrece una visi√≥n integral del ciclo de vida completo de una API moderna: **dise√±o, implementaci√≥n, despliegue, mantenimiento y evoluci√≥n**, con los principales patrones y tecnolog√≠as de referencia hasta 2025.

# Dise√±o de Patrones y Protocolos API  
`$= dv.current().file.tags.join(" ")`  

- API  
- [Backend](/uncategorized/backend/)  
- [microservicios](/backend/microservicios/)  
- [web services](/backend/web-services/)  
- [OpenAPI](/backend/openapi/)  
- [GraphQL](/backend/graphql/)  
- Rest  
- SOAP  
- [gRPC](/backend/grpc/)  
- API Gateway  

---

## Introducci√≥n

El dise√±o de patrones y protocolos en una API define **c√≥mo se comunican los sistemas**, **c√≥mo se estructuran los recursos** y **qu√© convenciones garantizan interoperabilidad y mantenibilidad**.  
Un buen dise√±o implica coherencia, previsibilidad, seguridad y escalabilidad a largo plazo.  

Los patrones de dise√±o proporcionan soluciones comunes a problemas recurrentes en el desarrollo y operaci√≥n de APIs, mientras que los protocolos definen las reglas t√©cnicas de la comunicaci√≥n.

---

## 1. Patrones de dise√±o de API

### 1.1. Patrones estructurales

- **Resource Pattern**  
	- Cada entidad se representa como un recurso con un identificador √∫nico (URI).  
	- Ejemplo: `/users`, `/users/{id}`, `/orders/{orderId}`.  
	- Usado en REST y GraphQL (a nivel de tipo).

- **Collection Pattern**  
	- Agrupa recursos relacionados bajo una colecci√≥n.  
	- Permite operaciones CRUD sobre conjuntos.  
	- Ejemplo:  
		- `GET /users` ‚Üí lista  
		- `POST /users` ‚Üí crear  
		- `GET /users/{id}` ‚Üí detalle  

- **Subresource Pattern**  
	- Representa jerarqu√≠as o dependencias.  
	- Ejemplo: `/users/{id}/orders`.  
	- Evita exponer relaciones impl√≠citas mediante consultas complejas.

- **Envelope Pattern**  
	- Uniforma respuestas dentro de un contenedor predecible.  
	- Ejemplo:
		{% raw %}
```json
		{
			"status": "success",
			"data": {...},
			"errors": []
		}
		```
{% endraw %}

---

### 1.2. Patrones de comunicaci√≥n

- **Request-Response**  
	- Cl√°sico intercambio s√≠ncrono cliente-servidor.  
	- Base de REST, SOAP y gRPC unary.  

- **Publish/Subscribe**  
	- Desacopla emisores y receptores mediante eventos.  
	- Usado en APIs de tipo *event-driven* o Webhooks.  

- **Streaming**  
	- Env√≠o continuo de datos (gRPC streaming, WebSockets, SSE).  
	- Ideal para tiempo real, monitoreo o IoT.

- **CQRS (Command Query Responsibility Segregation)**  
	- Separar comandos (modifican estado) de consultas (solo lectura).  
	- Reduce acoplamiento y mejora escalabilidad.

---

### 1.3. Patrones de versionado

- **URI versioning**  
	- `/api/v1/...`  
- **Header versioning**  
	- `Accept: application/vnd.api+json; version=2`  
- **Query versioning**  
	- `?version=3`  
- **Backward compatibility**  
	- Evitar romper clientes; a√±adir campos nuevos sin eliminar antiguos.  

---

### 1.4. Patrones de agregaci√≥n y composici√≥n

- **API Composition**  
	- Combina respuestas de varios servicios en uno solo.  
	- Ejemplo: un endpoint `/dashboard` que une datos de `/users` y `/orders`.  

- **Backend for Frontend (BFF)**  
	- API adaptada a un tipo de cliente (web, m√≥vil, IoT).  
	- Mejora rendimiento y reduce l√≥gica en el frontend.  

- **GraphQL Pattern**  
	- Permite consultas personalizadas, combinando m√∫ltiples recursos en una sola llamada.  
	- Se basa en un esquema tipado que describe los datos disponibles.  

---

### 1.5. Patrones de resiliencia

- **Circuit Breaker**  
	- Previene cascadas de fallos cortando llamadas a servicios no disponibles.  
- **Retry Pattern**  
	- Reintenta peticiones fallidas con backoff exponencial.  
- **Timeout Pattern**  
	- Define tiempos m√°ximos de espera por respuesta.  
- **Fallback Pattern**  
	- Usa una respuesta por defecto cuando un servicio falla.  

---

### 1.6. Patrones de seguridad

- **Token-based Auth**  
	- Uso de JWT u OAuth 2.0 para autenticaci√≥n sin estado.  
- **Rate Limiting Pattern**  
	- L√≠mite de peticiones por cliente o IP.  
- **mTLS (Mutual TLS)**  
	- Autenticaci√≥n mutua entre servicios internos.  
- **Input Validation Pattern**  
	- Validaci√≥n estricta en cada punto de entrada (schemas).  

---

## 2. Protocolos de API

### 2.1. REST
- Protocolo basado en HTTP, ligero y ampliamente adoptado.  
- Usa m√©todos est√°ndar (`GET`, `POST`, `PUT`, `DELETE`, `PATCH`).  
- Datos generalmente en formato JSON.  
- Ventajas: simplicidad, cacheo, soporte universal.  
- Desventajas: acoplamiento d√©bil entre cliente y servidor, sobre/infra-fetching.

---

### 2.2. SOAP
- Basado en XML, formal y con contratos definidos mediante WSDL.  
- Orientado a entornos corporativos o regulados.  
- Permite transporte sobre HTTP, SMTP u otros protocolos.  
- Soporta transacciones complejas y seguridad WS-*.

---

### 2.3. [GraphQL](/backend/graphql/)
- Permite al cliente definir la estructura exacta de la respuesta.  
- Un solo endpoint (`/graphql`) maneja m√∫ltiples consultas y mutaciones.  
- Ventajas: evita overfetching/underfetching.  
- Desventajas: caching complejo y consultas costosas si no se limitan.  

---

### 2.4. [gRPC](/backend/grpc/)
- Framework RPC basado en HTTP/2 y Protocol Buffers.  
- Comunicaci√≥n binaria, compacta y de alto rendimiento.  
- Ideal para comunicaci√≥n entre microservicios internos.  
- Soporta streaming bidireccional.  

Ejemplo b√°sico de definici√≥n `.proto`:

{% raw %}
```proto
syntax = "proto3";

service UserService {
	rpc GetUser (UserRequest) returns (UserResponse);
}

message UserRequest {
	int32 id = 1;
}

message UserResponse {
	string name = 1;
	string email = 2;
}
```
{% endraw %}`

---

### 2.5. WebSockets

* Protocolo full-duplex sobre TCP para comunicaci√≥n en tiempo real.
* Mantiene una conexi√≥n abierta entre cliente y servidor.
* Ideal para chats, notificaciones y colaboraci√≥n simult√°nea.

---

### 2.6. Server-Sent Events (SSE)

* Permite al servidor enviar flujos unidireccionales continuos al cliente.
* √ötil para actualizaciones en vivo o dashboards.

---

### 2.7. MQTT y AMQP

* Protocolos ligeros para IoT y mensajer√≠a asincr√≥nica.
* MQTT se basa en el modelo publish/subscribe.
* AMQP proporciona colas, enrutamiento y confirmaci√≥n de entrega.

---

## 3. Patrones de interoperabilidad

* **HATEOAS (Hypermedia as the Engine of Application State)**

  * Incluye enlaces en las respuestas que describen las posibles acciones siguientes.
  * Ejemplo:

    {% raw %}
```json
    {
    	"id": 1,
    	"name": "Eduardo",
    	"links": [
    		{"rel": "self", "href": "/users/1"},
    		{"rel": "orders", "href": "/users/1/orders"}
    	]
    }
    ```
{% endraw %}
* **Content Negotiation**

  * Cliente y servidor acuerdan el formato (JSON, XML, YAML) mediante encabezados `Accept` y `Content-Type`.
* **Idempotencia**

  * Repetir una misma operaci√≥n produce siempre el mismo resultado (importante para `PUT` y `DELETE`).
* **Statelessness**

  * Cada solicitud contiene todo el contexto necesario, sin depender del estado del servidor.

---

## 4. Patrones de evoluci√≥n y gobernanza

* **Deprecation Strategy**

  * Notificar y documentar endpoints obsoletos.
  * Mantener periodo de compatibilidad.
* **Schema Registry**

  * Control central de los contratos y versiones de API.
* **API Linter / Validator**

  * Analiza convenciones, consistencia y cumplimiento de est√°ndares (por ejemplo, Spectral, OpenAPI Lint).
* **Observabilidad**

  * Implementar trazas, logs estructurados y m√©tricas por endpoint.

---

## 5. Comparativa de protocolos

| Protocolo  | Transporte | Formato       | Orientaci√≥n | Rendimiento | Complejidad | Ideal para                  |
| ---------- | ---------- | ------------- | ----------- | ----------- | ----------- | --------------------------- |
| REST       | HTTP/1.1   | JSON          | Recursos    | Medio       | Baja        | APIs p√∫blicas               |
| SOAP       | HTTP/SMTP  | XML           | Servicios   | Medio       | Alta        | Entornos corporativos       |
| GraphQL    | HTTP       | JSON          | Consultas   | Medio       | Media       | Frontends din√°micos         |
| gRPC       | HTTP/2     | Binario       | RPC         | Alta        | Media       | Microservicios internos     |
| WebSockets | TCP        | Texto/Binario | Eventos     | Alta        | Media       | Tiempo real                 |
| MQTT       | TCP        | Binario       | Pub/Sub     | Muy alta    | Baja        | IoT                         |
| AMQP       | TCP        | Binario       | Mensajer√≠a  | Alta        | Alta        | Integraciones empresariales |

---

## Conclusi√≥n

El dise√±o de una API moderna requiere seleccionar **el protocolo adecuado** seg√∫n el caso de uso, junto con **patrones de dise√±o** que garanticen robustez, mantenibilidad y compatibilidad futura.
REST y GraphQL dominan el panorama web, mientras que gRPC, WebSockets y MQTT ampl√≠an las posibilidades hacia entornos distribuidos, tiempo real y sistemas embebidos.
Adoptar patrones de versionado, resiliencia y seguridad permite construir APIs **predecibles, estables y escalables** en cualquier ecosistema.




# omnivore api
{% raw %}
```base
type: list
name: "Notas con #api en Omnivore"
order:
  - property: date_saved
    direction: desc
columns:
  - file.name
  - date_saved
filters:
  and:
    - file.inFolder("Omnivore")
    - file.hasTag("api", "API")
views:
  - type: table
    name: Table
    sort:
      - property: file.mtime
        direction: DESC

```
{% endraw %}

