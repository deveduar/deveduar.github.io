---
date: 2025-10-12 13:10
title: Sockets
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: Backend
tags:
  - sockets
  - real-time
  - socket-io
---
# Sockets
``

- [Backend](/backend/backend/)
- [Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)

## Conceptos
- Comunicaci√≥n en tiempo real bidireccional entre cliente y servidor.
- Permite actualizaciones instant√°neas sin recargar la p√°gina.
- Se utiliza para chat en tiempo real, notificaciones, juegos en l√≠nea, colaboraci√≥n en documentos, etc.
- Diferencias entre HTTP y WebSockets:
	 - HTTP: comunicaci√≥n unidireccional, cada petici√≥n requiere respuesta del servidor.
	 - WebSocket: conexi√≥n persistente, comunicaci√≥n continua y eficiente.

## Proyectos
- app de chat ia con agente de gemini
	 - Ejemplo pr√°ctico de implementaci√≥n de chat con respuesta autom√°tica usando IA.
	 - Integraci√≥n de WebSockets para recibir mensajes en tiempo real.
	 - Manejo de eventos: conexi√≥n, desconexi√≥n, mensajes entrantes y salientes.

## Socket.IO
- [Socket.io](https://socket.io/)
- Documentaci√≥n oficial: https://socket.io/docs/v4/
- Librer√≠a para Node.js que facilita la implementaci√≥n de WebSockets.
- Caracter√≠sticas:
	 - Reconexi√≥n autom√°tica.
	 - Emisi√≥n y recepci√≥n de eventos personalizados.
	 - Soporte de rooms y namespaces para segmentar comunicaciones.
	 - Compatible con fallbacks si WebSocket no est√° disponible (polling).

### Ejemplo b√°sico de Socket.IO (Servidor)
{% raw %}
```javascript
const io = require("socket.io")(3000);

io.on("connection", (socket) => {
	console.log("Nuevo cliente conectado:", socket.id);
	socket.on("mensaje", (data) => {
		console.log("Mensaje recibido:", data);
		io.emit("mensaje", data);
	});

	socket.on("disconnect", () => {
		console.log("Cliente desconectado:", socket.id);
	});
});
```
{% endraw %}`

### Ejemplo b√°sico de Socket.IO (Cliente)

{% raw %}
```javascript
<script src="/socket.io/socket.io.js"></script>
<script>
	const socket = io("http://localhost:3000");

	socket.on("connect", () => {
		console.log("Conectado al servidor:", socket.id);
	});

	socket.on("mensaje", (data) => {
		console.log("Mensaje del servidor:", data);
	});

	function enviarMensaje(texto) {
		socket.emit("mensaje", texto);
	}
</script>
```
{% endraw %}

## WebSockets - Cursos y Recursos

- [Socket.io | Curso Pr√°ctico de WebSockets, con Socket.io y Nodejs | Chat con Socket.io](https://www.youtube.com/watch?v=0wqteZNqruc)
- [¬øC√≥mo se comunican los programas escritos en lenguajes distintos?](https://www.youtube.com/watch?v=7f9NzvvPo9g)
- Conceptos adicionales:  
     - Protocolos subyacentes: WS (WebSocket), WSS (WebSocket seguro).  
     - Handshake inicial HTTP para actualizar a WebSocket.  
     - Mecanismos de ping/pong para mantener la conexi√≥n viva.
# Sockets ‚Äì Conceptos Avanzados y Temas Complementarios

## Arquitectura de Comunicaci√≥n
- Modelo cliente-servidor con conexi√≥n persistente.
- Comunicaci√≥n full-duplex: env√≠o y recepci√≥n simult√°nea de datos.
- Escalabilidad horizontal mediante balanceadores de carga.
- Uso de adaptadores (ej. Redis Adapter en Socket.IO) para sincronizar eventos entre m√∫ltiples instancias.

## WebSocket Protocol
- [Protocolos](/redes/protocolos/)
- Basado en RFC 6455.
- Funciona sobre TCP.
- Upgrade desde HTTP/1.1 durante el handshake inicial.
- Menor overhead comparado con polling o long-polling.
- Frames binarios y de texto para transmisi√≥n eficiente.

## Seguridad
- Uso de WSS (WebSocket Secure) con TLS.
- Autenticaci√≥n basada en:
	- Tokens [JWT](/autenticacion/jwt/) enviados en el handshake.
	- Cookies de sesi√≥n.
- Control de autorizaci√≥n por rooms y namespaces.
- Prevenci√≥n de ataques:
	- Rate limiting.
	- Validaci√≥n de payloads.
	- Protecci√≥n contra conexiones no autorizadas.

## Gesti√≥n de Conexiones
- Manejo del ciclo de vida:
	- Conexi√≥n.
	- Reintentos y reconexi√≥n.
	- Desconexi√≥n controlada.
- Heartbeats (ping/pong) para detectar conexiones ca√≠das.
- Gesti√≥n de usuarios activos y estados online/offline.

## Escalabilidad y Rendimiento
- Uso de Redis, Kafka o RabbitMQ como message brokers.
- Separaci√≥n de servicios:
	- Gateway de WebSockets.
	- Servicios de negocio independientes.
- Optimizaci√≥n:
	- Emisi√≥n selectiva de eventos.
	- Compresi√≥n de mensajes.
	- Uso de binarios cuando sea necesario.

## Patrones de Dise√±o
- [Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)
- Pub/Sub (Publicador‚ÄìSuscriptor).
- Event-Driven Architecture.
- CQRS aplicado a eventos en tiempo real.
- Observer pattern aplicado a listeners de eventos.

## Casos de Uso Avanzados
- Dashboards en tiempo real (monitorizaci√≥n, m√©tricas).
- Sistemas de trading y mercados financieros.
- Juegos multijugador online.
- Edici√≥n colaborativa (tipo Google Docs).
- Streaming de eventos IoT.

## Alternativas y Comparativas
- SSE (Server-Sent Events):
	- Comunicaci√≥n unidireccional.
	- Menor complejidad.
- [gRPC](/backend/grpc/) Streaming:
	- Alto rendimiento.
	- Uso frecuente en microservicios.
- MQTT:
	- Orientado a IoT.
	- Ligero y eficiente.

## Testing y Debugging
- Simulaci√≥n de m√∫ltiples clientes.
- Uso de logs estructurados para eventos.
- Herramientas:
	- Postman (WebSocket support).
	- WebSocket King Client.
- Tests de carga para conexiones concurrentes.

## Observabilidad
- M√©tricas:
	- Conexiones activas.
	- Eventos por segundo.
	- Latencia.
- Integraci√≥n con Prometheus y Grafana.
- Trazabilidad de eventos distribuidos.

## Buenas Pr√°cticas
- Definir contratos de eventos claros.
- Versionado de eventos.
- Manejo de errores expl√≠cito.
- Desacoplar l√≥gica de transporte y l√≥gica de negocio.
- Documentar eventos y flujos en tiempo real.
