---
date: 2025-05-19 20:30
title: CORS
tags:
  - CORS
  - backend
  - devops
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Backend
public_note: "true"
category: Backend
---
# CORS
`$= dv.current().file.tags.join(" ")`

- [Backend](/uncategorized/backend/)
- [ciberseguridad](/uncategorized/ciberseguridad/)

## Concepto General
 
CORS (*Cross-Origin Resource Sharing*) es un mecanismo de seguridad que controla c√≥mo los recursos de un sitio web pueden ser solicitados desde otro dominio distinto al de origen. Se implementa mediante cabeceras HTTP que indican qu√© dominios, m√©todos y cabeceras est√°n permitidos al realizar peticiones entre or√≠genes.

Su objetivo principal es evitar accesos no autorizados o fugas de datos al consumir APIs desde navegadores, manteniendo la integridad del [Backend](/uncategorized/backend/) y la protecci√≥n de los usuarios en el contexto de [ciberseguridad](/uncategorized/ciberseguridad/).

## Or√≠genes
El *origen* se define como la combinaci√≥n de **protocolo**, **dominio** y **puerto**.  
Dos URLs pertenecen al mismo origen solo si los tres componentes coinciden exactamente.

Ejemplo:
- `https://api.misitio.com:443` y `https://api.misitio.com` ‚Üí mismo origen  
- `https://app.misitio.com` y `https://api.misitio.com` ‚Üí distinto origen  
- `http://localhost:3000` y `https://localhost:3000` ‚Üí distinto origen  

Cuando una aplicaci√≥n cliente intenta acceder a recursos desde un origen diferente, el navegador eval√∫a las cabeceras CORS del servidor antes de permitir o bloquear la solicitud.

## Cabeceras HTTP

Las cabeceras CORS determinan las reglas de acceso:

- `Access-Control-Allow-Origin`: especifica qu√© origen puede acceder (`*` para todos, o una URL espec√≠fica).
- `Access-Control-Allow-Methods`: lista de m√©todos HTTP permitidos (`GET`, `POST`, `PUT`, `DELETE`, etc.).
- `Access-Control-Allow-Headers`: define las cabeceras personalizadas aceptadas por el servidor.
- `Access-Control-Allow-Credentials`: indica si las cookies o credenciales est√°n permitidas.
- `Access-Control-Max-Age`: tiempo en segundos que el navegador puede almacenar la pol√≠tica CORS en cach√©.

### Ejemplo de Respuesta del Servidor

{% raw %}
```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://frontend.com
Access-Control-Allow-Methods: GET, POST
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
```
{% endraw %}`

## Librer√≠a `cors` en [Backend](/uncategorized/backend/)

En entornos como Node.js o Express.js, la librer√≠a `cors` simplifica la configuraci√≥n mediante middleware.

### Instalaci√≥n

{% raw %}
```bash
npm install cors
```
{% endraw %}

### Uso B√°sico

{% raw %}
```javascript
const express = require('express');
const cors = require('cors');

const app = express();
app.use(cors());
```
{% endraw %}

Este ejemplo permite el acceso desde cualquier origen (`*`), lo cual puede ser √∫til para desarrollo pero no se recomienda en producci√≥n.

### Configuraci√≥n Personalizada

{% raw %}
```javascript
const corsOptions = {
	origin: 'https://frontend.com',
	methods: ['GET', 'POST'],
	allowedHeaders: ['Content-Type', 'Authorization'],
	credentials: true
};

app.use(cors(corsOptions));
```
{% endraw %}

## Whitelist de Or√≠genes

Para mayor seguridad, puede definirse una lista blanca (*whitelist*) de dominios permitidos.

{% raw %}
```javascript
const whitelist = ['https://frontend.com', 'https://admin.frontend.com'];

const corsOptions = {
	origin: (origin, callback) => {
		if (!origin || whitelist.includes(origin)) {
			callback(null, true);
		} else {
			callback(new Error('No autorizado por CORS'));
		}
	}
};

app.use(cors(corsOptions));
```
{% endraw %}

Esta configuraci√≥n eval√∫a el origen de cada solicitud y solo permite los que est√©n en la lista.

## Casos Pr√°cticos

* **Entorno local**: permitir `http://localhost` y `http://127.0.0.1` para desarrollo.
* **APIs p√∫blicas**: configurar `Access-Control-Allow-Origin: *` solo si no se manejan credenciales.
* **Producci√≥n**: utilizar whitelist y credenciales solo cuando sea necesario.

## Buenas Pr√°cticas de Seguridad

* No usar `*` en `Access-Control-Allow-Origin` si se manejan cookies o tokens.
* Validar los or√≠genes en el servidor, no confiar en el cliente.
* Registrar los intentos fallidos de acceso para auditor√≠a.
* Comprobar configuraciones CORS en entornos de staging antes del despliegue.

## Errores Comunes

* **Bloqueo de navegador**: ocurre cuando el servidor no devuelve las cabeceras adecuadas.
* **Preflight request fallida**: error en la respuesta al m√©todo `OPTIONS`.
* **Cabeceras ausentes**: olvidar incluir `Access-Control-Allow-Headers` cuando se usan cabeceras personalizadas.

## Diagn√≥stico y Depuraci√≥n

* Usar herramientas de red del navegador (pesta√±a *Network*) para ver las cabeceras.
* Revisar el log del servidor para detectar rechazos de origen.
* Probar con `curl` o `Postman` para verificar manualmente las respuestas.

### Ejemplo de prueba con `curl`

{% raw %}
```bash
curl -I -X OPTIONS https://api.misitio.com -H "Origin: https://frontend.com"
```
{% endraw %}

Esto permite inspeccionar las cabeceras de respuesta CORS sin depender del navegador.


# CORS Avanzado y Casos de Implementaci√≥n

## Profundizaci√≥n T√©cnica

CORS no solo gestiona peticiones simples; tambi√©n regula las llamadas **preflight**, las cuales se ejecutan autom√°ticamente antes de una solicitud principal cuando se cumplen ciertas condiciones (por ejemplo, m√©todos distintos de `GET` o `POST`, o cabeceras personalizadas).

### Solicitudes Preflight

El navegador env√≠a una solicitud `OPTIONS` al servidor para verificar si el origen, m√©todo y cabeceras est√°n permitidos.

#### Ejemplo de Flujo Preflight

1. **Cliente env√≠a:**
   {% raw %}
```http
   OPTIONS /api/recurso HTTP/1.1
   Origin: https://frontend.com
   Access-Control-Request-Method: POST
   Access-Control-Request-Headers: Content-Type
```
{% endraw %}`

2. **Servidor responde:**

{% raw %}
```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://frontend.com
Access-Control-Allow-Methods: POST
Access-Control-Allow-Headers: Content-Type
Access-Control-Max-Age: 3600
```
{% endraw %}

Si la respuesta cumple las condiciones CORS, el navegador procede con la solicitud real (`POST`).

## Integraci√≥n con APIs REST y [GraphQL](/backend/graphql/)

En arquitecturas modernas, especialmente con microservicios o APIs distribuidas, la correcta configuraci√≥n CORS es esencial para el consumo desde clientes SPA o m√≥viles.

### Ejemplo REST

* Backend en `https://api.misitio.com`
* Frontend en `https://app.misitio.com`

El backend debe responder con:

{% raw %}
```http
Access-Control-Allow-Origin: https://app.misitio.com
```
{% endraw %}

### Ejemplo GraphQL

{% raw %}
```javascript
app.use(
	'/graphql',
	cors({ origin: 'https://frontend.com', credentials: true }),
	express.json(),
	expressMiddleware(schema)
);
```
{% endraw %}

Esto permite peticiones autenticadas de un dominio controlado sin exponer credenciales a otros or√≠genes.

## CORS en [Frontend](/uncategorized/frontend/)

Aunque el control principal recae en el servidor, el cliente puede adaptarse a los requisitos del servidor:

* Definir el `mode` en `fetch`:

  {% raw %}
```javascript
  fetch('https://api.misitio.com/datos', { mode: 'cors' });
  ```
{% endraw %}
* Incluir credenciales si el servidor lo permite:

  {% raw %}
```javascript
  fetch('https://api.misitio.com/secure', {
  	mode: 'cors',
  	credentials: 'include'
  });
  ```
{% endraw %}

Estas configuraciones dependen del `Access-Control-Allow-Credentials` y el dominio autorizado.

## CORS y Autenticaci√≥n

Cuando se usan tokens [JWT](/autenticacion/jwt/) o sesiones, la configuraci√≥n CORS se vuelve cr√≠tica:

* **JWT**: los tokens se env√≠an en la cabecera `Authorization`. El servidor debe incluir esta cabecera en `Access-Control-Allow-Headers`.
* **Cookies de sesi√≥n**: requieren `credentials: true` y un origen expl√≠cito (no `*`).

Ejemplo de backend seguro:

{% raw %}
```javascript
app.use(
	cors({
		origin: 'https://frontend.com',
		credentials: true,
		allowedHeaders: ['Authorization', 'Content-Type']
	})
);
```
{% endraw %}

## CORS en Nginx y Apache

CORS tambi√©n puede configurarse a nivel de proxy o servidor web.

### Nginx

{% raw %}
```nginx
location /api/ {
	add_header 'Access-Control-Allow-Origin' 'https://frontend.com';
	add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
	add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type';
	if ($request_method = OPTIONS) {
		return 204;
	}
}
```
{% endraw %}

### Apache

{% raw %}
```apache
<Directory "/var/www/api">
	Header set Access-Control-Allow-Origin "https://frontend.com"
	Header set Access-Control-Allow-Methods "GET,POST,OPTIONS"
	Header set Access-Control-Allow-Headers "Authorization,Content-Type"
</Directory>
```
{% endraw %}

## CORS y Reverse Proxy

En arquitecturas donde un *reverse proxy* (como Nginx o Traefik) se encarga de enrutar peticiones, CORS puede manejarse directamente en el proxy, aliviando la carga del [Backend](/uncategorized/backend/). Esto facilita aplicar pol√≠ticas centralizadas para m√∫ltiples microservicios.

## Testing y Validaci√≥n

Herramientas √∫tiles:

* **Postman** y **Insomnia** para probar cabeceras manualmente.
* **curl** para solicitudes controladas.
* Extensiones de navegador como *Allow CORS: Access-Control-Allow-Origin* (solo para pruebas, nunca en producci√≥n).

Automatizaci√≥n en testing:

{% raw %}
```javascript
import request from 'supertest';
import app from '../app';

test('Permite solicitudes desde origen v√°lido', async () => {
	const res = await request(app)
		.get('/api/data')
		.set('Origin', 'https://frontend.com');
	expect(res.headers['access-control-allow-origin']).toBe('https://frontend.com');
});
```
{% endraw %}

## Estrategias Avanzadas

* **Dynamic Origin Handling**: permitir or√≠genes basados en configuraci√≥n o entorno.
* **Rate Limiting por Origen**: limitar tr√°fico seg√∫n el dominio para mitigar abusos.
* **Registro de Solicitudes CORS**: almacenar intentos de acceso no autorizados para an√°lisis de seguridad.

## Conclusi√≥n T√©cnica

CORS es una capa cr√≠tica en la arquitectura web moderna que conecta seguridad, accesibilidad y dise√±o de APIs. Su mala configuraci√≥n puede exponer vulnerabilidades o impedir la comunicaci√≥n leg√≠tima entre servicios. La clave est√° en aplicar pol√≠ticas precisas, no gen√©ricas, integradas dentro de un contexto seguro de [Backend](/uncategorized/backend/), [ciberseguridad](/uncategorized/ciberseguridad/) y despliegue.

# CORS: Casos Avanzados, Configuraciones Complejas y Escenarios Especiales

## CORS en Microservicios y Arquitecturas Distribuidas

En entornos basados en [microservicios](/backend/microservicios/), el control de CORS puede descentralizarse o centralizarse seg√∫n la topolog√≠a:

- **Centralizado (en gateway o API Gateway)**: el control CORS se gestiona en un punto de entrada com√∫n, simplificando la configuraci√≥n.
- **Descentralizado (en cada microservicio)**: cada servicio define su propia pol√≠tica, √∫til si hay diferentes dominios o niveles de acceso.

Ejemplo con Express.js y API Gateway:
{% raw %}
```javascript
gateway.use('/api/users', cors({ origin: 'https://app.frontend.com' }), usersService);
gateway.use('/api/payments', cors({ origin: 'https://admin.frontend.com' }), paymentsService);
```
{% endraw %}`

## CORS en WebSockets

Aunque CORS no se aplica directamente a WebSockets (`ws://` o `wss://`), el concepto de **origen confiable** sigue siendo relevante.
Los navegadores solo permiten conexiones WebSocket al mismo origen o a dominios que implementen medidas equivalentes de validaci√≥n en el handshake.

Configuraci√≥n t√≠pica:

{% raw %}
```javascript
const wsServer = new WebSocketServer({
	verifyClient: (info, done) => {
		const origin = info.origin;
		const allowed = ['https://frontend.com', 'https://admin.frontend.com'];
		if (allowed.includes(origin)) done(true);
		else done(false, 403, 'Origin not allowed');
	}
});
```
{% endraw %}

## CORS en Aplicaciones M√≥viles y [pwa](/frontend/pwa/)

Las aplicaciones m√≥viles h√≠bridas (por ejemplo, con [capacitor](/desarrollo%20multiplataforma/capacitor/) o Cordova) no siempre ejecutan restricciones CORS, ya que operan fuera del contexto del navegador.
Sin embargo, en [pwa](/frontend/pwa/) o entornos que usan Service Workers, las pol√≠ticas CORS siguen aplic√°ndose para proteger las respuestas cacheadas o interceptadas.

Ejemplo de manejo con `fetch` y `Service Worker`:

{% raw %}
```javascript
self.addEventListener('fetch', event => {
	event.respondWith(
		fetch(event.request, { mode: 'cors' })
			.then(response => response)
			.catch(() => caches.match(event.request))
	);
});
```
{% endraw %}

## CORS y CDN

Cuando los recursos (im√°genes, fuentes, scripts) se sirven desde un CDN, es esencial que las cabeceras CORS est√©n configuradas correctamente para permitir su uso desde otros dominios.

Ejemplo en AWS S3:

{% raw %}
```xml
<CORSConfiguration>
	<CORSRule>
		<AllowedOrigin>https://app.frontend.com</AllowedOrigin>
		<AllowedMethod>GET</AllowedMethod>
		<AllowedHeader>*</AllowedHeader>
		<ExposeHeader>Content-Length</ExposeHeader>
	</CORSRule>
</CORSConfiguration>
```
{% endraw %}

Esto habilita el uso de recursos est√°ticos en un frontend alojado en otro dominio.

## CORS y HTTP/2 o HTTP/3

Con protocolos modernos, las cabeceras CORS siguen funcionando igual, pero su interpretaci√≥n puede verse afectada por:

* Multiplexaci√≥n de peticiones.
* Cabeceras pseudo (`:method`, `:path`, etc.).
* Compresi√≥n y priorizaci√≥n de streams.

En estos contextos, el control CORS sigue siendo una capa l√≥gica sobre HTTP, no una limitaci√≥n t√©cnica del protocolo.

## CORS en Cloudflare, AWS API Gateway y Azure API Management

### Cloudflare

Permite definir reglas de cabeceras personalizadas en su panel o mediante *Transform Rules*:

{% raw %}
```bash
Access-Control-Allow-Origin: https://frontend.com
Access-Control-Allow-Methods: GET, POST, OPTIONS
```
{% endraw %}

### AWS API Gateway

En APIs gestionadas, las pol√≠ticas CORS se definen por recurso:

{% raw %}
```json
{
	"Access-Control-Allow-Origin": "'https://frontend.com'",
	"Access-Control-Allow-Methods": "'GET,POST,OPTIONS'"
}
```
{% endraw %}

### Azure API Management

Usa *Inbound Policies* XML:

{% raw %}
```xml
<inbound>
	<base />
	<cors>
		<allowed-origins>
			<origin>https://frontend.com</origin>
		</allowed-origins>
		<allowed-methods>
			<method>GET</method>
			<method>POST</method>
		</allowed-methods>
	</cors>
</inbound>
```
{% endraw %}

## CORS y SSE (Server-Sent Events)

Al usar *event streams*, el navegador sigue respetando CORS.
El servidor debe enviar cabeceras adecuadas antes de abrir el stream.

Ejemplo:

{% raw %}
```javascript
res.writeHead(200, {
	'Content-Type': 'text/event-stream',
	'Access-Control-Allow-Origin': 'https://frontend.com',
	'Cache-Control': 'no-cache',
	Connection: 'keep-alive'
});
```
{% endraw %}

## CORS en [Testing](/testing/testing/) y Automatizaci√≥n QA

Las pruebas autom√°ticas deben incluir escenarios CORS para evitar bloqueos en producci√≥n:

* Simular or√≠genes distintos con herramientas como `supertest` o `playwright`.
* Incluir pruebas de *preflight* y validaci√≥n de credenciales.
* Asegurar que los endpoints de error tambi√©n devuelvan cabeceras CORS v√°lidas.

Ejemplo con [Playwright](/testing/playwright/):

{% raw %}
```javascript
test('bloquea origen no autorizado', async ({ request }) => {
	const res = await request.get('https://api.misitio.com/data', {
		headers: { Origin: 'https://malicious.com' }
	});
	expect(res.status()).toBe(403);
});
```
{% endraw %}

## CORS y OAuth2 / OpenID Connect

Durante los flujos de autenticaci√≥n (especialmente *Authorization Code Flow*), los redireccionamientos entre dominios requieren configuraciones CORS y de *redirect URI* sincronizadas.
Si no se gestionan correctamente, el navegador bloquear√° las respuestas o tokens.

Recomendaciones:

* Mantener los `redirect_uri` registrados en el proveedor de identidad.
* Usar dominios consistentes en frontend y backend (por ejemplo, subdominios compartidos).
* No exponer tokens en respuestas sin CORS adecuado.

## CORS en Serverless Functions

En plataformas como [Vercel](/cloud/vercel/), Netlify Functions o AWS Lambda, CORS debe configurarse manualmente en cada funci√≥n o mediante middleware global.

Ejemplo en Vercel:

{% raw %}
```javascript
export default function handler(req, res) {
	res.setHeader('Access-Control-Allow-Origin', 'https://frontend.com');
	res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
	if (req.method === 'OPTIONS') return res.status(204).end();
	res.status(200).json({ message: 'OK' });
}
```
{% endraw %}

## Monitoreo y Auditor√≠a

Para garantizar seguridad continua:

* Analizar logs de acceso rechazado.
* Implementar m√©tricas sobre or√≠genes m√°s frecuentes.
* Integrar alertas cuando se detecten solicitudes repetidas de or√≠genes desconocidos.

Integraci√≥n con herramientas de observabilidad como Grafana o Elastic Stack para visualizar tr√°fico bloqueado por CORS.

## Enfoque de Dise√±o Seguro

* Definir pol√≠ticas CORS desde el dise√±o inicial del sistema.
* Mantener consistencia entre entornos (dev, staging, prod).
* Integrar CORS en revisiones de seguridad y pentesting.
* Documentar claramente las pol√≠ticas de acceso en la API.

---

**En resumen**, hemos cubierto el espectro completo de CORS:

* Fundamentos t√©cnicos y cabeceras.
* Implementaci√≥n en [Backend](/uncategorized/backend/), proxies y nubes.
* Integraciones con protocolos y arquitecturas modernas.
* Estrategias de seguridad, auditor√≠a y pruebas automatizadas.

Con esta extensi√≥n, el tema CORS queda completamente desarrollado en todos sus niveles pr√°cticos, conceptuales y de aplicaci√≥n real.



