---
date: 2024-11-23 20:32
title: Firebase
keywords:
source:
status: ðŸŒŸ
Parent: "[[Area-Prog]]"
public_note: "true"
category: Backend
tags:
  - firebase
  - backend
  - api
  - BaaS
  - db
---
# Firebase

- [Backend](/backend/backend/)
- [Databases](/databases/databases/)
- [nextjs](/frontend/nextjs/)
- [cloud](/cloud/cloud/)
- BaaS
- MVP
- Firestore
- Firebase vs MongoDB
	- **Firebase**
		- Base de datos NoSQL en tiempo real.
		- Backend as a Service completo (BaaS).
		- IntegraciÃ³n sencilla con apps web y mÃ³viles.
		- Servicios incluidos: Auth, Firestore, Realtime Database, Hosting, Functions, Storage, Messaging.
	- **MongoDB**
		- Base de datos NoSQL tradicional.
		- Requiere backend propio (Node.js, Express, etc.).
		- Mayor control sobre la estructura y consultas de los datos.
- Conceptos clave
	- **NoSQL**
		- Almacena datos en formato JSON/documentos.
		- Flexible y escalable horizontalmente.
		- Ideal para aplicaciones con esquemas dinÃ¡micos o en evoluciÃ³n.
	- **Base de datos**
		- **Firestore**
			- Base de datos en tiempo real y en la nube.
			- SincronizaciÃ³n automÃ¡tica entre cliente y servidor.
			- Consultas estructuradas y soporte para transacciones.
		- **Realtime Database**
			- OpciÃ³n mÃ¡s antigua de Firebase.
			- Menor flexibilidad comparado con Firestore.
	- **AutenticaciÃ³n**
		- Firebase Auth permite:
			- Email/password.
			- Proveedores externos: Google, Facebook, GitHub, Apple.
		- Seguridad y reglas basadas en roles y usuarios.
		- IntegraciÃ³n con aplicaciones web y mÃ³viles.
	- **Hosting Serverless**
		- Firebase Hosting: despliegue rÃ¡pido de sitios estÃ¡ticos, SPAs y PWAs.
		- CDN global con SSL automÃ¡tico.
		- Compatible con dominios personalizados.
	- **Headless Backend**
		- Firebase puede funcionar como backend desacoplado.
		- Ideal para arquitecturas JAMstack, microfrontends o apps hÃ­bridas.
	- **BaaS (Backend as a Service)**
		- Servicios integrados:
			- Base de datos (Firestore / Realtime DB)
			- AutenticaciÃ³n
			- Hosting
			- Funciones serverless
			- Almacenamiento de archivos
			- Notificaciones push (Firebase Cloud Messaging)
	- **MVP y prototipos**
		- Permite crear prototipos rÃ¡pidamente sin infraestructura compleja.
		- Reducido tiempo de desarrollo y mantenimiento inicial.
	- **IntegraciÃ³n con Next.js**
		- [Next Firebase Template](https://github.com/milliorn/nextjs-13-firebase-starter)
			- Proyecto preconfigurado con Next.js 13 y Firebase.
			- Incluye ejemplos de autenticaciÃ³n, Firestore y despliegue.
	- **DocumentaciÃ³n oficial**
		- [DocumentaciÃ³n de Firebase](https://firebase.google.com/docs/samples?hl=es-419)
		- Ejemplos prÃ¡cticos para integraciÃ³n con web y mobile.

## CÃ³digo de ejemplo: Firestore
{% raw %}
```javascript
import { initializeApp } from "firebase/app";
import { getFirestore, collection, getDocs } from "firebase/firestore";

const firebaseConfig = {
	apiKey: "TU_API_KEY",
	authDomain: "TU_DOMINIO.firebaseapp.com",
	projectId: "TU_PROJECT_ID",
	storageBucket: "TU_BUCKET.appspot.com",
	messagingSenderId: "TU_MESSAGING_ID",
	appId: "TU_APP_ID"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

async function getData() {
	const querySnapshot = await getDocs(collection(db, "usuarios"));
	querySnapshot.forEach((doc) => {
		console.log(doc.id, " => ", doc.data());
	});
}

getData();
```
{% endraw %}`

## CÃ³digo de ejemplo: Firebase Auth

{% raw %}
```javascript
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword } from "firebase/auth";

const auth = getAuth();

async function register(email, password) {
	try {
		const userCredential = await createUserWithEmailAndPassword(auth, email, password);
		console.log("Usuario registrado:", userCredential.user);
	} catch (error) {
		console.error("Error en registro:", error);
	}
}

async function login(email, password) {
	try {
		const userCredential = await signInWithEmailAndPassword(auth, email, password);
		console.log("Usuario logueado:", userCredential.user);
	} catch (error) {
		console.error("Error en login:", error);
	}
}
```
{% endraw %}

## CÃ³digo de ejemplo: Hosting y Deploy

{% raw %}
```bash
# Inicializar proyecto Firebase
firebase init

# Seleccionar Hosting y configurar proyecto

# Desplegar el frontend
firebase deploy
```
{% endraw %}

# Firebase â€“ AmpliaciÃ³n de servicios y conceptos  

## Servicios adicionales destacados  
- **Bases de datos avanzadas**  
	- Realtime Database: base de datos NoSQL en tiempo real, ideal para sincronizaciÃ³n rÃ¡pida entre clientes.  
	- Cloud Firestore: base de datos NoSQL moderna, orientada a documentos/colecciones, con soporte para consultas estructuradas, escalabilidad global. :contentReference[oaicite:3]{index=3}  
- **Almacenamiento de archivos**  
	- Cloud Storage for Firebase: permite almacenar archivos generados por usuarios (imÃ¡genes, vÃ­deos, documentos) con reglas de seguridad y escalabilidad. :contentReference[oaicite:5]{index=5}  
- **Funciones serverless / backend sin servidor**  
	- Cloud Functions for Firebase: escribir lÃ³gica de backend que se ejecuta en respuesta a eventos (base de datos, autenticaciÃ³n, HTTP, etc.) sin gestionar servidores. :contentReference[oaicite:7]{index=7}  
- **MensajerÃ­a & notificaciones**  
	- Firebase Cloud Messaging (FCM): servicio multiplataforma para enviar notificaciones push y mensajes entre servidor/app. :contentReference[oaicite:9]{index=9}  
- **ConfiguraciÃ³n remota / personalizaciÃ³n / pruebas A / B**  
	- Remote Config: permite cambiar parÃ¡metros de la app en producciÃ³n sin desplegar cÃ³digo nuevo, hacer pruebas A/B, activar/desactivar funciones. :contentReference[oaicite:11]{index=11}  
- **Seguridad y validaciÃ³n de apps**  
	- App Check: servicio que protege que las peticiones a tu backend/vÃ­as autorizadas provengan de instancias vÃ¡lidas de tu app y no de servidores maliciosos. :contentReference[oaicite:13]{index=13}  
- **AnalÃ­tica, crecimiento y calidad de apps**  
	- Firebase Analytics y otros: monitorizaciÃ³n del uso, comportamiento de usuarios, eventos de conversiÃ³n. :contentReference[oaicite:15]{index=15}  
	- Crashlytics: reporte de errores en apps mÃ³viles/web en producciÃ³n.  
- **Plataforma de hosting y despliegue**  
	- Firebase Hosting: despliegue de frontend (sitios estÃ¡ticos, SPAs), integraciÃ³n con CDN y SSL automÃ¡tico.  
- **IntegraciÃ³n con otros servicios de Google Cloud**  
	- Muchos servicios de Firebase se integran directamente con Google Cloud Platform (GCP) para analÃ­tica avanzada, big-data, ML, etc. :contentReference[oaicite:19]{index=19}  

## Arquitecturas y patrones recomendados  
- Puede usarse como **backend completo**: autenticaciÃ³n + base de datos + reglas + funciones serverless + hosting â†’ permite lanzar prototipos/MVP sin servidor propio.  
- TambiÃ©n se puede integrar como **pieza de un sistema hÃ­brido**: por ejemplo, usar Firestore + Functions pero con microservicios externos o bases de datos relacionales para casos complejos.  
- Buenas prÃ¡cticas:  
	- Definir reglas de seguridad (Firestore, Storage) con cuidado.  
	- Indexar consultas eficientemente (especialmente Firestore).  
	- Limitar costes: el plan gratuito es viable para prototipos pero en producciÃ³n se debe monitorizar uso.  
	- Versionar las funciones y usar entornos de staging para evitar romper producciÃ³n.  
- Consideraciones de escalabilidad: aunque muchos servicios escalan automÃ¡ticamente, hay lÃ­mites y costes que diseÃ±ar con antelaciÃ³n (por ejemplo nÃºmero de lecturas/escrituras en Firestore, trÃ¡fico en funciones, coste de notificaciones).  
- Migraciones y evoluciÃ³n: si empiezas con Realtime Database quizÃ¡ en futuro migrar a Firestore si necesitas consultas mÃ¡s potentes o esquemas mÃ¡s complejos.

## Casos de uso avanzados  
- Apps en tiempo real: chats, dashboards en vivo, colaboraciÃ³n simultÃ¡nea.  
- Aplicaciones mÃ³viles + web con backend compartido: un solo proyecto Firebase que atiende mÃºltiples plataformas.  
- Juegos, aplicaciones sociales, plataformas de contenido generador por usuario donde el almacenamiento de archivos + base de datos + autentificaciÃ³n deben estar integrados.  
- MVP rÃ¡pidos y validaciÃ³n de idea: usando Firebase como plataforma base para iterar rÃ¡pido sin infra compleja.  
- Apps serverless que requieren lÃ³gica backend ligera (webhooks, triggers de base de datos, procesamiento de imÃ¡genes) usando Cloud Functions.  
- PersonalizaciÃ³n y experimentaciÃ³n: con Remote Config, A/B testing, analytics para optimizar UX.

## Limitaciones y puntos a tener en cuenta  
- Las bases NoSQL requieren pensar diferente que bases relacionales: no hay JOINs clÃ¡sicos, consultas complejas pueden requerir otros servicios o trabajo adicional.  
- Costes en producciÃ³n pueden crecer si no se gestionan Ã­ndices, reglas o triggers ineficientes.  
- Algunas funcionalidades como bÃºsqueda de texto avanzada o geoqueries complejas pueden ser limitadas directamente en Firestore y pueden necesitar servicios externos (como Elasticsearch). > â€œtbh the search issue is one of the biggest problems in Firebase â€¦ I thought it would be easier to deploy a full application.â€ :contentReference[oaicite:20]{index=20}  
- Dependencia de la plataforma: aunque es muy integrado, si necesitas mover a otro proveedor o infra muy especÃ­fica quizÃ¡ haya fricciÃ³n.

## IntegraciÃ³n con Next.js y stack moderno  
- Proyecto tipo plantilla: [Next Firebase Template](https://github.com/milliorn/nextjs-13-firebase-starter) (ya citado).  
- En Next.js puedes:  
	- Usar Firebase Auth en servidor y cliente para rutas protegidas.  
	- Acceder a Firestore desde API routes o funciones serverless.  
	- Desplegar el frontend en Firebase Hosting o usar Vercel + backend Firebase.  
	- Aprovechar SSR/ISR con Next.js y Firebase como backend ligero.  
- Arquitectura sugerida: Next.js (frontend/SSR) + Firebase Auth + Firestore + Firebase Hosting para frontend estÃ¡tico + Cloud Functions para lÃ³gica backend pesada.

## Etiquetas sugeridas para la nota  
- BaaS  
- NoSQL  
- Auth  
- Hosting  
- Serverless  
- MVP  
- StackNext  
- Cloud  
- FirebaseServices  

# Firebase â€“ GuÃ­a completa 2025

- [Backend](/backend/backend/)
- [Databases](/databases/databases/)
- [nextjs](/frontend/nextjs/)
- [cloud](/cloud/cloud/)
- BaaS
- MVP
- Serverless

---

## ðŸ§© VisiÃ³n general
Firebase es una plataforma de desarrollo de Google que ofrece servicios en la nube para construir aplicaciones web y mÃ³viles sin gestionar infraestructura.  
Su enfoque **BaaS (Backend as a Service)** permite integrar autenticaciÃ³n, bases de datos, hosting, almacenamiento y funciones serverless en un mismo ecosistema.

---

## ðŸ”§ Componentes principales

### 1. Base de datos
- **Firestore**
	- Base de datos NoSQL moderna y escalable.
	- Modelo basado en **colecciones y documentos** (JSON).
	- Consultas estructuradas, Ã­ndices automÃ¡ticos y transacciones.
	- IntegraciÃ³n nativa con SDKs web, Android, iOS y Node.js.
	- SincronizaciÃ³n en tiempo real y modo offline.

- **Realtime Database**
	- Base NoSQL original de Firebase.
	- Estructura tipo Ã¡rbol JSON.
	- Ideal para sincronizaciÃ³n inmediata (chats, colaboraciÃ³n, IoT).
	- Menor flexibilidad para consultas avanzadas.

#### Buenas prÃ¡cticas
- DiseÃ±ar datos **orientados a consultas**, no a relaciones.
- Minimizar lecturas costosas (usar subcolecciones e Ã­ndices).
- Definir **reglas de seguridad** basadas en usuario y rol.

---

### 2. AutenticaciÃ³n
- Firebase Auth simplifica el inicio de sesiÃ³n en apps web y mÃ³viles.
- MÃ©todos soportados:
	- Email y contraseÃ±a.
	- Proveedores externos: Google, GitHub, Facebook, Apple, Twitter.
	- AutenticaciÃ³n anÃ³nima o por enlace mÃ¡gico.
- Ofrece persistencia automÃ¡tica de sesiÃ³n y gestiÃ³n de tokens JWT.

#### Reglas y seguridad
- DefiniciÃ³n de reglas con `firestore.rules` o `storage.rules`.
- IntegraciÃ³n con Firestore y Cloud Storage para filtrar acceso segÃºn `request.auth.uid`.

---

### 3. Hosting
- **Firebase Hosting**
	- Ideal para sitios estÃ¡ticos, SPAs y PWAs.
	- CDN global, HTTP/2 y SSL automÃ¡tico.
	- Permite despliegues instantÃ¡neos (`firebase deploy`).
	- IntegraciÃ³n con dominios personalizados.
- **Casos de uso**
	- Despliegue de proyectos [nextjs](/frontend/nextjs/) o [astro](/frontend/astro/).
	- Hosting para documentaciones, portfolios, MVPs.

---

### 4. Almacenamiento
- **Cloud Storage for Firebase**
	- Guarda archivos (imÃ¡genes, vÃ­deos, PDFs) con seguridad y escalabilidad.
	- Control de acceso mediante reglas y tokens de usuario.
	- IntegraciÃ³n directa con Firestore o Auth.
	- Soporta subida, descarga y metadatos.

---

### 5. Funciones Serverless
- **Cloud Functions for Firebase**
	- Permite ejecutar cÃ³digo backend sin servidores.
	- Se activan mediante eventos:
		- Cambios en Firestore o Realtime Database.
		- Nuevos usuarios en Auth.
		- Subidas a Storage.
		- Llamadas HTTP.
	- Escalado automÃ¡tico y logs centralizados.

#### Ejemplo de uso
- Validar datos antes de escribir en la base.
- Generar miniaturas de imÃ¡genes.
- Enviar notificaciones push tras eventos.

---

### 6. MensajerÃ­a y Notificaciones
- **Firebase Cloud Messaging (FCM)**
	- EnvÃ­o de notificaciones push y mensajes entre cliente/servidor.
	- Compatible con Android, iOS, Web y Flutter.
	- Admite segmentaciÃ³n de usuarios y envÃ­o condicional.

---

### 7. AnalÃ­tica y monitoreo
- **Google Analytics for Firebase**
	- AnalÃ­tica en tiempo real, embebida en el SDK.
	- IntegraciÃ³n con BigQuery y Google Ads.
	- Seguimiento de conversiones, embudos y comportamiento de usuario.
- **Crashlytics**
	- Reporte en tiempo real de errores y fallos en apps mÃ³viles.
- **Performance Monitoring**
	- Mide tiempos de carga, latencia de red y uso de recursos.

---

### 8. ConfiguraciÃ³n remota y experimentaciÃ³n
- **Remote Config**
	- Permite cambiar valores en producciÃ³n sin redeploy.
	- Ideal para activaciÃ³n de funciones, A/B Testing o personalizaciÃ³n dinÃ¡mica.
- **A/B Testing**
	- Integrado con Remote Config y Analytics.
	- EvalÃºa impacto de cambios antes de aplicarlos globalmente.

---

### 9. Seguridad y validaciÃ³n
- **App Check**
	- Protege tus recursos asegurando que las solicitudes provengan de instancias legÃ­timas.
	- Compatible con Android, iOS y Web.
- **Security Rules**
	- Controlan lectura/escritura en Firestore y Storage.
	- Basadas en condiciones del usuario o tipo de dato.

---

### 10. IntegraciÃ³n con Google Cloud
- IntegraciÃ³n directa con GCP:
	- BigQuery (anÃ¡lisis avanzado).
	- Cloud Run y Cloud Tasks (procesamiento personalizado).
	- Vertex AI (machine learning).
- Firebase actÃºa como una **capa simplificada** para desarrollos rÃ¡pidos sobre la infraestructura de Google Cloud.

---

## âš™ï¸ Arquitecturas y patrones recomendados
- **Full Firebase App:**  
	Usa Firebase para todo (Auth + Firestore + Hosting + Functions). Perfecto para MVP o startups.

- **HÃ­brido (Firebase + Backend propio):**  
	Mantiene Firestore/Auth pero usa un backend Node.js o [Springboot](/backend/springboot/) para lÃ³gica avanzada o APIs REST.

- **Headless Backend:**  
	Firebase sirve de backend desacoplado para proyectos [nextjs](/frontend/nextjs/) o [react](/frontend/react/) (arquitectura JAMstack).

#### Buenas prÃ¡cticas
- Usar variables de entorno para API keys.
- Configurar entornos de desarrollo y producciÃ³n separados.
- Monitorizar uso (lecturas, escrituras, almacenamiento).
- Implementar caching en cliente si se accede frecuentemente a Firestore.

---

## ðŸ’¡ Casos de uso comunes
- Aplicaciones de chat en tiempo real.
- Dashboards colaborativos.
- Juegos online con sincronizaciÃ³n de progreso.
- Plataformas de contenido UGC (imÃ¡genes, posts, vÃ­deos).
- MVPs o prototipos sin backend dedicado.
- Apps hÃ­bridas (mÃ³vil + web) con sincronizaciÃ³n en vivo.

---

## âš ï¸ Limitaciones y consideraciones
- NoSQL requiere diseÃ±ar datos por consulta, no por relaciÃ³n.
- No hay JOINs ni queries complejas nativas.
- Coste puede crecer rÃ¡pidamente si no se optimiza:
	- Lecturas/escrituras de Firestore.
	- TrÃ¡fico en funciones.
	- Almacenamiento de archivos grandes.
- Algunas funciones (bÃºsqueda avanzada, geolocalizaciÃ³n, informes) pueden requerir servicios externos.
- Alta dependencia del ecosistema Google (vendor lock-in).

---

## ðŸ§  Firebase + Next.js
- IntegraciÃ³n nativa con [nextjs](/frontend/nextjs/):
	- Uso de Firestore o Auth desde API Routes.
	- Despliegue SSR o SSG con Hosting o Vercel.
	- Reglas de Auth en middleware.
- Plantilla recomendada: [Next Firebase Template](https://github.com/milliorn/nextjs-13-firebase-starter)

---

## ðŸ’» Ejemplo de inicializaciÃ³n bÃ¡sica
{% raw %}
```javascript
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";

const firebaseConfig = {
	apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
	authDomain: "tuapp.firebaseapp.com",
	projectId: "tuapp",
	storageBucket: "tuapp.appspot.com",
	messagingSenderId: "XXXXXX",
	appId: "1:XXXXXX:web:XXXXXX"
};

export const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);
```
{% endraw %}`

---

## ðŸš€ Ejemplo de despliegue

{% raw %}
```bash
# Inicializar proyecto
firebase init

# Elegir servicios (Hosting, Functions, Firestore)
# Configurar dominio y reglas

# Desplegar aplicaciÃ³n
firebase deploy
```
{% endraw %}

# Firebase â€“ Ejemplos de cÃ³digo prÃ¡cticos  

- [Backend](/backend/backend/)
- [Databases](/databases/databases/)
- [nextjs](/frontend/nextjs/)
- [cloud](/cloud/cloud/)
- BaaS
- MVP
- Serverless

---

## ðŸ”° InicializaciÃ³n bÃ¡sica del proyecto

{% raw %}
```javascript
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getAuth } from "firebase/auth";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
	apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
	authDomain: "tuapp.firebaseapp.com",
	projectId: "tuapp",
	storageBucket: "tuapp.appspot.com",
	messagingSenderId: "123456789",
	appId: "1:123456789:web:abcdef123456"
};

export const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);
export const auth = getAuth(app);
export const storage = getStorage(app);
```
{% endraw %}`

---

## ðŸ“ Firestore â€“ CRUD bÃ¡sico

### Crear documento

{% raw %}
```javascript
import { collection, addDoc } from "firebase/firestore";
import { db } from "./firebase";

async function createUser() {
	try {
		const docRef = await addDoc(collection(db, "usuarios"), {
			nombre: "Eduardo",
			email: "eduardo@example.com",
			activo: true,
			fechaCreacion: new Date()
		});
		console.log("Usuario creado con ID:", docRef.id);
	} catch (error) {
		console.error("Error al crear usuario:", error);
	}
}
```
{% endraw %}

### Leer documentos

{% raw %}
```javascript
import { collection, getDocs } from "firebase/firestore";
import { db } from "./firebase";

async function getUsers() {
	const querySnapshot = await getDocs(collection(db, "usuarios"));
	querySnapshot.forEach((doc) => {
		console.log(`${doc.id} =>`, doc.data());
	});
}
```
{% endraw %}

### Actualizar documento

{% raw %}
```javascript
import { doc, updateDoc } from "firebase/firestore";
import { db } from "./firebase";

async function updateUser(id) {
	const userRef = doc(db, "usuarios", id);
	await updateDoc(userRef, { activo: false });
	console.log("Usuario actualizado");
}
```
{% endraw %}

### Eliminar documento

{% raw %}
```javascript
import { doc, deleteDoc } from "firebase/firestore";
import { db } from "./firebase";

async function deleteUser(id) {
	await deleteDoc(doc(db, "usuarios", id));
	console.log("Usuario eliminado");
}
```
{% endraw %}

---

## ðŸ” AutenticaciÃ³n

### Registro de usuario

{% raw %}
```javascript
import { getAuth, createUserWithEmailAndPassword } from "firebase/auth";
const auth = getAuth();

async function register(email, password) {
	try {
		const userCredential = await createUserWithEmailAndPassword(auth, email, password);
		console.log("Usuario registrado:", userCredential.user);
	} catch (error) {
		console.error("Error en registro:", error);
	}
}
```
{% endraw %}

### Inicio de sesiÃ³n

{% raw %}
```javascript
import { getAuth, signInWithEmailAndPassword } from "firebase/auth";
const auth = getAuth();

async function login(email, password) {
	try {
		const userCredential = await signInWithEmailAndPassword(auth, email, password);
		console.log("Usuario logueado:", userCredential.user);
	} catch (error) {
		console.error("Error en login:", error);
	}
}
```
{% endraw %}

### Cierre de sesiÃ³n

{% raw %}
```javascript
import { getAuth, signOut } from "firebase/auth";
const auth = getAuth();

async function logout() {
	await signOut(auth);
	console.log("SesiÃ³n cerrada");
}
```
{% endraw %}

---

## â˜ï¸ Cloud Storage

### Subir archivo

{% raw %}
```javascript
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
import { storage } from "./firebase";

async function uploadFile(file) {
	const storageRef = ref(storage, `uploads/${file.name}`);
	await uploadBytes(storageRef, file);
	const url = await getDownloadURL(storageRef);
	console.log("Archivo subido:", url);
	return url;
}
```
{% endraw %}

### Eliminar archivo

{% raw %}
```javascript
import { ref, deleteObject } from "firebase/storage";
import { storage } from "./firebase";

async function deleteFile(path) {
	const fileRef = ref(storage, path);
	await deleteObject(fileRef);
	console.log("Archivo eliminado");
}
```
{% endraw %}

---

## âš™ï¸ Cloud Functions (ejemplo simple)

### index.js

{% raw %}
```javascript
const functions = require("firebase-functions");
const admin = require("firebase-admin");

admin.initializeApp();
const db = admin.firestore();

// FunciÃ³n que se activa al crear un usuario en Firestore
exports.welcomeUser = functions.firestore
	.document("usuarios/{userId}")
	.onCreate(async (snap, context) => {
		const newUser = snap.data();
		console.log("Nuevo usuario creado:", newUser.email);
		await db.collection("logs").add({
			mensaje: `Bienvenido ${newUser.nombre}`,
			fecha: new Date()
		});
	});
```
{% endraw %}

---

## ðŸ“¡ Firebase Cloud Messaging (FCM)

{% raw %}
```javascript
import { getMessaging, getToken, onMessage } from "firebase/messaging";
import { app } from "./firebase";

const messaging = getMessaging(app);

async function solicitarPermiso() {
	try {
		const permiso = await Notification.requestPermission();
		if (permiso === "granted") {
			const token = await getToken(messaging, {
				vapidKey: "TU_VAPID_KEY_PUBLICA"
			});
			console.log("Token de notificaciÃ³n:", token);
		}
	} catch (error) {
		console.error("Error obteniendo token:", error);
	}
}

onMessage(messaging, (payload) => {
	console.log("NotificaciÃ³n recibida:", payload);
});
```
{% endraw %}

---

## âš¡ Remote Config

### ConfiguraciÃ³n y obtenciÃ³n de valores

{% raw %}
```javascript
import { getRemoteConfig, fetchAndActivate, getValue } from "firebase/remote-config";
import { app } from "./firebase";

const remoteConfig = getRemoteConfig(app);
remoteConfig.settings.minimumFetchIntervalMillis = 3600000;

async function cargarConfiguracion() {
	try {
		await fetchAndActivate(remoteConfig);
		const mensaje = getValue(remoteConfig, "mensaje_bienvenida").asString();
		console.log("Mensaje remoto:", mensaje);
	} catch (error) {
		console.error("Error cargando configuraciÃ³n remota:", error);
	}
}
```
{% endraw %}

---

## ðŸ”Ž Reglas de seguridad bÃ¡sicas (Firestore)

{% raw %}
```js
rules_version = '2';
service cloud.firestore {
	match /databases/{database}/documents {
		match /usuarios/{userId} {
			allow read, write: if request.auth.uid == userId;
		}
		match /public/{document=**} {
			allow read: if true;
			allow write: if request.auth != null;
		}
	}
}
```
{% endraw %}

---

## ðŸš€ Despliegue

{% raw %}
```bash
# Inicializar proyecto Firebase
firebase init

# Seleccionar servicios (Firestore, Functions, Hosting, Storage)

# Desplegar todo
firebase deploy
```
{% endraw %}




