---
date: 2025-01-03 00:49
title: SOLID
tags:
  - CS
  - SOLID
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Computer Science
public_note: "true"
category: Computer Science
---
# Principios SOLID
`$= dv.current().file.tags.join(" ")` 

Los principios SOLID son cinco principios de dise√±o orientado a objetos que buscan crear software m√°s comprensible, flexible y mantenible.

- SRP, principio de responsabilidad unica
- OCP  principio open close
- LSP,  Liskov substitution principle
- ISP Interface segregation principle
- DIP  Dependency inyection principle (Acoplamiento)
- [Computer Science](/uncategorized/computer-science/)
- [CLEAN](/computer%20science/clean/)
- [Computer Science](/uncategorized/computer-science/) [CLEAN](/computer%20science/clean/) SOLID- los 5 principios que te ayudar√°n a desarrollar software de calidad

## SRP - Principio de Responsabilidad √önica
**Una clase debe tener una sola raz√≥n para cambiar**, meaning it should have only one job or responsibility.

- **Beneficios**: C√≥digo m√°s f√°cil de entender, mantener y probar
- **Ejemplo**: Separar una clase que maneja datos y tambi√©n genera reportes en dos clases distintas
- **Consecuencias de violarlo**: Cambios en una funcionalidad afectan m√∫ltiples partes del sistema
- **Detecci√≥n**: Una clase con muchos m√©todos no relacionados o que cambia por diferentes razones

---

## OCP - Principio Abierto/Cerrado
**Las entidades de software deben estar abiertas para extensi√≥n pero cerradas para modificaci√≥n**.

- **Extensi√≥n sin modificaci√≥n**: A√±adir nuevo comportamiento mediante herencia, composici√≥n o interfaces
- **Patrones aplicables**: Strategy, Decorator, Factory
- **Ventajas**: Reduce el riesgo de introducir bugs en c√≥digo existente
- **Ejemplo**: Usar interfaces para permitir nuevos tipos de pago sin modificar la clase principal de procesamiento

---

## LSP - Principio de Sustituci√≥n de Liskov
**Los objetos de un programa deber√≠an ser reemplazables por instancias de sus subtipos sin alterar el correcto funcionamiento del programa**.

- **Relaci√≥n "es-un"**: Debe ser semanticamente correcta
- **Precondiciones y postcondiciones**: Las subclases no deben fortalecer precondiciones ni debilitar postcondiciones
- **Violaciones comunes**: 
	- Lanzar excepciones inesperadas
	- Devolver tipos de datos diferentes
	- Tener requisitos de inicializaci√≥n diferentes
- **Ejemplo**: Si `Pato` hereda de `Ave`, debe poder usar todos los m√©todos de `Ave` correctamente

---

## ISP - Principio de Segregaci√≥n de Interfaces
**Ning√∫n cliente deber√≠a verse forzado a depender de m√©todos que no usa**.

- **Interfaces espec√≠ficas**: Mejor muchas interfaces espec√≠ficas que una general
- **Detecci√≥n de violaciones**: Clientes que implementan m√©todos vac√≠os o lanzan "NotImplementedException"
- **Beneficios**: Reduce el acoplamiento y las dependencias no necesarias
- **Ejemplo**: Separar una interfaz `IMultifuncional` en `IImpresora`, `IEsc√°ner`, `IFax`

---

## DIP - Principio de Inversi√≥n de Dependencias
**Depende de abstracciones, no de implementaciones concretas**.

- **M√≥dulos de alto nivel**: No deben depender de m√≥dulos de bajo nivel
- **Abstracciones**: No deben depender de detalles, los detalles deben depender de abstracciones
- **Patrones relacionados**: Inyecci√≥n de dependencias, Service Locator
- **Acoplamiento**: Reduce el acoplamiento fuerte entre componentes
- **Implementaci√≥n**: Usar interfaces o clases abstractas como puntos de dependencia
- **Ventajas**: C√≥digo m√°s testeable, mantenible y flexible

---

## Relaci√≥n entre Principios

- **SRP y ISP**: Ambos buscan la cohesi√≥n y separaci√≥n de responsabilidades
- **DIP y OCP**: Facilitan la extensibilidad del sistema
- **LSP**: Garantiza que la herencia y polimorfismo funcionen correctamente
- **Conjunto**: Crean arquitecturas desacopladas, mantenibles y escalables

---

## Beneficios de Aplicar SOLID

- **Mantenibilidad**: C√≥digo m√°s f√°cil de modificar y extender
- **Testabilidad**: Componentes aislados m√°s f√°ciles de probar
- **Reusabilidad**: Componentes con responsabilidades bien definidas
- **Reducci√≥n de acoplamiento**: Dependencias claras y gestionadas
- **Resiliencia**: Menos efectos colaterales al hacer cambios

# Ejemplos Pr√°cticos de Principios SOLID

## SRP - Ejemplo Pr√°ctico

### ‚ùå Violaci√≥n del SRP
```typescript
class User {
  constructor(private name: string, private email: string) {}
  
  getUserInfo(): string {
    return `${this.name} <${this.email}>`;
  }
  
  saveToDatabase(): void {
    // L√≥gica para guardar en base de datos
    console.log(`Guardando usuario ${this.name} en la base de datos...`);
  }
  
  sendEmail(subject: string, message: string): void {
    // L√≥gica para enviar email
    console.log(`Enviando email a ${this.email}: ${subject}`);
  }
}
```

### ‚úÖ Aplicando SRP
```typescript
class User {
  constructor(private name: string, private email: string) {}
  
  getUserInfo(): string {
    return `${this.name} <${this.email}>`;
  }
}

class UserRepository {
  saveUser(user: User): void {
    console.log(`Guardando usuario en la base de datos...`);
  }
}

class EmailService {
  sendEmail(to: string, subject: string, message: string): void {
    console.log(`Enviando email a ${to}: ${subject}`);
  }
}
```

---

## OCP - Ejemplo Pr√°ctico

### ‚ùå Violaci√≥n del OCP
```typescript
class AreaCalculator {
  calculateArea(shape: any): number {
    if (shape.type === 'circle') {
      return Math.PI * shape.radius * shape.radius;
    } else if (shape.type === 'rectangle') {
      return shape.width * shape.height;
    }
    // Para a√±adir un tri√°ngulo, tendr√≠a que MODIFICAR esta clase
    throw new Error('Tipo de forma no soportada');
  }
}
```

### ‚úÖ Aplicando OCP
```typescript
interface Shape {
  area(): number;
}

class Circle implements Shape {
  constructor(private radius: number) {}
  
  area(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle implements Shape {
  constructor(private width: number, private height: number) {}
  
  area(): number {
    return this.width * this.height;
  }
}

class Triangle implements Shape {
  constructor(private base: number, private height: number) {}
  
  area(): number {
    return (this.base * this.height) / 2;
  }
}

class AreaCalculator {
  calculateArea(shape: Shape): number {
    return shape.area();
  }
}
```

---

## LSP - Ejemplo Pr√°ctico

### ‚ùå Violaci√≥n del LSP
```typescript
class Bird {
  fly(): void {
    console.log("Volando...");
  }
}

class Duck extends Bird {
  // OK - los patos pueden volar
}

class Penguin extends Bird {
  fly(): void {
    throw new Error("Los ping√ºinos no pueden volar!");
  }
}

// Uso que viola LSP
function makeBirdFly(bird: Bird): void {
  bird.fly(); // ‚ùå Esto fallar√° con Penguin
}
```

### ‚úÖ Aplicando LSP
```typescript
class Bird {
  // Comportamiento com√∫n a todas las aves
}

interface FlyingBird {
  fly(): void;
}

class Duck extends Bird implements FlyingBird {
  fly(): void {
    console.log("Pato volando...");
  }
  
  swim(): void {
    console.log("Pato nadando...");
  }
}

class Penguin extends Bird {
  swim(): void {
    console.log("Ping√ºino nadando...");
  }
}

// Uso correcto
function makeBirdFly(bird: FlyingBird): void {
  bird.fly(); // ‚úÖ Solo acepta aves que pueden volar
}
```

---

## ISP - Ejemplo Pr√°ctico

### ‚ùå Violaci√≥n del ISP
```typescript
interface Worker {
  work(): void;
  eat(): void;
  sleep(): void;
}

class Robot implements Worker {
  work(): void {
    console.log("Robot trabajando...");
  }
  
  eat(): void {
    throw new Error("Los robots no comen!");
  }
  
  sleep(): void {
    throw new Error("Los robots no duermen!");
  }
}

class Human implements Worker {
  work(): void {
    console.log("Humano trabajando...");
  }
  
  eat(): void {
    console.log("Humano comiendo...");
  }
  
  sleep(): void {
    console.log("Humano durmiendo...");
  }
}
```

### ‚úÖ Aplicando ISP
```typescript
interface Workable {
  work(): void;
}

interface Eatable {
  eat(): void;
}

interface Sleepable {
  sleep(): void;
}

class Robot implements Workable {
  work(): void {
    console.log("Robot trabajando...");
  }
}

class Human implements Workable, Eatable, Sleepable {
  work(): void {
    console.log("Humano trabajando...");
  }
  
  eat(): void {
    console.log("Humano comiendo...");
  }
  
  sleep(): void {
    console.log("Humano durmiendo...");
  }
}
```

---

## DIP - Ejemplo Pr√°ctico

### ‚ùå Violaci√≥n del DIP
```typescript
class MySQLDatabase {
  connect(): void {
    console.log("Conectando a MySQL...");
  }
  
  query(sql: string): any {
    console.log(`Ejecutando query en MySQL: ${sql}`);
    return { results: [] };
  }
}

class UserService {
  private database: MySQLDatabase;
  
  constructor() {
    this.database = new MySQLDatabase(); // ‚ùå Dependencia concreta
    this.database.connect();
  }
  
  getUsers(): any {
    return this.database.query("SELECT * FROM users");
  }
}
```

### ‚úÖ Aplicando DIP
```typescript
interface Database {
  connect(): void;
  query(sql: string): any;
}

class MySQLDatabase implements Database {
  connect(): void {
    console.log("Conectando a MySQL...");
  }
  
  query(sql: string): any {
    console.log(`Ejecutando query en MySQL: ${sql}`);
    return { results: [] };
  }
}

class PostgreSQLDatabase implements Database {
  connect(): void {
    console.log("Conectando a PostgreSQL...");
  }
  
  query(sql: string): any {
    console.log(`Ejecutando query en PostgreSQL: ${sql}`);
    return { results: [] };
  }
}

class UserService {
  constructor(private database: Database) { // ‚úÖ Dependencia de abstracci√≥n
    this.database.connect();
  }
  
  getUsers(): any {
    return this.database.query("SELECT * FROM users");
  }
}

// Uso
const mySQLDb = new MySQLDatabase();
const userService = new UserService(mySQLDb);

const postgreSQLDb = new PostgreSQLDatabase();
const userService2 = new UserService(postgreSQLDb);
```

---

## Ejemplo Integrado - Sistema de Notificaciones

### ‚ùå Sin SOLID
```typescript
class NotificationService {
  sendNotification(user: any, message: string, type: string): void {
    if (type === 'email') {
      // L√≥gica compleja para enviar email
      console.log(`Enviando email a ${user.email}: ${message}`);
    } else if (type === 'sms') {
      // L√≥gica compleja para enviar SMS
      console.log(`Enviando SMS a ${user.phone}: ${message}`);
    } else if (type === 'push') {
      // L√≥gica compleja para notificaci√≥n push
      console.log(`Enviando push a ${user.deviceId}: ${message}`);
    }
    // Registrar en base de datos
    console.log(`Registrando notificaci√≥n en BD...`);
  }
}
```

### ‚úÖ Con SOLID Aplicado
```typescript
// SRP + ISP: Interfaces segregadas
interface NotificationChannel {
  send(to: string, message: string): void;
}

interface NotificationRepository {
  save(notification: any): void;
}

// OCP: F√°cil de extender
class EmailChannel implements NotificationChannel {
  send(to: string, message: string): void {
    console.log(`Enviando email a ${to}: ${message}`);
  }
}

class SMSChannel implements NotificationChannel {
  send(to: string, message: string): void {
    console.log(`Enviando SMS a ${to}: ${message}`);
  }
}

class PushChannel implements NotificationChannel {
  send(to: string, message: string): void {
    console.log(`Enviando push a ${to}: ${message}`);
  }
}

// DIP: Depende de abstracciones
class NotificationService {
  constructor(
    private channels: NotificationChannel[],
    private repository: NotificationRepository
  ) {}
  
  sendNotification(user: any, message: string): void {
    this.channels.forEach(channel => {
      channel.send(user.contact, message);
    });
    
    this.repository.save({
      userId: user.id,
      message: message,
      timestamp: new Date()
    });
  }
}

// Uso
const emailChannel = new EmailChannel();
const smsChannel = new SMSChannel();
const repository = new DatabaseNotificationRepository();

const notificationService = new NotificationService(
  [emailChannel, smsChannel],
  repository
);
```

---

## Patrones de Detecci√≥n de Violaciones

### Se√±ales de que necesitas aplicar SOLID:

**SRP**: 
- Una clase cambia por m√∫ltiples razones
- Tiene muchos m√©todos no relacionados
- Es dif√≠cil de testear

**OCP**:
- Modificas c√≥digo existente para a√±adir funcionalidad
- Muchos `if/else` o `switch` para tipos

**LSP**:
- `instanceof` checks frecuentes
- M√©todos que lanzan "NotImplemented"
- Subclases que no usan todos los m√©todos padre

**ISP**:
- Interfaces con muchos m√©todos
- Clases que implementan m√©todos vac√≠os
- Dependencias forzadas

**DIP**:
- `new` keyword en constructores de servicios
- Dificultad para hacer testing
- Acoplamiento fuerte entre m√≥dulos

# Patrones de Dise√±o que Complementan SOLID

## Patrones Creacionales

### Factory Method
```typescript
interface PaymentProcessor {
    process(amount: number): void;
}

class CreditCardProcessor implements PaymentProcessor {
    process(amount: number): void {
        console.log(`Processing credit card payment: $${amount}`);
    }
}

class PayPalProcessor implements PaymentProcessor {
    process(amount: number): void {
        console.log(`Processing PayPal payment: $${amount}`);
    }
}

abstract class PaymentProcessorFactory {
    abstract createProcessor(): PaymentProcessor;
    
    processPayment(amount: number): void {
        const processor = this.createProcessor();
        processor.process(amount);
    }
}

class CreditCardFactory extends PaymentProcessorFactory {
    createProcessor(): PaymentProcessor {
        return new CreditCardProcessor();
    }
}
```

### Builder Pattern
```typescript
class QueryBuilder {
    private table: string = '';
    private fields: string[] = [];
    private conditions: string[] = [];
    
    select(fields: string[]): QueryBuilder {
        this.fields = fields;
        return this;
    }
    
    from(table: string): QueryBuilder {
        this.table = table;
        return this;
    }
    
    where(condition: string): QueryBuilder {
        this.conditions.push(condition);
        return this;
    }
    
    build(): string {
        return `SELECT ${this.fields.join(', ')} FROM ${this.table} WHERE ${this.conditions.join(' AND ')}`;
    }
}
```

---

## Patrones Estructurales

### Adapter Pattern
```typescript
// Servicio legacy que no sigue nuestra interfaz
class LegacyWeatherService {
    fetchWeatherData(city: string): any {
        return { temperature: 72, condition: 'sunny' };
    }
}

// Interfaz moderna que queremos usar
interface WeatherService {
    getWeather(city: string): WeatherData;
}

interface WeatherData {
    temp: number;
    description: string;
}

// Adapter que convierte la interfaz legacy a la moderna
class WeatherServiceAdapter implements WeatherService {
    constructor(private legacyService: LegacyWeatherService) {}
    
    getWeather(city: string): WeatherData {
        const legacyData = this.legacyService.fetchWeatherData(city);
        return {
            temp: legacyData.temperature,
            description: legacyData.condition
        };
    }
}
```

### Composite Pattern
```typescript
interface FileSystemComponent {
    getName(): string;
    getSize(): number;
    display(indent: string): void;
}

class File implements FileSystemComponent {
    constructor(private name: string, private size: number) {}
    
    getName(): string { return this.name; }
    getSize(): number { return this.size; }
    
    display(indent: string): void {
        console.log(`${indent}File: ${this.name} (${this.size} bytes)`);
    }
}

class Directory implements FileSystemComponent {
    private children: FileSystemComponent[] = [];
    
    constructor(private name: string) {}
    
    getName(): string { return this.name; }
    
    getSize(): number {
        return this.children.reduce((total, child) => total + child.getSize(), 0);
    }
    
    add(component: FileSystemComponent): void {
        this.children.push(component);
    }
    
    display(indent: string): void {
        console.log(`${indent}Directory: ${this.name}`);
        this.children.forEach(child => child.display(indent + '  '));
    }
}
```

---

## Patrones de Comportamiento

### Strategy Pattern
```typescript
interface SortingStrategy {
    sort(data: number[]): number[];
}

class BubbleSort implements SortingStrategy {
    sort(data: number[]): number[] {
        console.log("Sorting using bubble sort");
        return [...data].sort((a, b) => a - b);
    }
}

class QuickSort implements SortingStrategy {
    sort(data: number[]): number[] {
        console.log("Sorting using quick sort");
        return this.quickSort([...data]);
    }
    
    private quickSort(data: number[]): number[] {
        if (data.length <= 1) return data;
        const pivot = data[0];
        const left = data.slice(1).filter(x => x <= pivot);
        const right = data.slice(1).filter(x => x > pivot);
        return [...this.quickSort(left), pivot, ...this.quickSort(right)];
    }
}

class Sorter {
    constructor(private strategy: SortingStrategy) {}
    
    setStrategy(strategy: SortingStrategy): void {
        this.strategy = strategy;
    }
    
    sort(data: number[]): number[] {
        return this.strategy.sort(data);
    }
}
```

### Observer Pattern
```typescript
interface Observer {
    update(data: any): void;
}

interface Subject {
    attach(observer: Observer): void;
    detach(observer: Observer): void;
    notify(): void;
}

class WeatherStation implements Subject {
    private observers: Observer[] = [];
    private temperature: number = 0;
    
    attach(observer: Observer): void {
        this.observers.push(observer);
    }
    
    detach(observer: Observer): void {
        const index = this.observers.indexOf(observer);
        if (index > -1) {
            this.observers.splice(index, 1);
        }
    }
    
    notify(): void {
        this.observers.forEach(observer => 
            observer.update(this.temperature)
        );
    }
    
    setTemperature(temp: number): void {
        this.temperature = temp;
        this.notify();
    }
}

class TemperatureDisplay implements Observer {
    update(temperature: number): void {
        console.log(`Temperature Display: ${temperature}¬∞C`);
    }
}

class Logger implements Observer {
    update(temperature: number): void {
        console.log(`Logger: Temperature changed to ${temperature}¬∞C`);
    }
}
```

---

## Principios Relacionados con SOLID

### Principio DRY (Don't Repeat Yourself)
```typescript
// ‚ùå Violaci√≥n DRY
class UserValidator {
    validateEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
}

class NewsletterValidator {
    validateEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
}

// ‚úÖ Aplicando DRY
class EmailValidator {
    static validate(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
}

class UserValidator {
    validateEmail(email: string): boolean {
        return EmailValidator.validate(email);
    }
}
```

### Principio KISS (Keep It Simple, Stupid)
```typescript
// ‚ùå Complejo innecesariamente
class ComplexCalculator {
    calculate(input: number[]): number {
        return input.reduce((acc, curr, idx, arr) => {
            const weighted = curr * (idx + 1);
            const normalized = weighted / arr.length;
            return acc + Math.pow(normalized, 2);
        }, 0);
    }
}

// ‚úÖ Simple y claro
class SimpleCalculator {
    calculateWeightedAverage(numbers: number[]): number {
        let total = 0;
        for (let i = 0; i < numbers.length; i++) {
            total += numbers[i] * (i + 1);
        }
        return total / numbers.length;
    }
}
```

### Ley de Demeter (Principio del Menor Conocimiento)
```typescript
// ‚ùå Violaci√≥n de la Ley de Demeter
class Customer {
    constructor(private wallet: Wallet) {}
    
    getWallet(): Wallet {
        return this.wallet;
    }
}

class Wallet {
    constructor(private money: number) {}
    
    getMoney(): number {
        return this.money;
    }
}

// Uso problem√°tico
const customer = new Customer(new Wallet(100));
const money = customer.getWallet().getMoney(); // ‚ùå Conoce demasiado

// ‚úÖ Cumpliendo la Ley de Demeter
class Customer {
    constructor(private wallet: Wallet) {}
    
    getAvailableMoney(): number {
        return this.wallet.getMoney();
    }
    
    makePayment(amount: number): boolean {
        return this.wallet.withdraw(amount);
    }
}

// Uso correcto
const money = customer.getAvailableMoney(); // ‚úÖ Solo conoce lo necesario
```

---

## Arquitectura Hexagonal (Puertos y Adaptadores)

### Estructura B√°sica
```typescript
// Domain Core (sin dependencias externas)
interface UserRepository {
    findById(id: string): Promise<User>;
    save(user: User): Promise<void>;
}

class User {
    constructor(
        public id: string,
        public name: string,
        public email: string
    ) {}
    
    changeEmail(newEmail: string): void {
        // L√≥gica de dominio
        this.email = newEmail;
    }
}

// Application Layer
class ChangeEmailUseCase {
    constructor(private userRepository: UserRepository) {}
    
    async execute(userId: string, newEmail: string): Promise<void> {
        const user = await this.userRepository.findById(userId);
        user.changeEmail(newEmail);
        await this.userRepository.save(user);
    }
}

// Infrastructure Layer (Adaptadores)
class MongoDBUserRepository implements UserRepository {
    async findById(id: string): Promise<User> {
        // Implementaci√≥n espec√≠fica de MongoDB
        return new User(id, "John", "john@example.com");
    }
    
    async save(user: User): Promise<void> {
        // Guardar en MongoDB
    }
}

class PostgreSQLUserRepository implements UserRepository {
    async findById(id: string): Promise<User> {
        // Implementaci√≥n espec√≠fica de PostgreSQL
        return new User(id, "John", "john@example.com");
    }
    
    async save(user: User): Promise<void> {
        // Guardar en PostgreSQL
    }
}
```

---

## Testing con SOLID

### Testabilidad Mejorada
```typescript
// Servicio f√°cil de testear gracias a DIP
class OrderService {
    constructor(
        private paymentProcessor: PaymentProcessor,
        private inventoryService: InventoryService,
        private notificationService: NotificationService
    ) {}
    
    async processOrder(order: Order): Promise<void> {
        // L√≥gica de negocio f√°cil de testear con mocks
    }
}

// Tests
describe('OrderService', () => {
    it('should process order successfully', async () => {
        const mockPaymentProcessor = {
            process: jest.fn().mockResolvedValue(true)
        };
        const mockInventory = {
            reserve: jest.fn().mockResolvedValue(true)
        };
        const mockNotification = {
            send: jest.fn()
        };
        
        const service = new OrderService(
            mockPaymentProcessor,
            mockInventory,
            mockNotification
        );
        
        await service.processOrder(testOrder);
        
        expect(mockPaymentProcessor.process).toHaveBeenCalled();
    });
});
```

---

## M√©tricas de Calidad de C√≥digo

### Indicadores de Buen Dise√±o

**Acoplamiento:**
- N√∫mero de dependencias por clase
- Profundidad del √°rbol de herencia
- Dependencias c√≠clicas

**Cohesi√≥n:**
- M√©todos relacionados trabajando juntos
- Responsabilidades bien definidas
- L√≥gica de negocio agrupada apropiadamente

**Complejidad:**
- Complejidad ciclom√°tica por m√©todo
- N√∫mero de par√°metros por m√©todo
- Longitud de m√©todos y clases

### Herramientas de An√°lisis
- **SonarQube**: An√°lisis est√°tico de c√≥digo
- **ESLint**: Reglas de calidad para JavaScript/TypeScript
- **Jest**: Coverage y m√©tricas de testing
- **Code Climate**: An√°lisis continuo de calidad

---

## Refactoring hacia SOLID

### T√©cnicas Comunes de Refactoring

**Extracci√≥n de Interfaces:**
```typescript
// Antes
class ReportGenerator {
    generatePDF(): void { /* ... */ }
    generateExcel(): void { /* ... */ }
    sendEmail(): void { /* ... */ }
}

// Despu√©s
interface ReportGenerator {
    generate(): void;
}

interface EmailSender {
    send(): void;
}
```

**Inversi√≥n de Dependencias:**
```typescript
// Antes
class UserService {
    private database = new MySQLDatabase();
}

// Despu√©s
class UserService {
    constructor(private database: Database) {}
}
```

**Composici√≥n sobre Herencia:**
```typescript
// Antes
class Bird {
    fly(): void { /* ... */ }
}

class Penguin extends Bird {
    fly(): void { throw new Error(); } // ‚ùå
}

// Despu√©s
class Bird {
    private flyingBehavior: FlyingBehavior;
    
    fly(): void {
        this.flyingBehavior.fly();
    }
}
```

# Arquitecturas que Implementan SOLID

## Clean Architecture

### Estructura de Capas
```typescript
// Domain Layer (Entidades y Reglas de Negocio)
interface User {
  id: string;
  name: string;
  email: string;
  isActive: boolean;
}

class Product {
  constructor(
    public id: string,
    public name: string,
    public price: number,
    public stock: number
  ) {}
  
  reduceStock(quantity: number): void {
    if (this.stock < quantity) {
      throw new Error('Insufficient stock');
    }
    this.stock -= quantity;
  }
}

// Application Layer (Casos de Uso)
interface OrderRepository {
  save(order: Order): Promise<void>;
  findById(id: string): Promise<Order>;
}

class CreateOrderUseCase {
  constructor(
    private orderRepository: OrderRepository,
    private productRepository: ProductRepository
  ) {}
  
  async execute(orderData: CreateOrderDTO): Promise<Order> {
    const product = await this.productRepository.findById(orderData.productId);
    product.reduceStock(orderData.quantity);
    
    const order = new Order(
      generateId(),
      orderData.customerId,
      product.id,
      orderData.quantity,
      product.price * orderData.quantity
    );
    
    await this.orderRepository.save(order);
    await this.productRepository.save(product);
    
    return order;
  }
}

// Infrastructure Layer (Implementaciones Concretas)
class MongoDBOrderRepository implements OrderRepository {
  async save(order: Order): Promise<void> {
    // Implementaci√≥n espec√≠fica de MongoDB
  }
  
  async findById(id: string): Promise<Order> {
    // Implementaci√≥n espec√≠fica de MongoDB
  }
}

// Presentation Layer (Controllers)
class OrderController {
  constructor(private createOrderUseCase: CreateOrderUseCase) {}
  
  async createOrder(req: Request, res: Response): Promise<void> {
    try {
      const order = await this.createOrderUseCase.execute(req.body);
      res.status(201).json(order);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
}
```

---

## Domain-Driven Design (DDD) con SOLID

### Agregados y Entidades
```typescript
// Aggregate Root
class Order {
  private items: OrderItem[] = [];
  private status: OrderStatus = 'pending';
  
  constructor(
    public readonly id: string,
    public readonly customerId: string,
    private total: number
  ) {}
  
  addItem(productId: string, quantity: number, price: number): void {
    const existingItem = this.items.find(item => item.productId === productId);
    
    if (existingItem) {
      existingItem.increaseQuantity(quantity);
    } else {
      this.items.push(new OrderItem(productId, quantity, price));
    }
    
    this.calculateTotal();
  }
  
  private calculateTotal(): void {
    this.total = this.items.reduce(
      (sum, item) => sum + item.getTotal(), 
      0
    );
  }
  
  complete(): void {
    if (this.items.length === 0) {
      throw new Error('Cannot complete empty order');
    }
    this.status = 'completed';
  }
  
  // Solo expone lo necesario (ISP)
  getItems(): ReadonlyArray<OrderItem> {
    return [...this.items];
  }
  
  getTotal(): number {
    return this.total;
  }
}

// Value Object
class Money {
  constructor(
    public readonly amount: number,
    public readonly currency: string = 'USD'
  ) {
    if (amount < 0) {
      throw new Error('Money amount cannot be negative');
    }
  }
  
  add(other: Money): Money {
    if (this.currency !== other.currency) {
      throw new Error('Cannot add different currencies');
    }
    return new Money(this.amount + other.amount, this.currency);
  }
}

// Domain Service
class OrderPricingService {
  calculateDiscount(order: Order, customer: Customer): Money {
    if (customer.isPremium() && order.getTotal() > 100) {
      return new Money(order.getTotal() * 0.1);
    }
    return new Money(0);
  }
}
```

---

## Event-Driven Architecture

### Patr√≥n Domain Events
```typescript
interface DomainEvent {
  readonly occurredOn: Date;
  readonly eventType: string;
}

class OrderCreatedEvent implements DomainEvent {
  public readonly occurredOn: Date = new Date();
  public readonly eventType: string = 'order.created';
  
  constructor(
    public readonly orderId: string,
    public readonly customerId: string,
    public readonly total: number
  ) {}
}

class OrderShippedEvent implements DomainEvent {
  public readonly occurredOn: Date = new Date();
  public readonly eventType: string = 'order.shipped';
  
  constructor(
    public readonly orderId: string,
    public readonly shippingDate: Date
  ) {}
}

// Event Handler
interface EventHandler<T extends DomainEvent> {
  handle(event: T): Promise<void>;
}

class OrderCreatedEventHandler implements EventHandler<OrderCreatedEvent> {
  constructor(
    private emailService: EmailService,
    private inventoryService: InventoryService
  ) {}
  
  async handle(event: OrderCreatedEvent): Promise<void> {
    await this.emailService.sendOrderConfirmation(event.orderId);
    await this.inventoryService.reserveItems(event.orderId);
  }
}

// Event Publisher
class DomainEventPublisher {
  private handlers: Map<string, EventHandler<DomainEvent>[]> = new Map();
  
  subscribe(eventType: string, handler: EventHandler<DomainEvent>): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler);
  }
  
  async publish(event: DomainEvent): Promise<void> {
    const eventHandlers = this.handlers.get(event.eventType) || [];
    
    await Promise.all(
      eventHandlers.map(handler => handler.handle(event))
    );
  }
}
```

---

## CQRS (Command Query Responsibility Segregation)

### Separaci√≥n de Lectura y Escritura
```typescript
// Commands (Write Side)
interface Command {
  readonly commandType: string;
}

class CreateUserCommand implements Command {
  public readonly commandType: string = 'user.create';
  
  constructor(
    public readonly userId: string,
    public readonly name: string,
    public readonly email: string
  ) {}
}

class UpdateUserEmailCommand implements Command {
  public readonly commandType: string = 'user.update.email';
  
  constructor(
    public readonly userId: string,
    public readonly newEmail: string
  ) {}
}

// Command Handlers
interface CommandHandler<T extends Command> {
  handle(command: T): Promise<void>;
}

class CreateUserCommandHandler implements CommandHandler<CreateUserCommand> {
  constructor(private userRepository: UserRepository) {}
  
  async handle(command: CreateUserCommand): Promise<void> {
    const user = new User(command.userId, command.name, command.email);
    await this.userRepository.save(user);
    
    // Publicar evento de dominio
    await eventPublisher.publish(new UserCreatedEvent(command.userId));
  }
}

// Queries (Read Side)
interface Query {
  readonly queryType: string;
}

class GetUserByIdQuery implements Query {
  public readonly queryType: string = 'user.get.byId';
  
  constructor(public readonly userId: string) {}
}

class GetUsersByCriteriaQuery implements Query {
  public readonly queryType: string = 'user.get.byCriteria';
  
  constructor(
    public readonly filters: UserFilters,
    public readonly page: number,
    public readonly limit: number
  ) {}
}

// Query Handlers
interface QueryHandler<T extends Query, R> {
  handle(query: T): Promise<R>;
}

class GetUserByIdQueryHandler implements QueryHandler<GetUserByIdQuery, UserDTO> {
  constructor(private userReadRepository: UserReadRepository) {}
  
  async handle(query: GetUserByIdQuery): Promise<UserDTO> {
    return await this.userReadRepository.findById(query.userId);
  }
}
```

---

## Microservicios y SOLID

### Comunicaci√≥n entre Servicios
```typescript
// Service Discovery Interface
interface ServiceDiscovery {
  getServiceUrl(serviceName: string): Promise<string>;
  registerService(serviceName: string, url: string): Promise<void>;
}

// Circuit Breaker Pattern
class CircuitBreaker {
  private failures: number = 0;
  private lastFailure: Date | null = null;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  constructor(
    private failureThreshold: number = 5,
    private timeout: number = 30000
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (this.isTimeoutExpired()) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failures = 0;
    this.state = 'closed';
  }
  
  private onFailure(): void {
    this.failures++;
    this.lastFailure = new Date();
    
    if (this.failures >= this.failureThreshold) {
      this.state = 'open';
    }
  }
}

// Service Client con Circuit Breaker
class UserServiceClient {
  constructor(
    private httpClient: HttpClient,
    private circuitBreaker: CircuitBreaker,
    private serviceDiscovery: ServiceDiscovery
  ) {}
  
  async getUser(userId: string): Promise<User> {
    return this.circuitBreaker.execute(async () => {
      const serviceUrl = await this.serviceDiscovery.getServiceUrl('user-service');
      const response = await this.httpClient.get(`${serviceUrl}/users/${userId}`);
      return response.data;
    });
  }
}
```

---

## Containerization y SOLID

### Dependency Injection Container
```typescript
interface ServiceConstructor<T> {
  new(...args: any[]): T;
}

type ServiceIdentifier = string | symbol | ServiceConstructor<any>;

class Container {
  private services: Map<ServiceIdentifier, any> = new Map();
  private factories: Map<ServiceIdentifier, Function> = new Map();
  private singletons: Map<ServiceIdentifier, any> = new Map();
  
  register<T>(
    identifier: ServiceIdentifier,
    constructor: ServiceConstructor<T>,
    dependencies: ServiceIdentifier[] = []
  ): void {
    this.factories.set(identifier, (container: Container) => {
      const args = dependencies.map(dep => container.get(dep));
      return new constructor(...args);
    });
  }
  
  registerSingleton<T>(
    identifier: ServiceIdentifier,
    constructor: ServiceConstructor<T>,
    dependencies: ServiceIdentifier[] = []
  ): void {
    this.factories.set(identifier, (container: Container) => {
      if (this.singletons.has(identifier)) {
        return this.singletons.get(identifier);
      }
      
      const args = dependencies.map(dep => container.get(dep));
      const instance = new constructor(...args);
      this.singletons.set(identifier, instance);
      return instance;
    });
  }
  
  get<T>(identifier: ServiceIdentifier): T {
    if (this.services.has(identifier)) {
      return this.services.get(identifier);
    }
    
    if (this.factories.has(identifier)) {
      const factory = this.factories.get(identifier)!;
      const instance = factory(this);
      this.services.set(identifier, instance);
      return instance;
    }
    
    throw new Error(`Service ${String(identifier)} not found`);
  }
}

// Uso del Container
const container = new Container();

// Registro de dependencias
container.registerSingleton('Database', MySQLDatabase, []);
container.register('UserRepository', MongoDBUserRepository, ['Database']);
container.register('EmailService', SendGridEmailService, []);
container.register('UserService', UserService, ['UserRepository', 'EmailService']);

// Resoluci√≥n
const userService = container.get<UserService>('UserService');
```

---

## Performance y SOLID

### Lazy Loading y Proxy Patterns
```typescript
// Virtual Proxy para Lazy Loading
interface Image {
  display(): void;
  getSize(): number;
}

class HighResolutionImage implements Image {
  constructor(private filename: string) {
    this.loadImageFromDisk();
  }
  
  private loadImageFromDisk(): void {
    console.log(`Loading high resolution image: ${this.filename}`);
    // Simular carga pesada
  }
  
  display(): void {
    console.log(`Displaying high resolution image: ${this.filename}`);
  }
  
  getSize(): number {
    return 5000; // Tama√±o en KB
  }
}

class ImageProxy implements Image {
  private realImage: HighResolutionImage | null = null;
  
  constructor(private filename: string) {}
  
  display(): void {
    if (this.realImage === null) {
      this.realImage = new HighResolutionImage(this.filename);
    }
    this.realImage.display();
  }
  
  getSize(): number {
    if (this.realImage === null) {
      return 100; // Tama√±o del proxy
    }
    return this.realImage.getSize();
  }
}

// Uso
const image1 = new ImageProxy('photo1.jpg'); // Carga r√°pida
const image2 = new ImageProxy('photo2.jpg'); // Carga r√°pida

console.log(image1.getSize()); // 100 KB (proxy)
image1.display(); // Carga y muestra la imagen real
console.log(image1.getSize()); // 5000 KB (imagen real)
```

---

## Monitoring y Observabilidad

### Structured Logging
```typescript
interface Logger {
  debug(message: string, context?: object): void;
  info(message: string, context?: object): void;
  warn(message: string, context?: object): void;
  error(message: string, error?: Error, context?: object): void;
}

class StructuredLogger implements Logger {
  constructor(private transport: LogTransport) {}
  
  info(message: string, context: object = {}): void {
    this.transport.send({
      level: 'info',
      message,
      timestamp: new Date().toISOString(),
      ...context
    });
  }
  
  error(message: string, error?: Error, context: object = {}): void {
    this.transport.send({
      level: 'error',
      message,
      timestamp: new Date().toISOString(),
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined,
      ...context
    });
  }
}

// Decorator para logging autom√°tico
function LogExecution(
  target: any,
  propertyName: string,
  descriptor: PropertyDescriptor
): PropertyDescriptor {
  const method = descriptor.value;
  
  descriptor.value = async function (...args: any[]) {
    const logger: Logger = (this as any).logger;
    const startTime = Date.now();
    
    logger.info(`Starting ${propertyName}`, { arguments: args });
    
    try {
      const result = await method.apply(this, args);
      const duration = Date.now() - startTime;
      
      logger.info(`Completed ${propertyName}`, {
        duration,
        result: result !== undefined ? 'success' : 'void'
      });
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      
      logger.error(`Failed ${propertyName}`, error, {
        duration,
        arguments: args
      });
      
      throw error;
    }
  };
  
  return descriptor;
}

// Uso del decorator
class OrderService {
  constructor(private logger: Logger) {}
  
  @LogExecution
  async processOrder(orderId: string): Promise<void> {
    // L√≥gica de procesamiento
  }
}
```

---

## Security y SOLID

### Principle of Least Privilege
```typescript
// Role-Based Access Control
interface Permission {
  resource: string;
  action: 'read' | 'write' | 'delete';
}

interface Role {
  name: string;
  permissions: Permission[];
}

class AuthorizationService {
  constructor(private userRoles: Map<string, Role[]>) {}
  
  hasPermission(userId: string, resource: string, action: string): boolean {
    const roles = this.userRoles.get(userId) || [];
    
    return roles.some(role =>
      role.permissions.some(permission =>
        permission.resource === resource &&
        permission.action === action
      )
    );
  }
}

// Security Context
class SecureService {
  constructor(
    private authorizationService: AuthorizationService,
    private userId: string
  ) {}
  
  async deleteOrder(orderId: string): Promise<void> {
    if (!this.authorizationService.hasPermission(this.userId, 'order', 'delete')) {
      throw new Error('Insufficient permissions');
    }
    
    // L√≥gica de eliminaci√≥n segura
  }
}
```

Estas arquitecturas y patrones avanzados muestran c√≥mo SOLID se integra en sistemas complejos, proporcionando bases s√≥lidas para el desarrollo de software escalable, mantenible y robusto.

# Arquitecturas y Patrones Avanzados con SOLID

## Clean Architecture

### Concepto Fundamental
Arquitectura que **separa las preocupaciones** en capas conc√©ntricas, donde las dependencias apuntan siempre hacia el centro (el dominio). El principio fundamental es la **independencia del framework** y las preocupaciones externas.

### Capas Principales

**Domain Layer** - Coraz√≥n del sistema:
- Contiene entidades y reglas de negocio puras
- Zero dependencias externas
- Ejemplo: `User`, `Order`, `Product` con l√≥gica de negocio

**Application Layer** - Orquesta el flujo:
- Contiene casos de uso
- Coordina entidades del dominio
- Define contratos para infraestructura

**Infrastructure Layer** - Implementaciones concretas:
- Bases de datos, APIs externas, frameworks
- Implementa interfaces definidas en capas internas
- Ejemplo: `MongoDBUserRepository`, `SendGridEmailService`

**Presentation Layer** - Punto de entrada:
- Controllers, GraphQL resolvers, CLI commands
- Transforma datos de entrada/salida

### Beneficios
- **Testabilidad**: El dominio se prueba sin infraestructura
- **Independencia**: Se pueden cambiar frameworks sin afectar negocio
- **Mantenibilidad**: Cada capa tiene responsabilidad clara

---

## Domain-Driven Design (DDD)

### Filosof√≠a Centrada en el Dominio
Metodolog√≠a que **alinea el software** con la realidad del negocio mediante modelado colaborativo entre expertos t√©cnicos y de dominio.

### Conceptos Clave

**Ubiquitous Language**:
- Lenguaje com√∫n en c√≥digo, documentaci√≥n y conversaciones
- Elimina traducciones entre t√©cnicos y negocio

**Bounded Contexts**:
- L√≠mites expl√≠citos donde un modelo tiene significado
- Ejemplo: "Cliente" en ventas vs "Usuario" en seguridad

**Aggregate Roots**:
- Entidades que garantizan consistencia del grupo
- Punto √∫nico de acceso para modificar el agregado
- Ejemplo: `Order` controla sus `OrderItems`

**Value Objects**:
- Objetos inmutables definidos por sus atributos
- Sin identidad propia
- Ejemplo: `Money`, `Address`, `Email`

**Domain Events**:
- Eventos significativos en el negocio
- Permiten reactividad y desacoplamiento
- Ejemplo: `OrderShippedEvent`, `PaymentReceivedEvent`

### Patrones Estrat√©gicos
- **Context Mapping**: Relaciones entre bounded contexts
- **Anti-Corruption Layer**: Protege un contexto de otro
- **Shared Kernel**: Modelo compartido entre contextos

---

## Event-Driven Architecture (EDA)

### Paradigma Basado en Eventos
Arquitectura donde los componentes se comunican mediante **eventos as√≠ncronos**, promoviendo el desacoplamiento y la escalabilidad.

### Componentes Principales

**Event Producers**:
- Generan eventos cuando ocurre algo significativo
- No conocen a los consumidores

**Event Consumers**:
- Reaccionan a eventos de inter√©s
- Procesan eventos de forma independiente

**Event Bus/Message Broker**:
- Canal que distribuye eventos
- Ejemplos: Kafka, RabbitMQ, AWS EventBridge

### Patrones Comunes

**Event Sourcing**:
- El estado se reconstruye aplicando eventos
- Ejemplo: `BankAccount` con historial de transacciones

**CQRS**:
- Separaci√≥n entre modelos de escritura y lectura
- Optimiza cada operaci√≥n por separado

**Saga Pattern**:
- Coordina transacciones largas entre servicios
- Compensa fallos con eventos de compensaci√≥n

### Ventajas
- **Desacoplamiento**: Productores y consumidores independientes
- **Escalabilidad**: Procesamiento paralelo de eventos
- **Resiliencia**: Los eventos pueden reprocesarse

---

## CQRS (Command Query Responsibility Segregation)

### Separaci√≥n Radical
Patr√≥n que **divide las operaciones** en dos categor√≠as: comandos (que cambian estado) y consultas (que leen estado).

### Lado de Comandos (Write)
- **Responsabilidad**: Cambiar el estado del sistema
- **Caracter√≠sticas**: Validaci√≥n estricta, l√≥gica de negocio compleja
- **Ejemplo**: `CreateUserCommand`, `UpdateOrderCommand`

### Lado de Consultas (Read)
- **Responsabilidad**: Leer y presentar datos
- **Caracter√≠sticas**: Optimizado para consultas, proyecciones simples
- **Ejemplo**: `GetUserQuery`, `SearchProductsQuery`

### Beneficios
- **Optimizaci√≥n Independiente**: Bases de datos separadas para lectura/escritura
- **Escalabilidad Selectiva**: Escalar seg√∫n el tipo de carga
- **Modelos Especializados**: Cada modelo hace una cosa bien

### Cu√°ndo Usarlo
- Sistemas con alta carga de lecturas vs escrituras
- Requerimientos complejos de reporting
- Necesidad de diferentes vistas de los mismos datos

---

## Microservicios

### Arquitectura de Servicios Independientes
Enfoque donde una aplicaci√≥n se compone de **servicios peque√±os y aut√≥nomos**, cada uno ejecut√°ndose en su propio proceso.

### Caracter√≠sticas Principales

**Autonom√≠a**:
- Cada servicio se despliega independientemente
- Base de datos propia (si es necesario)
- Equipos independientes por servicio

**Comunicaci√≥n**:
- APIs REST, gRPC, mensajer√≠a as√≠ncrona
- Contratos bien definidos entre servicios

**Resiliencia**:
- Circuit breakers para fallos en cascada
- Retry policies con backoff exponencial

### Patrones Esenciales

**Service Discovery**:
- Los servicios se encuentran din√°micamente
- Ejemplo: Consul, Eureka, Kubernetes Services

**API Gateway**:
- Punto √∫nico de entrada
- Enrutamiento, autenticaci√≥n, rate limiting

**Event Sourcing + CQRS**:
- Com√∫n en microservicios para consistencia eventual

### Ventajas y Desaf√≠os
- **Ventajas**: Escalabilidad independiente, deployment r√°pido, tolerancia a fallos
- **Desaf√≠os**: Complejidad operacional, debugging distribuido, consistencia de datos

---

## Containerization y Dependency Injection

### Contenedores como Unidad de Despliegue
Empaquetado de aplicaciones con **todas sus dependencias**, garantizando consistencia entre entornos.

### Dependency Injection (DI)
Patr√≥n que **invierte el control** de la creaci√≥n de dependencias, promoviendo el desacoplamiento.

**Container de DI**:
- Registra implementaciones y dependencias
- Resuelve el grafo de dependencias autom√°ticamente
- Maneja ciclos de vida (singleton, transient, scoped)

**Beneficios**:
- **Testabilidad**: F√°cil de mockear dependencias
- **Flexibilidad**: Cambiar implementaciones sin modificar c√≥digo
- **Mantenibilidad**: Dependencias expl√≠citas en el constructor

### Orchestration
- **Kubernetes**: Orquestaci√≥n de contenedores
- **Service Mesh**: Comunicaci√≥n entre servicios (Istio, Linkerd)
- **ConfigMaps y Secrets**: Gesti√≥n de configuraci√≥n

---

## Performance y Optimizaci√≥n

### Patrones de Mejora de Rendimiento

**Lazy Loading**:
- Carga de recursos solo cuando se necesitan
- Ejemplo: `ImageProxy` que carga im√°genes pesadas bajo demanda

**Caching Strategies**:
- Cache aside, write through, write behind
- Invalidation patterns

**Connection Pooling**:
- Reutilizaci√≥n de conexiones a base de datos
- Reduce overhead de establecimiento de conexi√≥n

### Monitoring y Observabilidad

**Three Pillars**:
- **Logs**: Eventos discretos con contexto
- **Metrics**: Medidas num√©ricas en el tiempo
- **Traces**: Seguimiento de requests a trav√©s de servicios

**Structured Logging**:
- Logs como datos, no solo texto
- Facilita b√∫squeda y agregaci√≥n

**Distributed Tracing**:
- Seguimiento de transacciones entre servicios
- Identifica cuellos de botella

---

## Security by Design

### Principios de Seguridad Integrada

**Principle of Least Privilege**:
- Usuarios y servicios tienen solo los permisos necesarios
- RBAC (Role-Based Access Control)

**Defense in Depth**:
- M√∫ltiples capas de seguridad
- Validaci√≥n en cada nivel

**Secure Defaults**:
- Configuraci√≥n segura por defecto
- Requiere acci√≥n expl√≠cita para reducir seguridad

### Patrones de Seguridad

**Zero Trust Architecture**:
- Nunca confiar, siempre verificar
- Micro-segmentaci√≥n de red

**Token-based Authentication**:
- JWT, OAuth2, OpenID Connect
- Stateless authentication

**API Security**:
- Rate limiting, input validation, output encoding
- Security headers (CORS, CSP)

---

## Refactoring hacia Arquitecturas S√≥lidas

### Estrategias de Migraci√≥n

**Strangler Fig Pattern**:
- Reemplazo gradual de legacy systems
- Nuevas funcionalidades en nueva arquitectura
- Eventual retiro del sistema legacy

**Branch by Abstraction**:
- Introducir abstracci√≥n sobre implementaci√≥n existente
- Cambiar implementaci√≥n detr√°s de la abstracci√≥n
- Eliminar implementaci√≥n antigua

### M√©tricas de √âxito

**Code Quality**:
- Complejidad ciclom√°tica reducida
- Cohesi√≥n alta, acoplamiento bajo
- Coverage de tests aumentado

**Business Metrics**:
- Time to market mejorado
- Defect rate reducido
- Team velocity consistente

Estas arquitecturas y patrones representan la evoluci√≥n natural de SOLID hacia sistemas empresariales complejos, manteniendo los principios fundamentales de dise√±o orientado a objetos mientras se adaptan a las demandas modernas de escalabilidad, resiliencia y mantenibilidad.

# Patrones de Dise√±o Fundamentales

## Patrones Creacionales

### Factory Method
Patr√≥n que define una interfaz para crear objetos, pero permite a las subclases decidir qu√© clase instanciar. Promueve el **acoplamiento d√©bil** entre el creador y los productos concretos.

**Aplicaci√≥n**: Cuando una clase no puede anticipar el tipo de objetos que debe crear, o cuando las subclases quieren especificar los objetos que crean.

**Ejemplo**: `DocumentCreator` con `ResumeCreator` y `ReportCreator` que producen diferentes tipos de documentos.

### Abstract Factory
Proporciona una interfaz para crear familias de objetos relacionados sin especificar sus clases concretas. Ideal para **sistemas que deben ser independientes** de c√≥mo se crean, componen y representan sus productos.

**Aplicaci√≥n**: Interfaces de usuario multiplataforma donde cada plataforma tiene su propia familia de controles.

### Builder
Separa la construcci√≥n de un objeto complejo de su representaci√≥n, permitiendo el mismo proceso de construcci√≥n crear diferentes representaciones. Resuelve el **problema del constructor telesc√≥pico**.

**Aplicaci√≥n**: Construcci√≥n de objetos complejos paso a paso, como consultas SQL o objetos de configuraci√≥n.

### Singleton
Garantiza que una clase tenga solo una instancia y proporciona un punto de acceso global a ella. √ötil para **recursos compartidos** como conexiones a bases de datos o configuraciones.

**Aplicaci√≥n**: Logger global, cache compartida, configuraci√≥n del sistema.

### Prototype
Crea nuevos objetos copiando un prototipo existente. Evita la creaci√≥n de subclases para instanciar objetos y permite **a√±adir o quitar objetos en tiempo de ejecuci√≥n**.

**Aplicaci√≥n**: Cuando el coste de crear un objeto es mayor que copiarlo, o cuando el sistema necesita ser independiente de c√≥mo se crean y representan los productos.

---

## Patrones Estructurales

### Adapter
Permite que interfaces incompatibles trabajen juntas. Act√∫a como **puente entre dos interfaces** diferentes, haciendo que parezcan compatibles.

**Aplicaci√≥n**: Integraci√≥n de librer√≠as legacy, adaptaci√≥n de APIs externas a interfaces internas.

### Bridge
Separa una abstracci√≥n de su implementaci√≥n, permitiendo que ambas var√≠en independientemente. Evita la **explosi√≥n de clases** en herencias multidimensionales.

**Aplicaci√≥n**: Controladores de dispositivos donde la abstracci√≥n (control remoto) se separa de la implementaci√≥n (dispositivo).

### Composite
Permite tratar objetos individuales y composiciones de objetos de manera uniforme. Crea **estructuras en √°rbol** donde los nodos hoja y compuestos se tratan igual.

**Aplicaci√≥n**: Sistemas de archivos, interfaces gr√°ficas con contenedores y elementos.

### Decorator
A√±ade responsabilidades adicionales a un objeto de forma din√°mica. Proporciona una **alternativa flexible a la herencia** para extender funcionalidad.

**Aplicaci√≥n**: Streams de Java, middleware en aplicaciones web, a√±adir funcionalidades a objetos existentes.

### Facade
Proporciona una interfaz simplificada a un subsistema complejo. Oculta la **complejidad del subsistema** y facilita su uso.

**Aplicaci√≥n**: APIs simplificadas para sistemas complejos, wrappers para librer√≠as complicadas.

### Flyweight
Utiliza el compartimiento para soportar eficientemente grandes cantidades de objetos de grano fino. Reduce el **uso de memoria** compartiendo partes comunes del estado.

**Aplicaci√≥n**: Editores de texto que comparten caracteres, juegos con muchos objetos similares.

### Proxy
Proporciona un sustituto o marcador de posici√≥n para otro objeto para controlar el acceso a √©l. √ötil para **acceso lazy**, control de acceso o logging.

**Aplicaci√≥n**: Virtual proxy para im√°genes pesadas, protection proxy para control de acceso, remote proxy para objetos distribuidos.

---

## Patrones de Comportamiento

### Chain of Responsibility
Permite que m√°s de un objeto maneje una solicitud, pas√°ndola a lo largo de una cadena hasta que es manejada. **Desacopla el emisor y el receptor**.

**Aplicaci√≥n**: Sistemas de ayuda contextual, procesamiento de eventos, middleware en aplicaciones web.

### Command
Encapsula una solicitud como un objeto, permitiendo parametrizar clientes con diferentes solicitudes, hacer cola o registrar solicitudes. Soporta **operaciones deshacer**.

**Aplicaci√≥n**: Sistemas de men√∫s, operaciones de deshacer/rehacer, jobs en cola.

### Interpreter
Define una representaci√≥n gramatical para un lenguaje y un int√©rprete que usa la representaci√≥n para interpretar sentencias del lenguaje. Para **lenguajes simples**.

**Aplicaci√≥n**: Expresiones regulares, consultas de bases de datos simples, calculadoras.

### Iterator
Proporciona una forma de acceder secuencialmente a los elementos de una agregaci√≥n sin exponer su representaci√≥n subyacente. **Separa el recorrido de la estructura**.

**Aplicaci√≥n**: Colecciones en lenguajes de programaci√≥n, recorrido de estructuras de datos complejas.

### Mediator
Define un objeto que encapsula c√≥mo un conjunto de objetos interact√∫a. Promueve el **acoplamiento d√©bil** al evitar que los objetos se refieran entre s√≠ expl√≠citamente.

**Aplicaci√≥n**: Controladores en MVC, sistemas de chat donde el mediator maneja la comunicaci√≥n.

### Memento
Captura y externaliza el estado interno de un objeto sin violar la encapsulaci√≥n, para que el objeto pueda ser restaurado a este estado m√°s tarde. Para **implementar deshacer**.

**Aplicaci√≥n**: Editores de texto, herramientas de dise√±o, juegos con guardado de estado.

### Observer
Define una dependencia uno-a-muchos entre objetos, de modo que cuando un objeto cambia estado, todos sus dependientes son notificados autom√°ticamente. Para **eventos y notificaciones**.

**Aplicaci√≥n**: Sistemas de eventos en interfaces gr√°ficas, notificaciones en tiempo real.

### State
Permite a un objeto alterar su comportamiento cuando su estado interno cambia. Parecer√° que el objeto **cambi√≥ su clase**.

**Aplicaci√≥n**: M√°quinas de estado finito, reproductores multimedia, procesadores de pedidos.

### Strategy
Define una familia de algoritmos, encapsula cada uno y los hace intercambiables. Permite que el **algoritmo var√≠e independientemente** de los clientes que lo usan.

**Aplicaci√≥n**: Algoritmos de ordenaci√≥n, estrategias de compresi√≥n, m√©todos de pago.

### Template Method
Define el esqueleto de un algoritmo en una operaci√≥n, delegando algunos pasos a las subclases. Permite a las subclases **redefinir ciertos pasos** sin cambiar la estructura del algoritmo.

**Aplicaci√≥n**: Frameworks que definen flujos de trabajo, procesamiento de datos con pasos variables.

### Visitor
Representa una operaci√≥n a realizar en los elementos de una estructura de objetos. Permite definir **nuevas operaciones sin cambiar** las clases de los elementos.

**Aplicaci√≥n**: Compiladores que realizan diferentes an√°lisis sobre AST, herramientas de reporting sobre estructuras complejas.

---

## Relaci√≥n con Principios SOLID

### SRP y Patrones
- **Factory Method**: Separa la creaci√≥n de objetos de su uso
- **Strategy**: Separa algoritmos en clases independientes
- **Command**: Separa la invocaci√≥n de la ejecuci√≥n

### OCP y Patrones
- **Strategy**: F√°cil a√±adir nuevos algoritmos
- **Decorator**: Extender funcionalidad sin modificar
- **Observer**: A√±adir observadores sin cambiar el sujeto

### LSP y Patrones
- **Composite**: Todos los componentes siguen la misma interfaz
- **Strategy**: Las estrategias son intercambiables
- **State**: Los estados son sustituibles

### ISP y Patrones
- **Adapter**: Crea interfaces espec√≠ficas para clientes
- **Facade**: Proporciona interfaces simplificadas
- **Proxy**: Expone solo la funcionalidad necesaria

### DIP y Patrones
- **Dependency Injection**: Implementaci√≥n directa de DIP
- **Abstract Factory**: Depende de abstracciones para creaci√≥n
- **Template Method**: Las subclases dependen de abstracciones

---

## Patrones en Arquitecturas Modernas

### Microservicios
- **API Gateway**: Facade para microservicios
- **Circuit Breaker**: Proxy para control de fallos
- **Service Discovery**: Abstract factory para localizaci√≥n

### Event-Driven
- **Event Sourcing**: Memento para estado del sistema
- **CQRS**: Strategy para lectura vs escritura
- **Saga**: Mediator para transacciones distribuidas

### Domain-Driven Design
- **Repository**: Abstract factory para agregados
- **Specification**: Strategy para criterios de negocio
- **Domain Events**: Observer para eventos de dominio

---

## Anti-patrones Comunes

### Singleton Abuse
- Problema: Dependencias ocultas, dif√≠cil de testear
- Soluci√≥n: Dependency Injection, limitar uso a casos genuinos

### God Object
- Problema: Clase que hace demasiado, viola SRP
- Soluci√≥n: Dividir usando Strategy, Factory, Facade

### Anemic Domain Model
- Problema: Objetos solo con datos, sin comportamiento
- Soluci√≥n: Mover l√≥gica a entidades usando State, Strategy

### Callback Hell
- Problema: Callbacks anidados, c√≥digo dif√≠cil de leer
- Soluci√≥n: Usar Promise/Async, Chain of Responsibility

Los patrones de dise√±o son herramientas que materializan los principios SOLID en soluciones concretas y reutilizables para problemas comunes de dise√±o de software.

# Arquitecturas y Patrones de Resiliencia y Escalabilidad

## Circuit Breaker Pattern

### Concepto y Mecanismos
Patr√≥n que previene fallos en cascada al detectar problemas en servicios dependientes. Funciona como un interruptor el√©ctrico que "abre" cuando detecta demasiados fallos.

**Estados del Circuit Breaker**:
- **Closed**: Operaci√≥n normal, las solicitudes pasan directamente
- **Open**: Solicitudes rechazadas inmediatamente sin llamar al servicio
- **Half-Open**: Permite solicitudes limitadas para probar recuperaci√≥n

**Umbrales de Configuraci√≥n**:
- Failure threshold percentage
- Timeout duration
- Number of calls in half-open state
- Wait duration in open state

### Estrategias de Recuperaci√≥n
- **Exponential Backoff**: Reintentos con intervalos crecientes
- **Fallback Responses**: Respuestas alternativas cuando el servicio est√° ca√≠do
- **Bulkhead Isolation**: Separaci√≥n de recursos para evitar contagio

---

## Bulkhead Pattern

### Aislamiento de Recursos
Patr√≥n que divide los recursos del sistema en grupos aislados para contener fallos y prevenir la propagaci√≥n de problemas.

**Tipos de Bulkheading**:

**Thread Pool Isolation**:
- Grupos separados de hilos para diferentes servicios
- Evita que un servicio lento consuma todos los recursos

**Connection Pool Isolation**:
- Pools de conexi√≥n separados por servicio
- Protege contra saturaciones de conexiones

**Resource Partitioning**:
- CPU, memoria y almacenamiento dedicados
- Aislamiento a nivel de infraestructura

### Implementaci√≥n en Microservicios
- L√≠mites de recursos por contenedor
- Queue separation para mensajes
- Database connection partitioning

---

## Retry Pattern

### Mecanismos de Reintento Inteligente
Estrategia para manejar fallos temporales mediante reintentos autom√°ticos con pol√≠ticas espec√≠ficas.

**Pol√≠ticas Comunes**:

**Fixed Interval**:
- Reintentos a intervalos constantes
- Simple pero puede causar congesti√≥n

**Exponential Backoff**:
- Intervalos que crecen exponencialmente
- Da tiempo al servicio para recuperarse

**Jitter**:
- Variaci√≥n aleatoria en los intervalos
- Evita el "herd effect" en sistemas distribuidos

**Circuit Breaker Integration**:
- Detiene reintentos si el circuito est√° abierto
- Combinaci√≥n con fallback mechanisms

---

## Timeout Pattern

### Gesti√≥n de L√≠mites Temporales
Establecimiento de tiempos m√°ximos de espera para operaciones, previniendo bloqueos indefinidos.

**Tipos de Timeouts**:

**Connection Timeout**:
- Tiempo m√°ximo para establecer conexi√≥n
- Previene esperas en conexiones lentas

**Read Timeout**:
- Tiempo m√°ximo para recibir respuesta
- Maneja servicios que responden lentamente

**Global Timeout**:
- Tiempo m√°ximo para operaci√≥n completa
- Incluye todos los pasos y reintentos

**Propagaci√≥n en Sistemas Distribuidos**:
- Header propagation entre servicios
- Deadline-based timeout management
- Context cancellation en llamadas anidadas

---

## Cache-Aside Pattern

### Estrategia de Caching Desacoplado
Patr√≥n donde la aplicaci√≥n es responsable de leer y escribir en la cache, manteni√©ndola sincronizada con el almacenamiento principal.

**Flujo de Operaciones**:

**Lectura**:
1. Buscar en cache primero
2. Si no existe (cache miss), leer de base de datos
3. Escribir en cache para futuras lecturas
4. Retornar datos

**Escritura**:
1. Escribir en base de datos
2. Invalidar entrada en cache
3. O escribir-through para mantener consistencia

**Estrategias de Invalidation**:
- **Time-based**: Expiraci√≥n despu√©s de tiempo fijo
- **Event-based**: Invalidaci√≥n por cambios de datos
- **Manual**: Invalidaci√≥n expl√≠cita por aplicaci√≥n

---

## Event Sourcing

### Almacenamiento Basado en Eventos
Patr√≥n donde el estado de la aplicaci√≥n se determina mediante una secuencia de eventos, en lugar de almacenar solo el estado actual.

**Componentes Principales**:

**Event Store**:
- Base de datos optimizada para eventos
- Append-only, inmutable
- Mantiene orden y consistencia

**Event Stream**:
- Secuencia ordenada de eventos para una entidad
- Identificado por aggregate ID

**Projections**:
- Vistas materializadas del estado actual
- Reconstruidas aplicando eventos
- Optimizadas para consultas espec√≠ficas

**Snapshots**:
- Puntos de estado guardados peri√≥dicamente
- Reducen tiempo de reconstrucci√≥n
- Para streams muy largos

### Beneficios en Sistemas Distribuidos
- **Audit Trail**: Historial completo de cambios
- **Temporal Queries**: Estado en cualquier punto del tiempo
- **Event Replay**: Reprocesamiento para corregir bugs
- **Multi-Projection**: Diferentes vistas del mismo evento stream

---

## Saga Pattern

### Gesti√≥n de Transacciones Distribuidas
Patr√≥n para mantener la consistencia de datos a trav√©s de m√∫ltiples servicios sin usar transacciones distribuidas ACID.

**Tipos de Saga**:

**Orchestration-Based**:
- Coordinador central orquesta los pasos
- Conoce el flujo completo de la transacci√≥n
- M√°s control pero m√°s acoplamiento

**Choreography-Based**:
- Cada servicio publica eventos
- Los servicios reaccionan a eventos relevantes
- Menos acoplamiento pero m√°s complejidad de seguimiento

**Patrones de Compensaci√≥n**:
- **Compensating Transactions**: Operaciones inversas
- **Retry Logic**: Reintento de pasos fallidos
- **Pause and Resume**: Continuaci√≥n desde punto de fallo

### Estrategias de Recovery
- **Manual Intervention**: Para casos complejos no automatizables
- **Automated Compensation**: Rollback autom√°tico de pasos completados
- **Forward Recovery**: Completar la transacci√≥n por caminos alternativos

---

## API Gateway Pattern

### Punto √önico de Entrada
Patr√≥n que proporciona un √∫nico endpoint para clientes, abstraiendo la complejidad de los microservicios backend.

**Funcionalidades Clave**:

**Routing y Composition**:
- Enrutamiento inteligente a servicios
- Aggregation de datos de m√∫ltiples servicios
- Response transformation

**Cross-Cutting Concerns**:
- **Authentication y Authorization**
- **Rate Limiting y Throttling**
- **Caching** de respuestas
- **Logging y Monitoring**

**Resilience Features**:
- Circuit breaker para servicios backend
- Timeout management
- Fallback responses

**Service Mesh Integration**:
- Comunicaci√≥n sidecar-to-sidecar
- Service discovery din√°mico
- Load balancing inteligente

---

## Sidecar Pattern

### Acompa√±ante de Aplicaciones
Patr√≥n donde componentes auxiliares se ejecutan en procesos separados pero junto a la aplicaci√≥n principal.

**Casos de Uso Comunes**:

**Infrastructure Concerns**:
- Service discovery registration
- Health checking
- Configuration management

**Observability**:
- Metrics collection
- Distributed tracing
- Log aggregation

**Networking**:
- Proxy para comunicaciones
- TLS termination
- Protocol translation

**Service Mesh Implementation**:
- Envoy, Linkerd, Istio
- Traffic management policies
- Security policies enforcement

---

## Strangler Fig Pattern

### Migraci√≥n Gradual de Sistemas
Patr√≥n para reemplazar sistemas legacy incrementalmente, creando nuevo sistema alrededor del existente.

**Fases de Implementaci√≥n**:

**Phase 1: Transform**:
- Crear facade sobre sistema legacy
- Reroute algunas solicitudes
- Mantener coexistencia

**Phase 2: Coexist**:
- Ambas implementaciones activas
- Feature toggle entre versiones
- Data synchronization

**Phase 3: Eliminate**:
- Retirar c√≥digo legacy
- Eliminar rutas antiguas
- Completar migraci√≥n

**Estrategias de Ruteo**:
- **URL-based**: Diferentes endpoints para nuevo vs legacy
- **Feature-based**: Toggle por funcionalidad
- **User-based**: Grupos de usuarios migrados progresivamente

---

## Backends for Frontends (BFF)

### APIs Especializadas por Cliente
Patr√≥n donde se crean backends espec√≠ficos para cada tipo de cliente frontend.

**Beneficios por Plataforma**:

**Mobile BFF**:
- Data aggregation optimizada para m√≥vil
- Protocolos eficientes en ancho de banda
- Offline-first considerations

**Web BFF**:
- Server-side rendering support
- SEO optimization
- Rich interaction patterns

**IoT BFF**:
- Protocol translation
- Batch processing
- Real-time communication

**Caracter√≠sticas Comunes**:
- Client-specific data transformation
- Optimized payloads
- Platform-aware error handling
- Custom authentication flows

---

## Health Check Pattern

### Monitoreo de Estado de Servicios
Mecanismo para verificar continuamente la salud de los componentes del sistema.

**Tipos de Health Checks**:

**Liveness Probe**:
- Indica si la aplicaci√≥n est√° ejecut√°ndose
- Failure resulta en restart del contenedor
- Checks b√°sicos de proceso

**Readiness Probe**:
- Indica si la aplicaci√≥n est√° lista para recibir tr√°fico
- Failure resulta en removal del load balancer
- Checks de dependencias

**Startup Probe**:
- Para aplicaciones con largo tiempo de inicio
- Previene kills prematuros
- Deshabilitado despu√©s del primer √©xito

**Composite Health Checks**:
- Database connectivity verification
- External service availability
- Resource utilization monitoring
- Business logic health indicators

---

## Feature Toggle Pattern

### Desarrollo y Release Controlados
Mecanismo para alternar funcionalidades sin desplegar nuevo c√≥digo.

**Tipos de Feature Toggles**:

**Release Toggles**:
- Controlan features incompletas
- Vida corta, removidos despu√©s del release
- Para trunk-based development

**Experiment Toggles**:
- A/B testing y canary releases
- Basados en porcentaje de usuarios
- Colectan m√©tricas de performance

**Ops Toggles**:
- Control operacional de features
- Para degradaci√≥n graceful bajo carga
- Kill switches para features problem√°ticas

**Permission Toggles**:
- Acceso basado en roles o permisos
- Beta features para usuarios espec√≠ficos
- License-based feature control

**Management Strategies**:
- Centralized configuration service
- Runtime changes without redeployment
- Audit trail for toggle changes
- Automated cleanup of technical debt

Estos patrones de resiliencia y escalabilidad complementan los principios SOLID proporcionando mecanismos pr√°cticos para construir sistemas distribuidos robustos, mantenibles y capaces de manejar fallos de manera elegante.

# Patrones de Data y Arquitecturas Especializadas

## Data Mesh Architecture

### Paradigma de Data como Producto
Arquitectura descentralizada que trata los datos como productos, con equipos de dominio como due√±os.

**Principios Fundamentales**:

**Domain Ownership**:
- Los equipos de negocio son due√±os de sus datos
- Responsabilidad end-to-end de calidad y disponibilidad
- Data products con SLAs definidos

**Data as a Product**:
- Documentaci√≥n autom√°tica
- Contracts de calidad de datos
- Self-service discovery

**Self-Serve Data Platform**:
- Infraestructura compartida para data products
- Standardized tooling
- Federated computational governance

**Federated Governance**:
- Pol√≠ticas globales con implementaci√≥n local
- Compliance automatizado
- Quality standards enforcement

---

## CQRS con Event Sourcing

### Combinaci√≥n de Patrones
Integraci√≥n de Command Query Responsibility Segregation con Event Sourcing para sistemas de alta consistencia.

**Arquitectura H√≠brida**:

**Write Side**:
- Commands validados y aplicados
- Events almacenados en event store
- Projections actualizan read models

**Read Side**:
- Optimizado para consultas espec√≠ficas
- Multiple read models para diferentes necesidades
- Cache strategies agresivas

**Synchronization Mechanisms**:
- Event handlers as√≠ncronos
- Conflict resolution strategies
- Eventually consistency patterns

**Benefits para Business Logic**:
- Complete audit trail
- Temporal queries
- Business intelligence integration
- Compliance and regulatory requirements

---

## Hexagonal Architecture con DDD

### Arquitectura de Puertos y Adaptadores
Combinaci√≥n de principios hexagonales con Domain-Driven Design para m√°xima separaci√≥n de concerns.

**Core Domain Layer**:
- Entities ricas en comportamiento
- Value objects inmutables
- Domain services para l√≥gica transversal

**Application Layer**:
- Use cases como orquestadores
- Transaction management
- Domain event publishing

**Infrastructure Layer**:
- Repository implementations
- External service adapters
- Framework-specific code

**Ports**:
- Input ports para use cases
- Output ports para repositories
- Event listeners para domain events

---

## Microfrontends Architecture

### Extensi√≥n de Microservicios al Frontend
Arquitectura que aplica principios de microservicios al desarrollo de interfaces de usuario.

**Approaches de Implementaci√≥n**:

**Build-time Integration**:
- Package-based microfrontends
- NPM modules como building blocks
- Shared dependency management

**Run-time Integration**:
- Web Components como contenedores
- Module Federation en Webpack
- Dynamic script loading

**Server-side Integration**:
- Edge-side includes (ESI)
- Server-side composition
- Fragment-based assembly

**Cross-cutting Concerns**:
- Shared design systems
- Consistent user experience
- Cross-application state management
- Unified authentication flows

---

## Serverless Patterns

### Arquitecturas sin Servidor
Patrones dise√±ados espec√≠ficamente para entornos serverless como AWS Lambda, Azure Functions.

**Event-driven Patterns**:

**Event Processing**:
- Stream processing con Kinesis/Lambda
- Batch processing con S3 triggers
- Real-time data transformation

**API Backends**:
- REST APIs con API Gateway + Lambda
- GraphQL resolvers serverless
- WebSocket connections management

**Orchestration Patterns**:
- Step Functions para workflows complejos
- Event Bridge para event routing
- SQS para message queuing

**Consideraciones Espec√≠ficas**:
- Cold start optimization
- Stateless design imperatives
- Resource limits awareness
- Cost optimization strategies

---

## GraphQL Federation

### Arquitectura de APIs Federadas
Patr√≥n para construir GraphQL APIs distribuidas across m√∫ltiples equipos.

**Federation Components**:

**Subgraph Services**:
- Autonomous GraphQL schemas
- Team ownership boundaries
- Independent deployment cycles

**Gateway/Router**:
- Single entry point for clients
- Query planning and execution
- Schema composition and validation

**Entity Resolution**:
- Cross-service data fetching
- Reference resolvers
- N+1 query prevention

**Extended Type System**:
- @key directives for entity keys
- @external for cross-references
- @requires for field dependencies

---

## Reactive Systems Principles

### Sistemas Responsivos y Resilientes
Arquitecturas dise√±adas alrededor de principios reactivos para sistemas modernos.

**Reactive Manifesto Principles**:

**Responsive**:
- Fast and consistent response times
- Real-time user feedback
- Predictable performance

**Resilient**:
- Failure containment
- Self-healing capabilities
- Graceful degradation

**Elastic**:
- Dynamic resource allocation
- Scale up/down automatically
- Load distribution intelligence

**Message Driven**:
- Async non-blocking communication
- Location transparency
- Back-pressure propagation

**Implementation Patterns**:
- Actor model systems
- Reactive streams
- Event loop architectures
- Non-blocking I/O

---

## Data-intensive Applications Patterns

### Patrones para Procesamiento de Datos
Arquitecturas especializadas en manejo de grandes vol√∫menes de datos.

**Stream Processing**:
- Real-time data pipelines
- Windowed aggregations
- Complex event processing

**Batch Processing**:
- Large-scale data transformation
- ETL/ELT workflows
- Distributed computing patterns

**Lambda Architecture**:
- Batch layer for comprehensive views
- Speed layer for real-time updates
- Serving layer for query integration

**Kappa Architecture**:
- Stream-only processing
- Replay capability for reprocessing
- Simplified maintenance model

---

## AI/ML System Patterns

### Arquitecturas para Sistemas de Machine Learning
Patrones espec√≠ficos para integraci√≥n y operaci√≥n de modelos de ML.

**ML Pipeline Architecture**:

**Data Collection**:
- Feature store implementation
- Data versioning
- Quality monitoring

**Model Training**:
- Automated retraining pipelines
- Experiment tracking
- Hyperparameter optimization

**Model Serving**:
- Real-time inference endpoints
- Batch prediction jobs
- A/B testing infrastructure

**Model Monitoring**:
- Prediction quality metrics
- Data drift detection
- Performance degradation alerts

**MLOps Practices**:
- Infrastructure as Code para ML
- Automated deployment pipelines
- Model registry management
- Compliance and explainability

---

## Blockchain-inspired Patterns

### Patrones de Sistemas Descentralizados
Arquitecturas inspiradas en blockchain para aplicaciones empresariales.

**Distributed Ledger Patterns**:

**Immutable Audit Trail**:
- Append-only data structures
- Cryptographic verification
- Timestamping services

**Consensus Mechanisms**:
- Practical Byzantine Fault Tolerance
- Proof of Authority
- Raft consensus algorithm

**Smart Contract Patterns**:
- Business logic encapsulation
- State transition validation
- Multi-signature authorization

**Tokenization Patterns**:
- Digital asset representation
- Ownership tracking
- Transfer authorization

---

## Quantum-ready Architecture

### Preparaci√≥n para Computaci√≥n Cu√°ntica
Patrones para sistemas que necesitan prepararse para la era cu√°ntica.

**Cryptography Transition**:
- Post-quantum cryptography adoption
- Hybrid cryptographic systems
- Key management evolution

**Algorithm Design**:
- Quantum-resistant algorithms
- Classical-quantum hybrid approaches
- Problem decomposition strategies

**Data Structure Preparation**:
- State representation optimization
- Parallel processing readiness
- Entanglement-aware design

**Development Practices**:
- Quantum computing literacy
- Algorithm selection criteria
- Performance benchmarking
- Security assessment frameworks

---

## Ethical AI Patterns

### Patrones para IA Responsable
Arquitecturas que incorporan consideraciones √©ticas en sistemas de IA.

**Fairness and Bias Mitigation**:
- Bias detection pipelines
- Fairness metrics monitoring
- Demographic parity enforcement

**Transparency and Explainability**:
- Model interpretability components
- Decision tracing mechanisms
- Explanation generation

**Privacy Preservation**:
- Differential privacy implementation
- Federated learning architectures
- Data anonymization pipelines

**Accountability and Governance**:
- Audit trail for AI decisions
- Human-in-the-loop patterns
- Ethics committee review integration

**Compliance Frameworks**:
- Regulatory requirement mapping
- Documentation automation
- Impact assessment integration

Estas arquitecturas y patrones especializados representan la evoluci√≥n hacia sistemas m√°s descentralizados, √©ticos y preparados para las demandas futuras, manteniendo siempre los principios fundamentales de buen dise√±o y separaci√≥n de responsabilidades.