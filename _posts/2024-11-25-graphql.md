---
date: 2024-11-25 16:24
title: GraphQL
tags:
keywords:
source:
status: üöÄ
Parent: "[[Area-Prog]]"
cssclasses:
public_note: "true"
category: graphql
categories:
  - graphql
  - api
  - backend
  - hide-embedded-header1
  - wide
  - Backend
---
# GraphQL
`$= dv.current().file.tags.join(" ")`

- [Backend](/uncategorized/backend/)
- [api](/backend/api/)
- [JSON](/databases/json/)
- [websockets](/backend/websockets/)
- [web services](/backend/web-services/)
- [node.js](/backend/node-js/)
- shopify

## Recursos
- [Introduction to GraphQL | GraphQL](https://graphql.org/learn/)
- [GitHub - graphql/graphql.github.io](https://github.com/graphql/graphql.github.io/tree/source?tab=readme-ov-file)
- [Running an Express GraphQL Server | GraphQL](https://graphql.org/graphql-js/running-an-express-graphql-server/)
- [GitHub GraphQL API documentation - GitHub Docs](https://docs.github.com/en/graphql)
- GraphQL - Wikipedia-GraphQL
- ¬øQu√© es GraphQL  IBM-graphql
- [ ] [How to GraphQL - The Fullstack Tutorial for GraphQL](https://www.howtographql.com/) 

---

## Conceptos fundamentales

### ¬øQu√© es GraphQL?
GraphQL es un lenguaje de consulta y un runtime para APIs que permite a los clientes definir exactamente qu√© datos necesitan. Fue creado por Facebook para resolver problemas comunes en APIs REST, como el **overfetching** (exceso de datos) y **underfetching** (falta de datos).  
A diferencia de REST, no se basa en m√∫ltiples endpoints, sino en una **√∫nica URL** que interpreta consultas estructuradas.

### Estructura b√°sica
- **Schema**: define los tipos de datos, sus relaciones y operaciones posibles.
- **Query**: solicita datos (similar a GET en REST).
- **Mutation**: modifica datos (similar a POST, PUT, DELETE).
- **Subscription**: gestiona flujos de datos en tiempo real usando [websockets](/backend/websockets/).

---

## Componentes del Schema

### Definici√≥n de Schema
El schema describe las entidades que pueden consultarse y c√≥mo se relacionan entre s√≠.  
Ejemplo b√°sico:

{% raw %}
```graphql
type User {
	id: ID!
	name: String!
	email: String!
}

type Query {
	users: [User]
	user(id: ID!): User
}
```
{% endraw %}`

### Tipos de datos

* **Escalares**: `Int`, `Float`, `String`, `Boolean`, `ID`
* **Objetos**: estructuras definidas por el usuario
* **Enums**: listas de valores permitidos
* **Interfaces y Unions**: definen relaciones polim√≥rficas entre tipos
* **Directivas**: como `@deprecated` para marcar campos obsoletos

---

## Operaciones principales

### Querys

Permiten consultar datos espec√≠ficos, incluso de entidades relacionadas, evitando m√∫ltiples llamadas.

{% raw %}
```graphql
query {
	user(id: "1") {
		name
		email
		posts {
			title
			content
		}
	}
}
```
{% endraw %}

### Mutations

Usadas para crear, modificar o eliminar datos.

{% raw %}
```graphql
mutation {
	createUser(name: "Eduardo", email: "edu@example.com") {
		id
		name
	}
}
```
{% endraw %}

### Subscriptions

Permiten actualizaciones en tiempo real usando [websockets](/backend/websockets/).

{% raw %}
```graphql
subscription {
	userCreated {
		id
		name
	}
}
```
{% endraw %}

---

## Comparativa con REST

| Caracter√≠stica              | REST                        | GraphQL                            |
| --------------------------- | --------------------------- | ---------------------------------- |
| Endpoints                   | M√∫ltiples                   | Uno solo                           |
| Peticiones                  | GET, POST, PUT, DELETE      | Query, Mutation, Subscription      |
| Estructura de respuesta     | Fija                        | Flexible (definida por el cliente) |
| Problemas comunes           | Overfetching, Underfetching | Minimiza ambos                     |
| Comunicaci√≥n en tiempo real | Limitada                    | Integrada (Subscriptions)          |

---

## Problemas comunes y optimizaci√≥n

### Underfetching y Overfetching

* **Underfetching**: la API devuelve menos datos de los necesarios ‚Üí m√∫ltiples llamadas.
* **Overfetching**: la API devuelve m√°s datos de los necesarios ‚Üí uso ineficiente de recursos.

**Soluci√≥n:** GraphQL permite consultas precisas que reducen ambos casos.

### Consultas costosas

El servidor debe validar y limitar la complejidad de las consultas para evitar abusos o degradaci√≥n de rendimiento.

### Optimizaci√≥n

* Implementar control de profundidad de queries.
* Usar caching selectivo en resolvers.
* Monitorizar consultas m√°s frecuentes.
* Agrupar resolvers con dataloader para evitar N+1 queries.

---

## Integraci√≥n y ecosistema

### En [node.js](/backend/node-js/)

GraphQL se implementa com√∫nmente con **Express** o **Apollo Server**.
Ejemplo b√°sico usando `express-graphql`:

{% raw %}
```js
import express from "express";
import { graphqlHTTP } from "express-graphql";
import { buildSchema } from "graphql";

const schema = buildSchema(`
	type Query {
		hello: String
	}
`);

const root = { hello: () => "Hello world!" };

const app = express();
app.use("/graphql", graphqlHTTP({ schema, rootValue: root, graphiql: true }));
app.listen(4000);
console.log("Servidor GraphQL en http://localhost:4000/graphql");
```
{% endraw %}

### En ecosistemas modernos

* **shopify** utiliza GraphQL extensivamente para su API Storefront.
* **GitHub** ofrece su API principal en GraphQL para obtener datos de repositorios y usuarios de manera optimizada.
* **Apollo Federation** permite unir m√∫ltiples servicios GraphQL en un solo gateway.

---

## Buenas pr√°cticas

* Dise√±ar schemas simples y predecibles.
* Documentar queries y mutations.
* Evitar anidamientos excesivos.
* Controlar la autenticaci√≥n y autorizaci√≥n a nivel de campo.
* Implementar paginaci√≥n y filtros en las queries.
* Validar la complejidad de las consultas en el backend.

---

## Tareas pendientes

* [ ] Probar APIs de ejemplo (GraphQL Playground o Apollo Sandbox)
* [ ] Integraci√≥n con Git y despliegue continuo
* [ ] A√±adir ejemplos de autenticaci√≥n con tokens y contextos


# GraphQL ‚Äì Temas avanzados

## Fragmentos reutilizables, alias y argumentos  
- **Fragments**: Permiten definir porciones de consulta reutilizables para evitar duplicaci√≥n. :contentReference[oaicite:1]{index=1}  
  {% raw %}
```graphql
  fragment addressFields on User {
  	name
  	street
  	city
  	zipcode
  }
  query {
  	users {
  		...addressFields
  	}
  }
```
{% endraw %}`

* **Alias**: Permiten nombrar resultados de campos con argumentos, cuando usas el mismo campo varias veces. Ejemplo:

  {% raw %}
````graphql
  {
  	first: user(id:"1") { name }
  	second: user(id:"2") { name }
  }
  ```
{% endraw %} :contentReference[oaicite:2]{index=2}  
  {% raw %}
````
* **Argumentos de campo**: Los campos pueden recibir argumentos, incluso con valores por defecto, lo cual da m√°s expresividad al esquema. ([howtographql.com][1])

## Tipos avanzados de SDL (Schema Definition Language)

* Puedes definir **escalares personalizados**, `enum`, `interface`, `union`. ([howtographql.com][1])
* **Inline fragments**: Se usan para consultas condicionales en tipos union o interface. ([Shopify][2])

  ```
{% endraw %}graphql
  union SearchResult = User | Product
  query {
  	search(text:"foo") {
  		... on User { id name }
  		... on Product { id title price }
  	}
  }
  {% raw %}
```

## Persisted queries y batching

* **Persisted queries**: Consultas pre-registradas en el servidor para reducir coste de parsing, mejorar cach√©, etc. ([Experience League][3])
* **Batched queries**: Env√≠o de m√∫ltiples operaciones (queries/mutations) en una sola petici√≥n, con alias, aunque la complejidad se suma. ([Shopify][2])

## Arquitectura, escalabilidad y federaci√≥n

* **Federation / composici√≥n de servicios**: Permite que m√∫ltiples microservicios GraphQL participen en un gateway unificado (por ejemplo Apollo Federation). ([blog.bytebytego.com][4])
* **Escalabilidad en producci√≥n**: Caching, balanceo, monitorizaci√≥n, limitaci√≥n de complejidad de queries. ([Medium][5])

## Seguridad, validaci√≥n y rendimiento

* Validaci√≥n de entradas, control de profundidad, coste de consulta para evitar abusos. ([Medium][6])
* Seguridad espec√≠fica para GraphQL: ataques de inyecci√≥n, denegaci√≥n de servicio por consultas complejas, an√°lisis de dependencias entre consultas. ([arXiv][7])
* Optimizaci√≥n de consultas: paginaci√≥n, l√≠mite de profundidad, data-loader para evitar N+1.

## Herramientas y generaci√≥n de c√≥digo

* Generaci√≥n autom√°tica de tipos y consultas para lenguajes fuertemente tipados (TypeScript, etc) que se alinean con el esquema GraphQL. ([Medium][5])
* Depuraci√≥n, tracing y monitorizaci√≥n de ejecuci√≥n de consultas (por ejemplo con Apollo Studio o similares).

## Integraci√≥n con microservicios y bases de datos gr√°ficas

* Uso de GraphQL sobre arquitecturas de microservicios: cada servicio expone su parte del esquema, se compone todo. ([blog.bytebytego.com][4])
* Ejecuci√≥n de GraphQL sobre grafos RDF o bases de datos de grafos, con algoritmos de join multi-way optimizados. ([arXiv][8])

## Buenas pr√°cticas avanzadas

* Versionado cero (evitar breaking changes a√±adiendo campos y usando directivas como `@deprecated`).
* Dise√±ar el esquema pensando en el cliente: anticipar qu√© datos necesitar√° y c√≥mo evolucionar√°.
* Usar m√©tricas de complejidad de consulta para rechazar o limitar queries que podr√≠an degradar el rendimiento.
* Instrumentar logs y alertas espec√≠ficas para GraphQL (autenticaci√≥n, autorizaci√≥n, performance).
* Mantener la separaci√≥n de responsabilidades entre schema (contrato) y resolvers (implementaci√≥n).

## Lista de verificaci√≥n para producci√≥n

- Definir estrategias de cach√© para respuestas, campos y nivel de consulta.
- Implementar limitaci√≥n de profundidad y coste en consultas (maxDepth, maxComplexity).
- Validar entradas (input types) y sanitizar argumentos antes de resolver.
- Auditar operaciones de suscripci√≥n: autenticaci√≥n, escala, desconexiones.
- Monitorizar latencias de resolvers, tiempos de respuesta globales, tasa de errores.
- Planificar fallback o degradaci√≥n de servicio ante cargas elevadas.
- Registrar y alertar operaciones sospechosas en esquemas GraphQL din√°micos.

## fuentes
- [1]: https://www.howtographql.com/advanced/2-more-graphql-concepts/?utm_source=chatgpt.com "Advanced GraphQL Language Concepts Tutorial"
- [2]: https://shopify.dev/docs/apps/build/graphql/basics/advanced?utm_source=chatgpt.com "Advanced concepts"
- [3]: https://experienceleague.adobe.com/en/docs/experience-manager-learn/getting-started-with-aem-headless/graphql/advanced-tutorial/overview?utm_source=chatgpt.com "Advanced Concepts of AEM Headless - GraphQL"
- [4]: https://blog.bytebytego.com/p/graphql-101-api-approach-beyond-rest?utm_source=chatgpt.com "GraphQL 101: API Approach Beyond REST"
- [5]: https://mobilelive.medium.com/graphql-advanced-concepts-a-comprehensive-guide-3479355d4709?utm_source=chatgpt.com "GraphQL Advanced Concepts: A Comprehensive Guide"
- [6]: https://ahmedrebai.medium.com/graphql-advanced-concepts-f7557b6132f4?utm_source=chatgpt.com "GraphQL advanced concepts . (Feb Blog) | by Rebai Ahmed"
- [7]: https://arxiv.org/abs/2504.13358?utm_source=chatgpt.com "GraphQLer: Enhancing GraphQL Security with Context-Aware API Testing"
- [8]: https://arxiv.org/abs/2409.12646?utm_source=chatgpt.com "Native Execution of GraphQL Queries over RDF Graphs Using Multi-way Joins"

# GraphQL ‚Äì Temas adicionales

## Schema stitching vs federaci√≥n profunda  
- A diferencia de la federaci√≥n pura, el llamado *schema stitching* permite combinar distintos esquemas GraphQL en uno s√≥lo sin usar necesariamente el est√°ndar de Apollo Federation.  
  - Esto puede usarse para integrar servicios REST, GraphQL externos o bases de datos distintas bajo un √∫nico esquema. :contentReference[oaicite:2]{index=2}  
- Ventajas: menor acoplamiento entre equipos, migraciones m√°s suaves, menor dependencia de un √∫nico proveedor.  
- Desventajas: puede requerir configuraci√≥n compleja y los planes de ejecuci√≥n pueden volverse m√°s opacos.

## Transporte y protocolo para suscripciones federadas  
- En escenarios federados, gestionar suscripciones (real-time) es especialmente desafiante: m√∫ltiples servicios, m√∫ltiples conexiones, sincronizaci√≥n. :contentReference[oaicite:3]{index=3}  
- Ejemplo avanzado: en Apollo GraphOS se introduce un nuevo protocolo `multipart-subscriptions` para cliente‚Üígateway y deduplicaci√≥n de conexiones gateway‚Üísubgraph. :contentReference[oaicite:5]{index=5}  
- Tips para dise√±ar: usar WebSocket o HTTP2 con multiplexaci√≥n; deduplicar conexiones cuando muchos clientes usan la misma suscripci√≥n; minimizar latencia.

## Validaci√≥n, seguridad y testing automatizado  
- Vulnerabilidades espec√≠ficas de GraphQL: inyecci√≥n de consultas, mediaci√≥n de autorizaci√≥n en campos, ataques de denegaci√≥n de servicio via queries altamente complejas. :contentReference[oaicite:6]{index=6}  
- Buenas pr√°cticas:
  - Definir qu√© campos pueden consultarse y con qu√© argumentos.  
  - Limitaci√≥n de profundidad (`maxDepth`), complejidad (`maxComplexity`) de la query.  
  - Testing automatizado que entienda el grafo de dependencias entre queries/mutations para detectar bypass de autorizaci√≥n.  
  - Monitorizaci√≥n de patrones de uso sospechosos.

## Caching, persistencia y control de respuestas  
- Cache a nivel de campo / tipo: en federaci√≥n, puedes indicar mediante directivas como `@cacheControl(maxAge: Int, scope: PUBLIC|PRIVATE)` qu√© nivel de cach√© debe aplicar cada campo. :contentReference[oaicite:7]{index=7}  
- Persisted queries (consultas pre-registradas) que permiten reducir el parsing y mejorar la cach√© de consultas repetitivas.  
- Cache del cliente, cache del servidor: definir pol√≠ticas coherentes para invalidaci√≥n post-mutaci√≥n, uso de `ResponseCachePlugin`, etc. :contentReference[oaicite:8]{index=8}

## Migraciones de API, versionado y evoluci√≥n del esquema  
- Con GraphQL la versi√≥n tradicional de "v1, v2, v3" se reemplaza por evoluci√≥n continua del esquema:  
  - Agregar campos nuevos en tipos existentes (sin romper compatibilidad).  
  - Marcar campos obsoletos con `@deprecated(reason: "...")`.  
  - Evitar eliminar campos que los clientes a√∫n usan.  
- En federaci√≥n, esto es a√∫n m√°s cr√≠tico porque m√∫ltiples equipos pueden exponer sub¬≠esquemas.  
- Plan de evoluci√≥n:
  - Documentar uso de cada campo.  
  - Comunicar deprecaciones a los equipos clientes.  
  - Usar herramientas de generaci√≥n de tipos (TypeScript, etc) para que los cambios se propaguen en tiempo de compilaci√≥n.

## Logging, m√©tricas y observabilidad en producci√≥n  
- Aseg√∫rate de que tu infraestructura GraphQL cuente con:  
  - Tiempos de ejecuci√≥n de resolvers, latencia por operaci√≥n.  
  - N¬∫ de nodos devueltos, profundidad de consulta, tama√±o del payload.  
  - M√©tricas de uso de suscripciones: conexiones activas, mensajes por segundo.  
  - Alertas para esquemas con muchas peticiones, errores frecuentes, uso de campos `@deprecated`.  
- Estas m√©tricas permiten anticipar cuellos de botella, abusos o degradaci√≥n del servicio.

## Integraci√≥n con otras tecnolog√≠as y fuentes de datos  
- Usar GraphQL como ‚Äúfachada‚Äù sobre diferentes backends: REST, bases de datos NoSQL, microservicios, servicios event-driven.  
- En federaci√≥n, cada subgrafo puede estar implementado con distinto stack tecnol√≥gico, y t√∫ los unificas bajo un √∫nico gateway.  
- La estrategia de migraci√≥n ‚Äúpor piezas‚Äù permite que un tipo o campo migre a servicio nuevo sin interrupciones (como lo describe el caso de WunderGraph). :contentReference[oaicite:10]{index=10}

## Estrategia de errores y fallas degradadas  
- En consultas federadas o complejas, pueden fallar subresolvers individuales. La estrategia debe contemplar:  
  - Devolver datos parciales √∫tiles en lugar de fallo general (‚Äúbest-effort‚Äù).  
  - Utilizar directivas como `@defer` y `@stream` para ofrecer partes de la respuesta que lleguen antes.  
  - Dise√±ar mecanismos de fallback cuando un subgrafo no est√° disponible: cache reciente, valores predeterminados, l√≥gica de retry.

# GraphQL ‚Äì Implementaci√≥n en producci√≥n

## Estructura general de proyecto
Un entorno de producci√≥n en GraphQL suele organizarse en capas bien definidas:

1. **Schema y resolvers** ‚Äì definici√≥n del contrato y l√≥gica de obtenci√≥n de datos.  
2. **M√≥dulo de seguridad** ‚Äì autenticaci√≥n, autorizaci√≥n, validaci√≥n.  
3. **Optimizaci√≥n de rendimiento** ‚Äì cach√©, batching, l√≠mites de complejidad.  
4. **Observabilidad y m√©tricas** ‚Äì logging, tracing, monitorizaci√≥n.  
5. **Evoluci√≥n del esquema** ‚Äì gesti√≥n de cambios, deprecaciones, comunicaci√≥n con clientes.  
6. **Gateway / federaci√≥n** ‚Äì integraci√≥n de m√∫ltiples servicios o fuentes de datos.

---

## Configuraci√≥n base con Apollo Server

```
{% endraw %}js
// server.js
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';
import { typeDefs } from './schema.js';
import { resolvers } from './resolvers.js';
import depthLimit from 'graphql-depth-limit';
import { createComplexityLimitRule } from 'graphql-validation-complexity';

const server = new ApolloServer({
	typeDefs,
	resolvers,
	validationRules: [
		depthLimit(10),
		createComplexityLimitRule(2000)
	],
	introspection: process.env.NODE_ENV !== 'production'
});

const { url } = await startStandaloneServer(server, {
	listen: { port: 4000 },
	context: async ({ req }) => ({
		token: req.headers.authorization || ''
	})
});

console.log(`üöÄ Servidor listo en ${url}`);
{% raw %}
````

---

## Validaci√≥n y seguridad

### Autenticaci√≥n y autorizaci√≥n

* Implementar un contexto compartido que propague el usuario autenticado.
* A nivel de resolver, validar los permisos con el contexto.
* Evitar exponer informaci√≥n sensible en errores.

```
{% endraw %}js
// resolvers.js
export const resolvers = {
	Query: {
		secretData: (_, __, { user }) => {
			if (!user || !user.isAdmin) throw new Error("Acceso denegado");
			return getSensitiveInfo();
		}
	}
};
{% raw %}
```

### Protecci√≥n contra abusos

* Limitar profundidad y complejidad de consultas.
* Desactivar introspecci√≥n en producci√≥n.
* Validar inputs y sanitizar argumentos.

---

## Caching y optimizaci√≥n

### Cache por campo o tipo

```
{% endraw %}graphql
type Product @cacheControl(maxAge: 60, scope: PUBLIC) {
	id: ID!
	name: String!
	price: Float
}
{% raw %}
```

### Uso de DataLoader

Evita el problema N+1 cargando datos en batch.

```
{% endraw %}js
import DataLoader from 'dataloader';
const userLoader = new DataLoader(async (ids) => {
	const users = await db.users.find({ _id: { $in: ids } });
	return ids.map(id => users.find(u => u.id === id));
});
{% raw %}
```

### Persisted queries

Permiten reducir el coste de parsing y prevenir inyecci√≥n de consultas.

* Pre-registrar queries hashadas en el servidor.
* El cliente env√≠a solo el hash de la consulta.
* Ideal para APIs p√∫blicas o m√≥viles.

---

## Monitorizaci√≥n y m√©tricas

### Ejemplo de integraci√≥n con Apollo Studio

```
{% endraw %}js
new ApolloServer({
	typeDefs,
	resolvers,
	plugins: [
		require('apollo-server-core').ApolloServerPluginUsageReporting({
			sendVariableValues: { all: true },
			sendHeaders: { all: true }
		})
	]
});
{% raw %}
```

### M√©tricas recomendadas

* Tiempo promedio por resolver.
* N¬∫ de queries por tipo.
* Profundidad media y complejidad de consulta.
* Ratio de errores.
* Campos m√°s utilizados.

---

## Estrategia de evoluci√≥n del esquema

### Deprecaci√≥n controlada

```
{% endraw %}graphql
type User {
	email: String @deprecated(reason: "Use contact.email en su lugar")
	contact: Contact
}
{% raw %}
```

### Auditor√≠a de uso

* Analizar logs de queries para detectar campos obsoletos.
* Comunicar con los clientes las futuras eliminaciones.
* Mantener un changelog de schema.

---

## Integraci√≥n con microservicios (Federation)

```
{% endraw %}js
// gateway.js
import { ApolloGateway } from '@apollo/gateway';
import { ApolloServer } from '@apollo/server';

const gateway = new ApolloGateway({
	serviceList: [
		{ name: 'users', url: 'http://localhost:4001/graphql' },
		{ name: 'orders', url: 'http://localhost:4002/graphql' }
	]
});

const server = new ApolloServer({ gateway, subscriptions: false });
{% raw %}
```

Ventajas:

* Escalado independiente por dominio.
* Equipos aut√≥nomos.
* Evoluci√≥n modular del esquema.

---

## Estrategia de errores y fallbacks

### Devoluci√≥n parcial con `@defer` y `@stream`

Permiten entregar datos parciales antes de completar toda la query.

```
{% endraw %}graphql
query {
	products {
		id
		name
		reviews @stream(initialCount: 2) {
			content
		}
	}
}
{% raw %}
```

### Respuesta parcial ante fallos

En resolvers federados, devolver datos parciales √∫tiles:

```
{% endraw %}js
try {
	return await fetchOrder(id);
} catch (err) {
	return { id, status: "UNKNOWN", error: err.message };
}
{% raw %}
```

---

## Plantillas √∫tiles para producci√≥n

### .env

```
{% endraw %}
NODE_ENV=production
PORT=4000
GRAPHQL_DEPTH_LIMIT=10
GRAPHQL_COMPLEXITY_LIMIT=2000
JWT_SECRET=yourSecretKey
{% raw %}
```

### package.json (m√≠nimo)

```
{% endraw %}json
{
	"scripts": {
		"start": "node server.js",
		"dev": "nodemon server.js"
	},
	"dependencies": {
		"@apollo/server": "^4.0.0",
		"graphql": "^16.8.0",
		"graphql-depth-limit": "^1.1.0",
		"graphql-validation-complexity": "^0.4.2",
		"dataloader": "^2.1.0"
	}
}
```

---

## Checklist para despliegue

- Introspecci√≥n desactivada en producci√≥n
- L√≠mite de profundidad y complejidad configurado
- Cache por tipo y DataLoader activo
- Autenticaci√≥n/Autorizaci√≥n verificadas
- Persisted queries habilitadas
- Logs y m√©tricas en servidor centralizado
- Auditor√≠a de campos obsoletos en curso
- Fallbacks implementados para errores federados

---

## Recursos avanzados

* [Apollo Federation Docs](https://www.apollographql.com/docs/federation/)
* [GraphQL Security Checklist](https://github.com/graphql-java/graphql-java/blob/master/SECURITY.md)
* [GraphQL Caching Guide](https://www.apollographql.com/docs/apollo-server/performance/caching/)
* [GraphQL Best Practices RFC](https://graphql.org/learn/best-practices/)
* [How to Prevent Over-complex Queries](https://www.apollographql.com/blog/graphql/security/limiting-query-complexity/)


