---
date: 2024-09-04T03:12:00
title: react
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: JS
tags:
  - JS
  - React
  - Frontend
---
# react
`$= dv.current().file.tags.join(" ")`

[react-projects.code-workspace](file:///C:%5CUsers%5CAdmin%5CDesktop%5CDocs%20Hp%202%5CJS-Projects%5Creact-projects.code-workspace)  
[ZOTERO JS-React](zotero://select/library/collections/3F6LZ7QX)  
[Udemy - React 18 Tutorial and Projects Course 2023](file:///F:%5CCURSOS%5CUdemy%20-%20React%2018%20Tutorial%20and%20Projects%20Course%202023)

- [Software engineering](/uncategorized/software-engineering/)
- [Sistemas](/uncategorized/sistemas/)
- [nextjs](/frontend/nextjs/)
- [react native](/desarrollo%20multiplataforma/react-native/)

## Recursos principales
- curso React-50-proyectos
	- 50.Projects.for.React.and.the.Static.Web.Colby.Fayock.1.0.pdf
	- [GitHub - 50 projects](https://github.com/colbyfayock/50-projects-for-react-and-the-static-web)
	- Business & Real-World
	- [GitHub - Business & Real-World](https://github.com/colbyfayock/50-projects-for-react-and-the-static-web/tree/master/Business%20%26%20Real-World)
- curso Udemy React 18
	- [readme fundamentals](https://github.com/john-smilga/react-course-v3/tree/main/01-fundamentals)
	- ``npx create-react-app@latest nombre`` (mejor usar Vite)
	- estructura: root injection, entry point src/index.js, gitignore, package.json/lock, scripts
	- nodejs-Instalar librer√≠as y borrar node modules
	- componentes funcionales (React, ReactDOM, createRoot, render)
	- extensiones vscode [Sistemas](/uncategorized/sistemas/)
		- [snippets react](https://github.com/r5n-dev/vscode-react-javascript-snippets/blob/HEAD/docs/Snippets.md)
		- rcc, rafce, rfce
	- createElement() vs JSX return()
	- fragment, camelCase
- [github curso react v3](https://github.com/john-smilga/react-course-v3)
- accomazzoFullstackReactComplete2017
- React-apuntes-libro-accomazzo
- React-full-course-2022 ‚ô•
- React-ReactJSJobseekers
- react-old

## Entrevistas React
- [Entrevista Semi Senior (MR s0da)](https://youtu.be/YFMqm5DWZ40)
	- instalar eslint, Vite recomendado, snippets
	- prueba t√©cnica: contador, listado, buenas pr√°cticas
- [Qu√© te preguntan en React (2024-2025)](https://youtu.be/uIAGyKxl878)

## Tipado con TypeScript en React
- [ComponentProps](https://youtu.be/vWy7edGAKBM) [typescript](/software%20engineering/typescript/)
	- ComponentProps para interfaces
	- destructuring con spread vs rest
	- typeof para props derivadas

## Conceptos React esenciales
- state, actions, context, refs
- [Redux](/frontend/redux/) vs context
- suspense & lazy loading
- providers groups
- patrones y optimizaci√≥n de componentes
- update algorithm / reconciliaci√≥n

## Tools
- [react-scan](https://github.com/aidenybai/react-scan)

## React 19 ‚Äì Conceptos avanzados
### Manejo de estados
- Context
	- state global
	- useReducer
		- action con payload
		- single source of truth
- [Redux](/frontend/redux/)
	- Redux Toolkit
	- RTK Query
	- m√∫ltiples entidades
- Comienza ‚Äì SWR
- state with revalidate
- Zustand
- Jotai
	- atoms
- Observables (RxJS - Introduction)
	- behavior subject

### Enrutamiento y navegaci√≥n
- react-router-dom
- query params
- diferencia entre nodo DOM y nodo JSX

### Hooks de optimizaci√≥n
- useMemo
- useRef
- useCallback
- memo

### Detecci√≥n de cambios y render
- strict mode
	- bootstrap doble renderizado
- re-renders y triggers
- diferencia estado vs par√°metros
- commit phase

### Compartir data entre componentes
- padre ‚Üí hijo
	- composition pattern
	- prop drilling
- hermanos
	- observers
	- services
	- context
- singleton pattern
	- errores de carrera
- observables
- provider dependency

### Batching de estado
- setState
- usar callback para estado previo

### Hooks principales
- useState
- useEffect
	- para side effects externos
	- no para reaccionar a estados internos del mismo componente
	- dependencias
	- async en efectos

## Formularios
### react-hook-form
- useForm
- validaci√≥n
	- zod ‚Üí schemas
	- yup

## Arquitecturas en React
- SCREAM, CLEAN
- container vs presentational components
- [Computer Science](/uncategorized/computer-science/)

## Consumo de APIs
- [axios](/backend/axios/) vs fetch
- [Backend](/uncategorized/backend/)
- interrupci√≥n con tokens/headers
- [api](/backend/api/)
- interceptores

## Otros conceptos avanzados
- container vs componente
- Portals
- HOC (High Order Components)
- custom hooks
	- l√≥gica reutilizable
	- encapsulaci√≥n
	- useState/useReducer internos
- suspense vs lazy
	- placeholders
- error boundary
- CSS modules

## Pruebas t√©cnicas ‚Äì ejemplos
- scroll infinito con lazy load
- IntersectionObserver
- fetch a APIs con dependencias entre estados
- end to end tests
- configurar entorno (Vite)
- [Automatizacion y Build](/uncategorized/automatizacion-y-build/)
	- npm react & react-dom
- [linters](/testing/linters/)
- flujos complejos con useEffect

# apuntes react

## UI Intro
- Named & default exports
- JSX ‚Üí usar [converter](https://transform.tools/html-to-jsx)
- Expresiones: objetos `{{}}`, strings, concatenaci√≥n con `+`
- Props, destructuring y spread ``{...props}``, ``{children}``
- Ejercicios: extraer componentes, controlar tama√±o thumbnail, usar children

### Renderizado condicional
- return temprano, `null`
- [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
- ternary, `&&` (solo usarlo con boolean a la izquierda)
- asignar JSX a variables
- JSX dentro de la condici√≥n
- Ejercicios: `importance &&`, refactor if ‚Üí variables/obj

### Listas y keys
- map, filter, keys con ``{person.id}``
- usar `<Fragment key={person.id}>`
- [`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID), [`uuid`](https://www.npmjs.com/package/uuid)
- evitar `key={Math.random()}` o index
- Ejercicios:
	- separar listas, nested maps
	- `<Recipe {...recipe} key={recipe.id}>`
	- shortcut props
	- keys en contexto
	- listar con separador condicionado

### Pureza
- side effects pasando `guest` como prop
- read-only
- `<React.StrictMode>`
- mutaci√≥n vs inmutabilidad
- event handlers: https://react.dev/learn/responding-to-events
- [`useEffect`](https://react.dev/reference/react/useEffect)
- [memo](https://react.dev/reference/react/memo)
- ["set" state](https://react.dev/learn/state-a-components-memory)
- Ejercicios: reloj, perfil, mutaci√≥n ‚Üí `slice()`
- M√©todos mutables: push, pop, reverse, sort  
- No mutables: slice, filter, map

### UI Tree
- Dependencia hijos/data
- conditional rendering
- top-level y leaf components
- module dependency tree
- bundler: https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Overview#the_modern_tooling_ecosystem


## Interactivity
- manejar interacciones, actualizar estado, cambiar UI
- [`useState`](https://react.dev/reference/react/useState)
	- Trigger ‚Üí Render ‚Üí Commit
	- state snapshot

### Queue de estados
- series de actualizaciones
- updater: `setScore(s => s + 1)`
- copiar objetos y arrays con `...`
- `onChange`, ejemplo:
	- `setPerson({ ...person, name: e.target.value });`

### Immer
- https://github.com/immerjs/use-immer
- `import { useImmer } from 'use-immer';`
- `useImmer({})`
- `updatePerson(draft => { draft.name = e.target.value })`
- arrays con propiedad `seen`

### Event Handlers
- leer event, props, callbacks
- `<button onClick={handleClick}>`
- `onClick={() => alert(message)}`
- pasar handler: `onClick={onClick}`
- custom props: `onClick={onSmash}`
- propagaci√≥n:
	- `onScroll` no propaga
	- detener con `e.stopPropagation()`
- captura:
	- `onClickCapture={() => {}}`
- alternativa a propagaci√≥n: pasar handlers a padres
- `e.preventDefault()`
- side effects & state

### Estado como memoria del componente
- hook `use` solo en top-level
- `useState`
- variables locales como `let sculpture = sculptureList[index]`
- formularios ‚Üí mejor un objeto de estado
- orden de los hooks ‚Üí fijo
- lista de estados como array interno
- estado aislado, privado
- compartir estado: https://react.dev/learn/sharing-state-between-components
- Ejercicios:
	- carrusel con `setIndex((index === sculptureList.length - 1 ) ? 0 : index + 1 )`
	- prev/next flags
	- handlers clausuran variables
	- evitar estados innecesarios

### Render Cycle
- Trigger Render Commit
- Initial render
- [`createRoot`](https://react.dev/reference/react-dom/client/createRoot)
- setState ‚Üí queue render
- render recursivo
- pure calculations
- strict mode ‚Üí errores
- rendimiento anidado: https://reactjs.org/docs/optimizing-performance.html
- DOM API: [`appendChild`](https://developer.mozilla.org/docs/Web/API/Node/appendChild)
- repaint browser

### Snapshot de estado
- setState encola y persiste snapshot
- async no rompe la referencia temporal

### Batching y series de estados
- batching en event handlers
- `setNumber(n => n + 1)`
- reemplazar inmediatamente: `setNumber(number + 5)`
- updater debe ser pura
- naming seg√∫n estado
- ejercicio: calcular estado final

### Objetos en estado
- mutaci√≥n ‚Üí no
- `setPosition({x: e.clientX, y: e.clientY })`
- mutaci√≥n local
- spread shallow:
	- `setPerson({ ...person, [e.target.name]: e.target.value })`
- objetos anidados:
	- `setPerson({...person, artwork: {...person.artwork, title: e.target.value}})`
- evitar anidar profundamente: https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state
- Immer:
	- `updatePerson(draft => { draft.artwork.city = 'Lagos' })`
- Ejercicios:
	- actualizar shape con coords
	- immer para coords y color

### Arrays en estado
- M√©todos mutables:
	- push, unshift, pop, shift, splice, assign, reverse, sort
- No mutables:
	- concat, spread `[...arr]`, filter, slice, map
- Ejemplos:
	- `setArtists([...artists, {id: nextId++, name}])`
	- `artists.filter(a => a.id !== artist.id)`
	- reverse con copia:
{% raw %}
```
const nextList = [...list]
nextList.reverse()
setList(nextList)
```
{% endraw %}
- mutaci√≥n accidental de objetos compartidos:
	- evitar modificar items referenciados
	- copiar item:  
		`return { ...artwork, seen: nextSeen }`
- arrays anidados ‚Üí immer:
	- `updateMyList(draft => { draft.find(a => a.id === id).seen = nextSeen })`

## Ejemplo de C√≥digo ‚Äì Actualizar estado con spread
{% raw %}
```jsx
function Form() {
const [person, setPerson] = useState({ name: '', city: '' })

function handleChange(e) {
	setPerson({
		...person,
		[e.target.name]: e.target.value
	})
}

return (
	<input
	 name="name"
	 value={person.name}
	 onChange={handleChange}
	/>
)
}
```
{% endraw %}`

## Ejemplo ‚Äì Arrays sin mutaci√≥n

{% raw %}
```jsx
function addArtist(name) {
setArtists([...artists, { id: crypto.randomUUID(), name }])
}
```
{% endraw %}
# apuntes react para estados

## 1. Manejar estado (State Management)

### 1.1. Reaccionar al input con el state
- Declarar expl√≠citamente **qu√© mostrar**: estados visuales, mensajes, loaders, errores.
	- √ötil crear *living styleguides* que muestren todos los estados en una sola p√°gina.
- Accionar cambios del estado:
	- Inputs humanos.
	- Cambios autom√°ticos (timers, peticiones, etc.).
- Representar el estado en memoria con **`useState`**:
	- A√±adir primero los estados visuales necesarios.
	- Borrar lo redundante o derivable ‚Üí evitar ‚Äúparadojas de estado‚Äù.
		- ‚ùå `isEmpty` innecesario ‚Üí usar: `answer.length === 0`
		- ‚ùå `isError` duplicado ‚Üí usar: `error !== null`
	- Reducir m√∫ltiples variables que describen la misma realidad en un **solo estado derivado** usando reducers u objetos de estado.

### 1.2. Reducers para unificar m√∫ltiples estados
- Evitan contradicciones entre estados.
- Un solo objeto representa el estado global del componente.
- √ötil cuando:
	- Varias variables dependen entre s√≠ (ej: error no nulo sin sentido si `status === 'success'`).
	- Se tienen m√∫ltiples transiciones de estado complejas.

### 1.3. Event handlers y estado
- Handlers actualizan el estado de forma predecible.
- Considerar:
	- Evitar re-render innecesario.
	- Orden correcto de actualizaciones.

### 1.4. Ejercicios importantes
- Activar una clase CSS seg√∫n estado.
	- Manejar eventos superpuestos con `e.stopPropagation()`.
	- Otra soluci√≥n: devolver dos JSX hermanos (no anidar si no es necesario).
- Editor de perfil:
	- Refactorizar comportamiento usando vanilla JS (`updateDOM`) antes de pasarlo a React para clarificar la l√≥gica.

---

## 2. Elegir la estructura del estado (State Shape)

### 2.1. Agrupar en un objeto
- Cuando varias partes del estado evolucionan juntas.

### 2.2. Evitar contradicciones de estado
- Reemplazar m√∫ltiples booleanos por un **estado finito** (`'typing'`, `'sending'`, `'sent'`).
- Ejemplo correcto:
	{% raw %}
```js
	const [status, setStatus] = useState('typing')
	```
{% endraw %}

### 2.3. Redundancia ‚Üí calcular siempre que sea posible
- No reflejar (mirroring) props en el estado.
	- Solo permitido cuando es un valor ‚Äúinitial‚Äù o ‚Äúdefault‚Äù que luego se ignora.
- No duplicar datos:
	- ‚ùå Guardar `selectedItem`
	- ‚úî Guardar `selectedId`, luego hacer `items.find()`

### 2.4. Objetos anidados profundos ‚Üí normalizar
- Aplanar estructuras:
	- Ejemplo: cada `place` tiene `childIds`.
	- Usar claves din√°micas y arrays de IDs.
- Estados ef√≠meros (ej: hover) deben vivir **cerca del componente que los usa**.

### 2.5. Ejercicios relevantes
- Cron√≥metro:
	- No duplicar tiempo si ya viene en props.
- Lista de paquetes:
	- Arreglar contador redundante.
- Resaltar letras:
	- Problema: desaparece el resaltado cuando actualizas el array ‚Üí estado duplicado.
	- Soluci√≥n: guardar solo el `id` en el estado; usar `letter.id` en handlers.
- Selecci√≥n m√∫ltiple:
	- Array de IDs ‚Üí `includes()`, `.filter()`
	- Si es muy grande ‚Üí usar `Set`
		- M√©todos: `.has()`, `.add()`, `.delete()`, `.size`

---

## 3. Compartir estado entre componentes

### 3.1. Lifting State Up
- Subir el estado al padre.
- Pasar:
	- Datos como props.
	- Handlers como props.
- Controlados vs no controlados:
	- **Controlled**: UI reflejada desde el estado.
	- **Uncontrolled**: DOM mantiene el estado.

### 3.2. Ejemplo: Accordion
- Solo un panel activo.
- Usar `activeIndex`.
- Pasar handler a los hijos.
- Mantener un **single source of truth**.

### 3.3. Ejercicios
- Mantener listas en sync.
- Renderizar seg√∫n estado del padre.

---

## 4. Preservar y resetear estado

### 4.1. Posici√≥n en el √°rbol
- React preserva estado cuando el componente:
	- Mantiene el mismo tipo.
	- Mantiene la misma posici√≥n en el render tree.
- No preserva cuando cambia:
	- Tipo de componente.
	- Posici√≥n.
	- Key.

### 4.2. Forzar reset de estado
- Cambiar `key`:
	{% raw %}
```jsx
	<Chat key={email} />
	```
{% endraw %}

### 4.3. Preservar estado de componentes eliminados
- Ocultarlos con CSS en lugar de desmontarlos.
- Aplanar estado:
	- Guardar mensajes pendientes.
	- Cargar estado inicial desde `localStorage`.

### 4.4. Ejercicios
- Input desaparece:
	- Usar `&&`, ternary o `{null}` para controlar render.
- Intercambiar campos del formulario:
	- A√±adir keys para forzar reset.
- Limpiar im√°genes al cambiar URL:
	- Cambiar `key` en el `<img>`.
- Lista con estado equivocado al reordenar:
	- Usar `id` como key, nunca el √≠ndice.

---

## 5. Extraer l√≥gica compleja a un reducer (`useReducer`)

### 5.1. Caso: TaskApp
- Acciones representadas como objetos:
	{% raw %}
```js
	dispatch({ type: 'add', text: 'Nueva tarea' })
	```
{% endraw %}

### 5.2. Reducer
- Firma:
	{% raw %}
```js
	function reducer(state, action) {
		switch(action.type) {
			case 'add':
				return [...]
			// ...
		}
	}
	```
{% endraw %}

### 5.3. Conexi√≥n con `useReducer`
- Argumentos:
	- Reducer.
	- Estado inicial.
- Retorno:
	- `state`, `dispatch`.

### 5.4. Analog√≠a
- Similar a `Array.prototype.reduce`:
	- Estado = acumulador.
	- Acci√≥n = item que modifica el acumulador.

---

## 6. Pasar datos profundos con Context (`useContext` + `createContext`)
- Evitar ‚Äúprop drilling‚Äù.
- Ideal para:
	- Tema visual.
	- Usuario autenticado.
	- Config global.
- No abusar: puede dificultar el control de renders.

---

## 7. Escalar estado con Reducer + Context
- Combinar ambas t√©cnicas:
	- Reducer controla l√≥gica.
	- Context distribuye estado y dispatch.
- Patr√≥n est√°ndar:
	- `StateContext`
	- `DispatchContext`
- Evitar redundancias como `error !== null` cuando ya hay un `status` bien definido.




# apuntes react docs parte 2 ‚Äî conceptos avanzados no cubiertos

## 1. Renderizaci√≥n y sincronizaci√≥n del estado

### 1.1. C√≥mo React decide renderizar
- Cada actualizaci√≥n de estado programa un **render**, pero React puede:
	- Agrupar (batching) m√∫ltiples actualizaciones.
	- Omitir renderizados si el resultado no cambia visualmente.
- React ejecuta el render en **modo concurrente**, pudiendo pausar, interrumpir o descartar renders antes de comprometerlos al DOM.

### 1.2. Batching autom√°tico
- React agrupa actualizaciones de estado dentro de eventos, promesas y efectos.
- √ötil para evitar renders extra.
	{% raw %}
```js
	setA(1)
	setB(2)
	// React lo agrupa en un √∫nico render
	```
{% endraw %}

### 1.3. Transiciones (useTransition)
- Permiten diferenciar:
	- Actualizaciones **urgentes** (ej: escribir en un input).
	- Actualizaciones **no urgentes** (filtrar lista grande).
- Evita que la UI se bloquee.
	{% raw %}
```js
	const [isPending, startTransition] = useTransition()
	startTransition(() => setFilter(value))
	```
{% endraw %}

---

## 2. Persistencia y sincronizaci√≥n externa del estado

### 2.1. Efectos asincr√≥nicos con `useEffect`
- Se usan para **sincronizar React con sistemas externos**, no para calcular estado derivado.
- Casos comunes:
	- Subscribirse a APIs.
	- Conectar WebSockets.
	- Timers y observers.
	- Leer/escribir en `localStorage`.

### 2.2. Efectos bien dise√±ados
- Deben:
	- Declarar dependencias correctas.
	- Limpiar suscripciones en el return del efecto.
- Evitar:
	- Efectos redundantes por mala dependencia.
	- Guardar funciones o datos derivados en el estado.
	- Usar efectos para l√≥gica que pertenece al render.

### 2.3. Efectos no reactivos
- Usar `useEffectEvent` (nuevo API) para evitar capturar valores obsoletos sin re-trigger del efecto.
- √ötil en animaciones, listeners, integraciones.

---

## 3. Sincronizaci√≥n de referencias y el DOM (useRef, useLayoutEffect)

### 3.1. `useRef`
- Mantiene valores que **no causan render**.
- Casos:
	- Guardar timeouts.
	- Guardar valores previos.
	- Acceder a elementos del DOM.

### 3.2. `useLayoutEffect`
- Corre **antes del paint visual**, √∫til para medir elementos.
- Riesgo: bloquea la UI si se abusa.
- Ejemplo:
	- Lectura de tama√±o de un nodo.
	- Calcular posiciones previas a animaciones.

---

## 4. Patrones de renderizado avanzado

### 4.1. Keyed renders y reconciliaci√≥n
- React usa keys para:
	- Mantener estabilidad del estado.
	- Reordenar listas.
- Conceptos:
	- **Reconciling**: React intenta reusar nodos con la misma key.
	- Cambiar keys ‚Üí fuerza recreaci√≥n de sub√°rboles completos.
- Buenas pr√°cticas:
	- Siempre usar IDs √∫nicos.
	- Evitar keys generadas por √≠ndice en listas din√°micas.

### 4.2. Memoizaci√≥n
- Evitar trabajos repetitivos:
	- `useMemo()` ‚Üí memoriza valores derivados.
	- `useCallback()` ‚Üí memoriza funciones y estabiliza props.
	- `React.memo()` ‚Üí memoriza componentes.
- Beneficios:
	- Menos renders.
	- Props estables para dependencias de efectos.

### 4.3. Cuando **NO** usar memoizaci√≥n
- Si la computaci√≥n no es costosa.
- Si el componente es peque√±o.
- Si genera m√°s complejidad que beneficio.

---

## 5. Patrones para estado global

### 5.1. Reducer + Context escalable
- Dividir:
	- `StateContext`
	- `DispatchContext`
- Evita renders excesivos en √°rboles grandes.
- Patr√≥n recomendado para:
	- Apps medianas.
	- L√≥gica compleja compartida.

### 5.2. Estado global con librer√≠as
Sin repetir nada visto anteriormente, estas librer√≠as introducen **conceptos nuevos**:

- **Zustand**
	- Estado global minimalista basado en *stores*.
	- Selectores para evitar renders innecesarios.

- **Jotai**
	- Estado basado en *√°tomos*, cada √°tomo maneja su propio renderizado.

- **Redux Toolkit**
	- Flujo unidireccional, reducers puros.
	- Concepto de *slices*, devtools y acciones serializables.

---

## 6. Suspense y carga as√≠ncrona

### 6.1. Suspense para datos
- React puede **pausar el render** hasta que un recurso est√© disponible.
- Se combina con:
	- loaders del router.
	- data-fetching reactivo.

### 6.2. Boundaries
- Permiten manejar errores y estados de carga en secciones espec√≠ficas del UI.
- Un error no tumba toda la app.

### 6.3. Streaming Server Rendering
- React puede enviar HTML en chunks.
- Comienza a renderizar antes de tener todos los datos.
- Especialmente √∫til en React Server Components (RSC).

---

## 7. Patrones de UI reactiva moderna (sin repetici√≥n de lo previo)

### 7.1. Sincronizar UI con m√°quina de estados ligera
- La UI sigue estados finitos:
	- `'idle'`
	- `'loading'`
	- `'loaded'`
	- `'error'`
- Reemplaza booleanos descoordinados.

### 7.2. Optimizaciones UI
- Evitar renders ‚Äúcascada‚Äù usando memoizaci√≥n selectiva.
- Dividir componentes grandes en subcomponentes puros.
- Preferir pasar valores derivados, no estructuras completas.

### 7.3. UI prediction
- React concurrent puede preparar pantallas ‚Äúen segundo plano‚Äù antes de mostrarlas.
- Minimiza flashes o saltos.

---

## 8. Testing del estado (conceptos nuevos)

### 8.1. Testear componentes con estado
- Renderizar el componente y simular eventos.
- Usar:
	- `@testing-library/react`
	- Interacci√≥n realista: `userEvent`

### 8.2. Testear reducers
- Reducers son funciones puras ‚Üí testear con inputs/outputs.
- No requiere montar el componente.

### 8.3. Testear efectos
- Mockear APIs externas.
- Asegurar limpieza correcta (`cleanup`).

---

## 9. Debugging y herramientas

### 9.1. React DevTools
- Inspeccionar:
	- √Årbol de componentes.
	- Estado actual.
	- Hooks.
	- Render reasons.
- ‚ÄúHighlight updates‚Äù para ver renders innecesarios.

### 9.2. Profiler
- Medir:
	- Tiempo de render.
	- Renders repetidos.
	- Componentes costosos.

---

## 10. Arquitectura recomendada para escalar estado

### 10.1. Estado local ‚Üí Reducer ‚Üí Context ‚Üí Librer√≠a global
Evoluci√≥n posible:
1. `useState`
2. `useReducer` en componentes con l√≥gica compleja
3. Reducer + Context para secciones de la app
4. Librer√≠a de estado para grandes aplicaciones

### 10.2. Separaci√≥n de dominios
- Estado UI.
- Estado de datos.
- Estado global de sesi√≥n.
- Estado derivado (no se almacena, se calcula).

### 10.3. Estado persistente
- Persistencia con:
	- localStorage.
	- IndexedDB.
	- Librer√≠as de *hydration* (Zustand persist, Jotai storage).


# React roadmap

## Recursos
- [roadmap](https://roadmap.sh/react)

---

## Resumen general del camino en React
- componentes y props
- vistas y JSX
- comunicaci√≥n entre componentes
- eventos
- hook `useState`
- hook `useEffect`
- ciclo de montaje y desmontaje
- HTTP y AJAX
- promesas, async/await, manejo de errores
- formularios, eventos y env√≠o a la vista
- router y navegaci√≥n
- rutas, subrutas y componentes anidados
- hooks, refs, memo, context
- validaci√≥n y formularios (Formik, React Hook Form)
- consumo de API REST
- stack MERN (Node + Express + Mongo)
- autenticaci√≥n con JWT

---

## Fundamentals
- Crear una React App (SPA)
- Function Components
- Class Components
- JSX
- Props
	- son **read-only**
	- un componente **no puede modificar sus props**
- State
	- permite cambiar la salida con el tiempo durante re-renders
- Hooks esenciales
	- `useState`
	- `useEffect`
	- manejo del ciclo de vida mediante hooks
- Conditional rendering
- Lists & Keys
- Formularios b√°sicos (controlled components)
- Composition vs Inheritance

---

## Advanced Topics
- HTTP Requests
	- contexto de petici√≥n y manejo de estados de carga
	- Context API para compartir datos
	- Refs para manipulaci√≥n de DOM o valores persistentes
	- Error Boundaries
	- Portals
- M√©todos GET, POST
- Hooks avanzados
	- `useContext`
	- `useReducer`
	- `useRef`
	- `useMemo`
	- `useCallback`
	- Custom Hooks
- Higher Order Components (HOC)
- Render Props
- Reconciliation (algoritmo de comparaci√≥n de React)

---

## Ecosystem

### State Management
- Redux
- MobX
- Recoil
- Apollo Client (GraphQL State Management + Cache)
- React Query / TanStack Query

### Routing
- React Router
- React Location

### Styling
- Styled Components
- Emotion
- Tailwind CSS
- Chakra UI
- Material UI
- Ant Design

### Forms
- Formik
- React Hook Form

### Testing
- Jest + React Testing Library
- Cypress

### Misc
- TypeScript
- Storybook para documentar componentes
- React i18Next (i18n)
- Firebase / Supabase (auth + backend as a service)
- Librer√≠as pr√°cticas:
	- data visualization (Recharts, Victory, Nivo)
	- drag & drop (dnd-kit, react-beautiful-dnd)
	- date pickers
	- skeleton loaders / shimmers
	- animaciones (Framer Motion, React Spring)

---

## Next Steps
- Gatsby (static site generation)
- Next.js (server rendering + RSC)
- Remix (full stack web framework)
- React Native (apps m√≥viles)


# Omnivore react

{% raw %}
```base
type: list
name: "Notas con #react en Omnivore"
order:
  - property: date_saved
    direction: desc
columns:
  - file.name
  - date_saved
filters:
  and:
    - file.inFolder("Omnivore")
    - file.hasTag("react", "React")
views:
  - type: table
    name: Table
    sort:
      - property: file.mtime
        direction: DESC

```
{% endraw %}
