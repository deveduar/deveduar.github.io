---
date: 2024-11-23 16:53
title: jasmine
keywords:
source:
status: ğŸŒŸ
Parent: "[[Area-Prog]]"
public_note: "true"
category: Testing
tags:
  - jasmine
  - testing
  - JS
  - unit-test
---
# Jasmine
``$= dv.current().file.tags.join(" ")``

- [Testing](/testing/testing/)
- docs
	- Your_first_suite-your_first_suite
---
## ğŸ§ª IntroducciÃ³n

**Jasmine** es un *framework de testing behavior-driven development (BDD)* para JavaScript, diseÃ±ado para realizar pruebas unitarias de manera sencilla, legible y sin dependencias externas. Es muy utilizado junto con Karma y otros entornos de integraciÃ³n continua dentro de flujos DevOps.

Su enfoque se basa en describir comportamientos esperados de una aplicaciÃ³n mediante bloques de cÃ³digo expresivos que facilitan la lectura y el mantenimiento de los tests.

## âš™ï¸ CaracterÃ­sticas Principales

- Sintaxis clara y natural basada en *describe* / *it*.
- No requiere DOM ni dependencias externas.
- Permite mocks, spies y aserciones integradas.
- Compatible con frameworks como Angular o librerÃ­as puras de JavaScript.
- IntegraciÃ³n con entornos de CI/CD y pipelines de DevOps.
- Soporta pruebas asincrÃ³nicas mediante callbacks, Promises y async/await.

## ğŸ§© Estructura BÃ¡sica de un Test

Cada test en Jasmine sigue una estructura jerÃ¡rquica de descripciones (*suites*) y especificaciones (*specs*).

### ğŸ“„ Ejemplo BÃ¡sico

{% raw %}
```javascript
describe("Calculadora", () => {
	it("deberÃ­a sumar correctamente", () => {
		const resultado = 2 + 3;
		expect(resultado).toBe(5);
	});

	it("deberÃ­a restar correctamente", () => {
		const resultado = 10 - 4;
		expect(resultado).toBe(6);
	});
});
```
{% endraw %}`

### ğŸ§  Conceptos Clave

* `describe()`: agrupa un conjunto de pruebas relacionadas.
* `it()`: define un test individual.
* `expect()`: define la expectativa o aserciÃ³n.
* *Matchers*: expresan la condiciÃ³n esperada (`toBe`, `toEqual`, `toContain`, `toThrow`, etc.).

## ğŸ” Matchers Comunes

| Matcher                          | DescripciÃ³n                                         |
| -------------------------------- | --------------------------------------------------- |
| `toBe(value)`                    | Compara por identidad (===).                        |
| `toEqual(value)`                 | Compara por valor.                                  |
| `toBeTruthy()` / `toBeFalsy()`   | EvalÃºa valores booleanos.                           |
| `toContain(item)`                | Verifica si un array o string contiene un elemento. |
| `toThrow()`                      | Espera una excepciÃ³n.                               |
| `toBeCloseTo(number, precision)` | Compara nÃºmeros flotantes.                          |

## ğŸ§° Spies y Mocks

Los **spies** permiten interceptar y observar llamadas a funciones, sin alterar su comportamiento original (a menos que se especifique).

{% raw %}
```javascript
describe("Spies en Jasmine", () => {
	it("deberÃ­a espiar una funciÃ³n", () => {
		const usuario = {
			saludar: (nombre) => `Hola ${nombre}`,
		};

		spyOn(usuario, "saludar");
		usuario.saludar("Eduardo");

		expect(usuario.saludar).toHaveBeenCalled();
		expect(usuario.saludar).toHaveBeenCalledWith("Eduardo");
	});
});
```
{% endraw %}

Los spies se pueden combinar con mÃ©todos como `and.returnValue()`, `and.callFake()` o `and.throwError()` para simular distintos comportamientos.

## â³ Tests AsincrÃ³nicos

Jasmine soporta tests con Promises, async/await o callbacks mediante la funciÃ³n `done()`.

{% raw %}
```javascript
it("deberÃ­a resolver una promesa correctamente", async () => {
	const resultado = await Promise.resolve("ok");
	expect(resultado).toBe("ok");
});
```
{% endraw %}

{% raw %}
```javascript
it("deberÃ­a ejecutar callback async", (done) => {
	setTimeout(() => {
		expect(true).toBeTrue();
		done();
	}, 100);
});
```
{% endraw %}

## ğŸ§® ConfiguraciÃ³n y EjecuciÃ³n

Los tests de Jasmine se pueden ejecutar en navegador o en Node.js.

* En entornos de frontend, suele integrarse con Karma.
* En Node.js, se puede instalar globalmente:

{% raw %}
```bash
npm install --save-dev jasmine
npx jasmine init
npx jasmine
```
{% endraw %}

Esto genera un archivo `spec/support/jasmine.json` con la configuraciÃ³n base.

## ğŸ§© IntegraciÃ³n con DevOps y CI/CD

* Puede integrarse en pipelines para ejecutar pruebas automÃ¡ticamente antes de despliegues.
* Compatible con entornos como GitHub Actions, Jenkins, GitLab CI o CircleCI.
* Los reportes pueden exportarse en formatos JUnit, JSON o HTML para anÃ¡lisis continuo.

## ğŸ”„ Pruebas de Componentes y Servicios (ejemplo con Angular)

En Angular, Jasmine se utiliza junto a TestBed para pruebas unitarias de componentes y servicios.

{% raw %}
```typescript
import { TestBed } from "@angular/core/testing";
import { UsuarioService } from "./usuario.service";

describe("UsuarioService", () => {
	let service: UsuarioService;

	beforeEach(() => {
		TestBed.configureTestingModule({});
		service = TestBed.inject(UsuarioService);
	});

	it("deberÃ­a crearse correctamente", () => {
		expect(service).toBeTruthy();
	});
});
```
{% endraw %}

## ğŸŒ Recursos

* [Your_first_suite](https://jasmine.github.io/tutorials/your_first_suite)
* [DocumentaciÃ³n Oficial de Jasmine](https://jasmine.github.io/)
* [Testing](/testing/testing/): conceptos y patrones generales
* Karma: integraciÃ³n y ejecuciÃ³n de tests
* DevOps: automatizaciÃ³n de pipelines de testing
* JavaScript: fundamentos del lenguaje en entorno de pruebas


# Jasmine - Conceptos Avanzados y Mejores PrÃ¡cticas

A continuaciÃ³n se amplÃ­an los temas no tratados en profundidad: *hooks del ciclo de vida, patrones de testing, configuraciÃ³n avanzada y estrategias de mantenimiento.*


## ğŸ” Ciclo de Vida de los Tests

Jasmine ofrece *hooks* que permiten preparar y limpiar el entorno antes y despuÃ©s de cada test o suite.

{% raw %}
```javascript
describe("Gestor de Usuarios", () => {
	let usuarios;

	beforeAll(() => {
		// Se ejecuta una vez antes de todos los tests
		usuarios = [];
	});

	beforeEach(() => {
		// Se ejecuta antes de cada test
		usuarios.push("nuevo");
	});

	afterEach(() => {
		// Limpieza tras cada test
		usuarios.pop();
	});

	afterAll(() => {
		// Se ejecuta una vez al finalizar todos los tests
		usuarios = null;
	});

	it("deberÃ­a agregar un usuario", () => {
		expect(usuarios.length).toBe(1);
	});
});
```
{% endraw %}`

Estos *hooks* son esenciales en pruebas con datos temporales, mocks o configuraciÃ³n global.

---

## ğŸ§± Estructura Escalable de Carpetas

Una estructura modular facilita el mantenimiento de test suites grandes.

{% raw %}
```
/tests
	/specs/
		usuario.spec.js
		auth.spec.js
		utils.spec.js
	/helpers/
		mock-data.js
		custom-matchers.js
	/setup/
		jasmine.json
		setupEnv.js
```
{% endraw %}

Recomendaciones:

* MantÃ©n un archivo `helpers/` con funciones o datos reutilizables.
* Crea *matchers* personalizados en `custom-matchers.js`.
* Centraliza la configuraciÃ³n del entorno de test (variables, spies globales, etc.) en `setupEnv.js`.

---

## ğŸ§© CreaciÃ³n de *Matchers* Personalizados

Jasmine permite extender su sistema de aserciones con *matchers* propios.

{% raw %}
```javascript
beforeEach(() => {
	jasmine.addMatchers({
		toBeEven: () => ({
			compare(actual) {
				const pass = actual % 2 === 0;
				return {
					pass,
					message: pass
						? `Esperaba que ${actual} no fuera par`
						: `Esperaba que ${actual} fuera par`,
				};
			},
		}),
	});
});

it("valida nÃºmeros pares", () => {
	expect(4).toBeEven();
});
```
{% endraw %}

Esto resulta Ãºtil para dominios especÃ­ficos (p. ej., validaciones de fechas, estructuras JSON, respuestas HTTP, etc.).

---

## âš¡ OptimizaciÃ³n de Pruebas AsincrÃ³nicas

### 1. Uso combinado de `done` y `setTimeout`

Evitar el bloqueo o falsos positivos.

{% raw %}
```javascript
it("maneja retrasos en respuestas", (done) => {
	fetch("/api/usuario").then((res) => {
		expect(res.status).toBe(200);
		done();
	});
});
```
{% endraw %}

### 2. Promises y `async/await`

MÃ¡s legibles y sin necesidad de `done()`.

{% raw %}
```javascript
it("valida respuesta API", async () => {
	const res = await fetch("/api/usuario");
	const data = await res.json();
	expect(data.nombre).toBeDefined();
});
```
{% endraw %}

---

## ğŸ§® PatrÃ³n â€œArrange, Act, Assertâ€ (AAA)

Organiza cada test en tres fases claras:

{% raw %}
```javascript
it("deberÃ­a calcular la suma correctamente", () => {
	// Arrange
	const a = 5;
	const b = 3;

	// Act
	const resultado = a + b;

	// Assert
	expect(resultado).toBe(8);
});
```
{% endraw %}

Ventajas:

* Claridad en la intenciÃ³n del test.
* Facilita refactorizaciÃ³n y lectura del cÃ³digo.

---

## ğŸ§° Mocks y Spies Combinados con *CallThrough*

Para observar una funciÃ³n **sin anular su comportamiento original**:

{% raw %}
```javascript
const servicio = {
	guardar: (item) => `Guardado: ${item}`,
};

spyOn(servicio, "guardar").and.callThrough();

it("ejecuta y espÃ­a simultÃ¡neamente", () => {
	const resultado = servicio.guardar("dato");
	expect(servicio.guardar).toHaveBeenCalled();
	expect(resultado).toBe("Guardado: dato");
});
```
{% endraw %}

---

## ğŸ§  Tests Parametrizados

Puedes iterar sobre mÃºltiples escenarios en una sola suite:

{% raw %}
```javascript
[
	{ input: 2, output: 4 },
	{ input: 3, output: 9 },
	{ input: 4, output: 16 },
].forEach((caso) => {
	it(`deberÃ­a calcular el cuadrado de ${caso.input}`, () => {
		expect(caso.input ** 2).toBe(caso.output);
	});
});
```
{% endraw %}

---

## ğŸ”¬ Cobertura de CÃ³digo con Istanbul (nyc)

Para medir quÃ© partes del cÃ³digo estÃ¡n cubiertas por tests:

{% raw %}
```bash
npm install --save-dev nyc
npx nyc jasmine
```
{% endraw %}

Esto genera un reporte en `/coverage`, Ãºtil en pipelines DevOps.

---

## ğŸ§© IntegraciÃ³n con Karma + Navegadores

`karma.conf.js` puede usar Jasmine como *framework base*:

{% raw %}
```javascript
frameworks: ["jasmine"],
files: ["src/**/*.js", "tests/**/*.spec.js"],
browsers: ["ChromeHeadless"],
reporters: ["progress", "kjhtml"],
```
{% endraw %}

Esto permite ejecutar los tests en entornos de navegador reales o headless (sin UI).

---

## ğŸ§± Buenas PrÃ¡cticas

* Usa nombres descriptivos: `it("deberÃ­a mostrar error si el email es invÃ¡lido")`.
* MantÃ©n los tests independientes entre sÃ­.
* Evita lÃ³gica compleja dentro de los tests.
* Reutiliza *fixtures* o *factories* para generar datos de prueba.
* Desactiva funciones de red o base de datos real mediante mocks.

---

## ğŸ§  Estrategias de Escalabilidad

En proyectos grandes:

* Agrupa suites por dominio funcional.
* Automatiza la ejecuciÃ³n con *watchers* (`npm run test:watch`).
* Integra en pipelines de despliegue continuo.
* Configura reportes HTML o JUnit para anÃ¡lisis visual o integraciÃ³n con herramientas como SonarQube.

---

## ğŸŒ Recursos Adicionales

* [Testing](/testing/testing/): Patrones y arquitecturas de pruebas.
* Karma: EjecuciÃ³n distribuida de tests en navegadores.
* DevOps: AutomatizaciÃ³n e integraciÃ³n en pipelines.
* JavaScript: Patrones modernos aplicados al testing.
* [Custom Matchers - Jasmine Docs](https://jasmine.github.io/tutorials/custom_matcher)
* [Best Practices for Jasmine Testing](https://jasmine.github.io/pages/docs_home.html)
# Jasmine - Casos Reales, Integraciones y Patrones Avanzados

$= dv.current().file.tags.join(" ")

## ğŸ§© Temas Pendientes y ExpansiÃ³n

En esta nota se profundiza en **aspectos no cubiertos previamente**:  
patrones avanzados, integraciÃ³n con frameworks modernos, pruebas de eventos, time mocking, seguridad en tests, depuraciÃ³n y uso en entornos hÃ­bridos (browser + Node.js).

---

## âš™ï¸ IntegraciÃ³n con Frameworks Modernos

### ğŸ”¹ Angular

Ya se mostrÃ³ un ejemplo bÃ¡sico, pero en entornos reales se combinan *Jasmine + TestBed* con *spy providers*:

{% raw %}
```typescript
import { TestBed } from "@angular/core/testing";
import { HttpClientTestingModule, HttpTestingController } from "@angular/common/http/testing";
import { UsuarioService } from "./usuario.service";

describe("UsuarioService", () => {
	let service: UsuarioService;
	let httpMock: HttpTestingController;

	beforeEach(() => {
		TestBed.configureTestingModule({
			imports: [HttpClientTestingModule],
			providers: [UsuarioService],
		});
		service = TestBed.inject(UsuarioService);
		httpMock = TestBed.inject(HttpTestingController);
	});

	it("deberÃ­a obtener lista de usuarios", () => {
		const mockUsuarios = [{ nombre: "Eduardo" }];

		service.obtenerUsuarios().subscribe((data) => {
			expect(data).toEqual(mockUsuarios);
		});

		const req = httpMock.expectOne("/api/usuarios");
		expect(req.request.method).toBe("GET");
		req.flush(mockUsuarios);
	});
});
```
{% endraw %}`

Esto demuestra cÃ³mo Jasmine puede integrarse profundamente en entornos de testing de componentes y servicios.

### ğŸ”¹ React

Aunque no es el estÃ¡ndar (donde se usa Jest), Jasmine puede funcionar con herramientas como Enzyme o Testing Library si se configura el entorno manualmente.

{% raw %}
```javascript
import React from "react";
import { render, screen } from "@testing-library/react";
import App from "./App";

describe("App Component", () => {
	it("renderiza el tÃ­tulo principal", () => {
		render(<App />);
		expect(screen.getByText(/Bienvenido/i)).toBeTruthy();
	});
});
```
{% endraw %}

---

## ğŸ•’ Time Mocking y Control del Tiempo

Jasmine permite **simular y manipular temporizadores**, Ãºtil para probar delays, intervalos y funciones dependientes de tiempo.

{% raw %}
```javascript
describe("Timers con Jasmine", () => {
	beforeEach(() => {
		jasmine.clock().install();
	});

	afterEach(() => {
		jasmine.clock().uninstall();
	});

	it("controla el tiempo con jasmine.clock()", () => {
		const callback = jasmine.createSpy("callback");

		setTimeout(callback, 1000);
		jasmine.clock().tick(1000);

		expect(callback).toHaveBeenCalled();
	});
});
```
{% endraw %}

---

## ğŸ” Tests de Eventos y DOM (sin navegador real)

En entornos de navegador simulado (por ejemplo con `jsdom`), Jasmine puede validar eventos sin depender de Karma:

{% raw %}
```javascript
describe("Eventos DOM", () => {
	it("detecta click en botÃ³n", () => {
		const button = document.createElement("button");
		let clicked = false;

		button.addEventListener("click", () => (clicked = true));
		button.click();

		expect(clicked).toBeTrue();
	});
});
```
{% endraw %}

---

## ğŸ§± Pruebas de IntegraciÃ³n entre MÃ³dulos

Jasmine tambiÃ©n puede orquestar pruebas entre diferentes capas (controladores, servicios, utilidades).

{% raw %}
```javascript
import { obtenerUsuario, formatearUsuario } from "../src/usuario";

describe("IntegraciÃ³n de mÃ³dulos", () => {
	it("deberÃ­a formatear el nombre del usuario correctamente", async () => {
		const usuario = await obtenerUsuario(1);
		const nombre = formatearUsuario(usuario);
		expect(nombre).toMatch(/^[A-Z]/);
	});
});
```
{% endraw %}

Estas pruebas no son unitarias, pero garantizan coherencia entre funciones interdependientes.

---

## ğŸ”’ Testing y Seguridad

### 1. ValidaciÃ³n de Inputs

{% raw %}
```javascript
describe("ValidaciÃ³n de inputs", () => {
	it("deberÃ­a rechazar valores inseguros", () => {
		const input = "<script>alert('xss')</script>";
		const resultado = sanitizar(input);
		expect(resultado).not.toContain("<script>");
	});
});
```
{% endraw %}

### 2. Mock de Tokens o Sesiones

{% raw %}
```javascript
beforeEach(() => {
	spyOn(localStorage, "getItem").and.returnValue("fake-token");
});
```
{% endraw %}

Evita exponer credenciales o datos reales en los tests.

---

## ğŸ§  PatrÃ³n *Given-When-Then* (Behavior-Driven)

Una extensiÃ³n del AAA, Ãºtil para documentaciÃ³n y claridad:

{% raw %}
```javascript
describe("Login de usuario", () => {
	it("deberÃ­a autenticar con credenciales vÃ¡lidas", () => {
		// Given
		const credenciales = { user: "admin", pass: "1234" };

		// When
		const resultado = login(credenciales);

		// Then
		expect(resultado).toBeTrue();
	});
});
```
{% endraw %}

Esto alinea los tests con el lenguaje del dominio y mejora la comunicaciÃ³n con equipos no tÃ©cnicos.

---

## ğŸ§© Mocking de MÃ³dulos Externos

Si tu cÃ³digo usa APIs o librerÃ­as externas, Jasmine puede reemplazarlas temporalmente:

{% raw %}
```javascript
import * as api from "../api";

describe("Mock de mÃ³dulos externos", () => {
	it("intercepta llamada externa", async () => {
		spyOn(api, "fetchData").and.returnValue(Promise.resolve({ ok: true }));

		const data = await api.fetchData();
		expect(data.ok).toBeTrue();
	});
});
```
{% endraw %}

---

## ğŸ” DepuraciÃ³n y Logs

Durante el desarrollo de tests complejos:

* Usa `console.log()` dentro de bloques `it()` (Jasmine no los bloquea).
* Usa `fit()` para ejecutar **solo un test**.
* Usa `fdescribe()` para ejecutar **solo una suite**.
* Usa `xit()` o `xdescribe()` para **ignorar temporalmente** tests.

{% raw %}
```javascript
fdescribe("Debugging activo", () => {
	it("solo este test se ejecuta", () => {
		console.log("Test en foco");
		expect(true).toBeTrue();
	});
});
```
{% endraw %}

---

## âš¡ IntegraciÃ³n con Node.js y ESM

Jasmine 5+ soporta mÃ³dulos ECMAScript nativamente:

{% raw %}
```bash
npm install jasmine --save-dev
npx jasmine --esm
```
{% endraw %}

Y permite `import/export` directamente:

{% raw %}
```javascript
import { sumar } from "../src/utils.js";

describe("Suma con ESM", () => {
	it("funciona con import/export", () => {
		expect(sumar(2, 2)).toBe(4);
	});
});
```
{% endraw %}

---

## ğŸ“¦ EjecuciÃ³n Paralela y OptimizaciÃ³n de Suites

En entornos grandes, Jasmine puede dividir suites en ejecuciones paralelas con herramientas externas (p. ej., `karma-parallel` o `jest-worker`):

* Mejora el rendimiento en pipelines CI.
* Reduce tiempos de feedback para los desarrolladores.
* Permite balancear la carga entre procesos o contenedores [Docker](/software%20engineering/docker/).

---

## ğŸ§® IntegraciÃ³n con DevOps Metrics y Reportes

* GeneraciÃ³n automÃ¡tica de reportes HTML, JSON o JUnit.
* IntegraciÃ³n con dashboards de calidad de cÃ³digo (SonarQube, Codecov, GitHub Actions).
* ConfiguraciÃ³n de *thresholds* de cobertura mÃ­nima:

{% raw %}
```bash
npx nyc --check-coverage --lines 80 --functions 85 --branches 70 jasmine
```
{% endraw %}

Esto obliga a mantener una cobertura mÃ­nima en el proyecto antes del merge.

---

## ğŸ§­ Estrategias de MigraciÃ³n

### De Jasmine a Jest (o viceversa)

* Los *matchers* y estructura son casi idÃ©nticos.
* Spies â†’ `jest.fn()`
* Jasmine â†’ mejor para entornos legacy o Angular.
* Jest â†’ preferido en ecosistemas modernos y monorepos.

Ejemplo de conversiÃ³n rÃ¡pida:

{% raw %}
```javascript
// Jasmine
spyOn(servicio, "getData").and.returnValue(of("ok"));

// Jest
jest.spyOn(servicio, "getData").mockReturnValue(of("ok"));
```
{% endraw %}

---

## ğŸ§° Recomendaciones Finales

* MantÃ©n suites cortas (<50 tests por archivo).
* Evita mocks excesivos (solo cuando sea necesario).
* Mide la *flakiness* (tests intermitentes) en CI.
* Documenta los *matchers* personalizados.
* Usa Jasmine no solo como herramienta de validaciÃ³n, sino como especificaciÃ³n viva del sistema.

---

## ğŸŒ Recursos Relacionados

* [Testing](/testing/testing/) â€“ Estrategias de diseÃ±o y mantenimiento.
* Karma â€“ EjecuciÃ³n distribuida y reporter plugins.
* DevOps â€“ IntegraciÃ³n continua y monitoreo de calidad.
* JavaScript â€“ Buenas prÃ¡cticas y patrones.
* [Jasmine Clock API Docs](https://jasmine.github.io/api/edge/Clock.html)
* [Testing Library Integration](https://testing-library.com/docs/ecosystem-jasmine/)



