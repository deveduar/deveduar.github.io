---
date: 2024-11-16 20:39
title: csharp
tags:
  - CSharp
  - cpp
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Software engineering
public_note: "true"
category: Software engineering
---
# csharp
`$= dv.current().file.tags.join(" ")`

## Ecosistema y contexto
- GameDev
	- Uso de C# en motores como Unity y frameworks de simulaci√≥n.
	- Integraci√≥n con gr√°ficos, f√≠sicas, scripting y tooling.
- [net](/software%20engineering/net/)
	- Plataforma principal de ejecuci√≥n (.NET, .NET Core, .NET 6+).
	- CLR, gesti√≥n de memoria, JIT, AOT y librer√≠as base.
- [cpp](/software%20engineering/cpp/)
	- Comparativa frecuente: rendimiento, control de memoria y casos h√≠bridos (interop C++/CLI, P/Invoke).
	- Escenarios donde C# act√∫a como capa de alto nivel.


## Lenguaje C#
- Tipado est√°tico fuerte con inferencia (`var`).
- Programaci√≥n orientada a objetos: clases, interfaces, herencia, polimorfismo.
- Programaci√≥n funcional:
	- Expresiones lambda, LINQ, inmutabilidad parcial.
	- Delegados, `Func<>`, `Action<>`, `Predicate<>`.
- Programaci√≥n as√≠ncrona:
	- `async/await`, `Task`, `ValueTask`.
	- Paralelismo con `Parallel`, `TPL` y `async streams`.
- Gesti√≥n de memoria:
	- Garbage Collector, generaciones, LOH.
	- `IDisposable`, `using`, patrones de liberaci√≥n.
- Seguridad y robustez:
	- Manejo de excepciones.
	- Tipos `nullable`, `Span<T>`, `ReadOnlySpan<T>`.

## Plataforma .NET
- Runtime:
	- CLR, ejecuci√≥n administrada y optimizaciones.
	- JIT vs AOT.
- Librer√≠as:
	- BCL, System.*, colecciones, IO, networking.
- Compatibilidad:
	- Multiplataforma (Windows, Linux, macOS).
	- Contenedores y despliegue cloud.

## Arquitectura y patrones
- Principios SOLID:
	- Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion.
- Inyecci√≥n de dependencias:
	- `IServiceCollection`, `ServiceProvider`.
	- Ciclos de vida: transient, scoped, singleton.
- Patrones de dise√±o comunes:
	- Factory, Singleton, Adapter, Decorator.
	- Repository y Unit of Work.
- Patron Strategy
	- Encapsula algoritmos intercambiables bajo una interfaz com√∫n.
	- Elimina condicionales complejos (`if/else`, `switch`).
	- Favorece extensibilidad y pruebas unitarias.
	- Recurso: [Mejora tu C√≥digo Eliminando IFs con el Patr√≥n Strategy - YouTube](https://youtu.be/cBdKQqIjXkk)

## Desarrollo de aplicaciones
- Consola y utilidades CLI.
- Aplicaciones de escritorio:
	- WPF, WinForms, MAUI.
- Web y APIs:
	- ASP.NET Core, Minimal APIs, MVC.
	- Middleware, filtros, autenticaci√≥n y autorizaci√≥n.
- Servicios:
	- Background services, workers, microservicios.
- Integraci√≥n:
	- REST, gRPC, mensajer√≠a (RabbitMQ, Kafka).

## Testing y calidad
- Pruebas unitarias:
	- xUnit, NUnit, MSTest.
- Mocking:
	- Moq, NSubstitute.
- Pruebas de integraci√≥n:
	- WebApplicationFactory, TestContainers.
- Calidad de c√≥digo:
	- Analyzers, StyleCop, Sonar.
	- Refactoring continuo.

## Herramientas
- CLI:
	- `dotnet new`, `dotnet build`, `dotnet test`, `dotnet publish`.
- IDE:
	- Visual Studio, Visual Studio Code.
- Control de versiones:
	- Git, flujos de trabajo CI/CD.
- Observabilidad:
	- Logging (Serilog, NLog).
	- M√©tricas y tracing.


## Libros
- C-Sharp-10 Net6 Libro
	- Caracter√≠sticas modernas del lenguaje y runtime.
## C-sharp-visual studio-sdk-componentes
- Runtimes .NET
	- .NET 5 Runtime
		- Runtime unificado posterior a .NET Core.
		- Uso en aplicaciones legacy recientes y transici√≥n hacia .NET 6+.
	- .NET Core 3.1 Runtime (LTS)
		- Versi√≥n de soporte extendido ampliamente usada en producci√≥n.
		- Base de muchas aplicaciones empresariales existentes.
- SDK y .NET Framework
	- .NET Framework 4.7.2
	- .NET Framework 4.7.1
	- .NET Framework 4.7
	- .NET Framework 4.6.2
	- .NET Framework 4.6.1
		- Necesarios para mantenimiento de aplicaciones WinForms/WPF cl√°sicas.
		- Compatibilidad con librer√≠as antiguas y sistemas heredados.
- Windows SDK
	- Windows 10 SDK
		- Versi√≥n 10.0.20
		- Versi√≥n 10.0.18
		- APIs Win32, UWP, acceso a sistema, drivers y tooling nativo.
	- Windows 11 SDK
		- Versi√≥n 10.0.22
		- Soporte para caracter√≠sticas modernas del sistema operativo.
- Integraci√≥n con Visual Studio
	- Compiladores Roslyn y an√°lisis est√°tico.
	- Debugger administrado y mixto (managed/unmanaged).
	- Herramientas de profiling, diagn√≥sticos y testing.
	- Extensibilidad mediante el SDK de Visual Studio.

## C-sharp-comandos
- Creaci√≥n de proyectos
	- `dotnet new console`
		- Genera un proyecto de consola con la versi√≥n por defecto del SDK.
	- `dotnet new console -f net6.0`
		- Crea un proyecto apuntando expl√≠citamente a .NET 6.
	- `dotnet new classlib`
		- Crea una librer√≠a de clases reutilizable.
	- `dotnet new xunit`
		- Inicializa un proyecto de pruebas unitarias con xUnit.
- Ejecuci√≥n y configuraci√≥n
	- `dotnet run`
		- Compila y ejecuta el proyecto activo.
	- `dotnet run --configuration Release`
		- Ejecuta usando configuraci√≥n optimizada para producci√≥n.
	- `dotnet run --configuration Debug`
		- Ejecuta con s√≠mbolos de depuraci√≥n.
- Paso de argumentos
	- `dotnet run firstarg second-arg third:arg "fourth arg"`
		- Demuestra c√≥mo se reciben argumentos desde l√≠nea de comandos.
	- `dotnet run red yellow 50`
		- Uso t√≠pico para pruebas de l√≥gica basada en par√°metros.
- Ayuda y exploraci√≥n
	- `dotnet help new`
		- Muestra documentaci√≥n general del comando new.
	- `dotnet new console -h`
		- Ayuda espec√≠fica para la plantilla console.
- Gesti√≥n de dependencias
	- `dotnet add package`
		- A√±ade paquetes NuGet al proyecto.
	- `dotnet add reference`
		- Agrega referencia a otro proyecto dentro de la soluci√≥n.
- Compilaci√≥n
	- `dotnet build`
		- Compila el proyecto sin ejecutarlo.
		- √ötil en pipelines CI/CD.
- Convenciones y ejemplos
	- dev_1
		- Identificador de entorno o perfil de desarrollo.
	- desarrollador1
		- Ejemplo de usuario o configuraci√≥n local para pruebas.

# curso-C-NET Tutorial Hello World in 5 minutes

## CLI dotnet ‚Äî visi√≥n general
- Herramienta principal para crear, compilar y ejecutar aplicaciones .NET.
- Funciona de forma multiplataforma (Windows, Linux, macOS).
- Centraliza gesti√≥n de SDKs, runtimes y plantillas de proyecto.

## CLI dotnet ‚Äî uso b√°sico
### Comando dotnet
{% raw %}
```bash
Usage: dotnet [options]
Usage: dotnet [path-to-application]

Options:
-h|--help         Display help.
--info            Display .NET information.
--list-sdks       Display the installed SDKs.
--list-runtimes   Display the installed runtimes.

path-to-application:
The path to an application .dll file to execute.
```
{% endraw %}`

- `--info`
    - Muestra informaci√≥n detallada del entorno .NET.
    - √ötil para diagn√≥stico y soporte.
- `--list-sdks`
    - Enumera los SDKs instalados en el sistema.
- `--list-runtimes`
    - Lista los runtimes disponibles para ejecuci√≥n.

## Crear tu primera aplicaci√≥n

### Creaci√≥n del proyecto

{% raw %}
```bash
dotnet new console -o MyApp
cd MyApp
```
{% endraw %}

- `dotnet new console`
    - Crea una aplicaci√≥n de consola usando la plantilla est√°ndar.
- `-o MyApp`
    - Genera un directorio llamado `MyApp`.
    - Inicializa los archivos necesarios del proyecto.
- `cd MyApp`
    - Cambia el directorio de trabajo al proyecto reci√©n creado.

## Estructura del proyecto

- Carpeta `MyApp`
    - `MyApp.csproj`
        - Archivo de proyecto.
        - Define el framework objetivo, dependencias y configuraci√≥n.
    - `Program.cs`
        - Punto de entrada de la aplicaci√≥n.
        - Contiene el m√©todo principal impl√≠cito (top-level statements).

## C√≥digo inicial

### Program.cs ‚Äî Hello World

{% raw %}
```csharp
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");
```
{% endraw %}

- Uso de _top-level statements_.
- No es necesario definir expl√≠citamente `Main`.
- Ideal para ejemplos r√°pidos y scripts.

## Ejecutar la aplicaci√≥n

### Ejecuci√≥n b√°sica

{% raw %}
```bash
dotnet run
```
{% endraw %}

- Compila el proyecto si es necesario.
- Ejecuta el binario resultante.
- Usa la configuraci√≥n `Debug` por defecto.

## Edici√≥n del c√≥digo

### Program.cs ‚Äî versi√≥n extendida

{% raw %}
```csharp
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");
Console.WriteLine("The current time is " + DateTime.Now);
```
{% endraw %}

- Introduce el uso de la clase `DateTime`.
- Ejemplo de concatenaci√≥n de strings.
- Demuestra ejecuci√≥n secuencial de instrucciones.

## Errores comunes y soluciones

- Error de permisos:
    - Mensaje t√≠pico:
        - `Template "Console Application" could not be created. Access to the path 'C:\Windows\System32\MyApp' is denied.`
    - Soluci√≥n:
        - Cambiar a un directorio con permisos de escritura.
        - Ejemplo: `Documents`, `Desktop` o una carpeta de trabajo.
- SDK no encontrado:
    - S√≠ntoma:
        - Windows no detecta un SDK instalado.
    - Causa:
        - Variable de entorno `PATH` mal configurada.
    - Recurso:
        - [Windows can't find the latest installed .NET SDK](https://stackoverflow.com/questions/67049414/windows-cant-find-the-latest-installed-net-sdk/67049415#67049415)
- Diagn√≥stico adicional:
    - Ejecutar `dotnet --info`.
    - Verificar `--list-sdks` y `--list-runtimes`.

# c sharp curso intro

## Recursos del curso
- [Curso Completo de C# para Principiantes (2021) üöÄ](https://www.youtube.com/watch?v=TqiysLEBZo4)
- [Repositorio del curso en GitHub](https://github.com/lucasmoy-dev/Curso-de-C-Sharp)

## Temario cubierto
- Hola mundo
- Tipos de datos
- Arrays
- Funciones y eventos
- Windows Forms Apps
- Control de flujo (if, while, do while, for)

## Fundamentos del lenguaje
- Tipado fuerte
	- Cada variable tiene un tipo definido expl√≠citamente.
	- El tipo se asigna en el momento de la creaci√≥n y no puede cambiar.
- Inferencia limitada
	- Aunque se use inferencia (`var`), el tipo queda fijado en la primera asignaci√≥n.
- Compilaci√≥n
	- Los errores de tipo se detectan antes de ejecutar el programa.

## Windows Forms Apps
- Modelo de programaci√≥n orientado a eventos.
- El flujo de ejecuci√≥n depende de acciones del usuario.
- Componentes comunes:
	- Button ‚Üí ejecuta c√≥digo al hacer click.
	- Label ‚Üí muestra informaci√≥n.
	- TextBox ‚Üí entrada de datos del usuario.
- Los m√©todos como `button1_Click` son manejadores de eventos.

## Ejemplo: variables string y concatenaci√≥n
### C√≥digo ‚Äî strings y Label
{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	string prueba = "Prueba de variable";
	string prueba2 = "Prueba " + "de " + "concatenacion " + prueba;
	prueba2 = "otra cosa";
	label1.Text = prueba2;
}
```
{% endraw %}`

- El operador `+` concatena cadenas.
- Las variables pueden reasignarse cuantas veces sea necesario.
- El texto del `Label` se actualiza din√°micamente.

## Ejemplo: tipos num√©ricos

### C√≥digo ‚Äî int y double

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	int numero = 123;
	double numeroDecimal = 5000.28;

	string prueba = "Prueba de variable: " + numeroDecimal;
	label1.Text = prueba;
}
```
{% endraw %}

- `int` almacena n√∫meros enteros.
- `double` almacena n√∫meros decimales con mayor precisi√≥n.
- Al concatenar con un string, el n√∫mero se convierte autom√°ticamente a texto.

## Operador resto (%)

- Devuelve el resto de una divisi√≥n entera.
- Uso t√≠pico:
    - `x % 2 == 0` ‚Üí n√∫mero par.
    - `x % 5 == 0` ‚Üí m√∫ltiplo de 5.
- Muy usado en validaciones y control de flujo.

## Errores comunes con tipos num√©ricos

- Desbordamiento (_overflow_):
    - `byte` solo admite valores entre 0 y 255.
    - Si se suma m√°s all√° del l√≠mite, el valor vuelve a empezar desde 0.
- Subdesbordamiento:
    - Tipos como `short` vuelven al valor m√°ximo al restar por debajo del m√≠nimo.
- Estos errores pueden pasar desapercibidos si no se validan los rangos.
    

## Suma y concatenaci√≥n

- Regla clave:
    - Si el primer operando es texto, toda la expresi√≥n se eval√∫a como texto.
- El orden de los operandos afecta al resultado.
- Ejemplo conceptual:
    - `"Resultado: " + 5 + 5` ‚Üí `"Resultado: 55"`
    - `5 + 5 + " Resultado"` ‚Üí `"10 Resultado"`

## Booleanos y condicionales

- El tipo `bool` solo admite:
    - `true`
    - `false`
- Se obtiene a partir de expresiones l√≥gicas.
- Muy usado en estructuras `if`.

### C√≥digo ‚Äî if simple

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	int edad = 17;
	bool esMayorDeEdad = edad >= 18;

	label1.Text = "El usuario es menor de edad";
	if (esMayorDeEdad)
	{
		label1.Text = "El usuario es mayor de edad";
	}
}
```
{% endraw %}

- El `if` ejecuta el bloque solo si la condici√≥n es verdadera.

### C√≥digo ‚Äî if / else

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	int edad = 17;
	bool esMayorDeEdad = edad >= 18;

	if (esMayorDeEdad)
	{
		label1.Text = "El usuario es mayor de edad";
	}
	else
	{
		label1.Text = "El usuario es menor de edad";
	}
}
```
{% endraw %}

- El `else` cubre el caso contrario.
- Evita duplicar l√≥gica innecesaria.
    

## Formularios ‚Äî renombrar controles

- Buenas pr√°cticas de nombres:
    - `label1` ‚Üí `lblResultado`
    - `textBox1` ‚Üí `txtEdad`
- Ventajas:
    - C√≥digo m√°s legible.
    - Menos errores al mantener formularios grandes.
    - El dise√±ador de Visual Studio actualiza el c√≥digo autom√°ticamente.

## Conversi√≥n de texto a n√∫mero

- Todo lo que viene de un `TextBox` es `string`.
- Es obligatorio convertir antes de operar con n√∫meros.

### C√≥digo ‚Äî Parse de string a int

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	string textoEdad = txtEdad.Text;
	int edad = Int32.Parse(textoEdad);
	bool esMayorDeEdad = edad >= 18;

	if (esMayorDeEdad)
	{
		lblResultado.Text = "El usuario es mayor de edad";
	}
	else
	{
		lblResultado.Text = "El usuario es menor de edad";
	}
}
```
{% endraw %}

- Riesgo:
    - Si el texto no es num√©rico, el programa falla.
- Alternativa recomendada:
    - `Int32.TryParse` para validar sin excepciones.

## Comentarios

- Comentarios de l√≠nea:
    - `// comentario`
- Comentarios de bloque:
    - `/* comentario */`
- No afectan a la ejecuci√≥n del programa.
- √ötiles para documentaci√≥n y mantenimiento.

## Calculadora de √çndice de Masa Corporal (IMC)

### C√≥digo ‚Äî c√°lculo IMC

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	string textoPeso = txtPeso.Text;
	double peso = Double.Parse(textoPeso);

	string textoAltura = txtAltura.Text;
	double altura = Double.Parse(textoAltura);

	double imc = peso / (altura * altura);
	MessageBox.Show("El imc es " + imc);
}
```
{% endraw %}

- Ejemplo completo de:
    - Entrada de datos.
    - Conversi√≥n de tipos.
    - Operaciones matem√°ticas.
    - Salida visual.

## Arrays y errores t√≠picos

- Un array tiene tama√±o fijo.
- Las posiciones empiezan en 0.
- Error com√∫n:
    - Acceder a un √≠ndice fuera del rango.
- Consecuencia:
    
    - Excepci√≥n en tiempo de ejecuci√≥n.

## Bucle while

- Eval√∫a la condici√≥n antes de ejecutar el bloque.
- Si la condici√≥n es falsa al inicio, no se ejecuta.
- Requiere siempre una condici√≥n booleana.
- Error com√∫n:
    - `while (true)` sin ruptura ‚Üí bucle infinito.

## Bucle do while

- Ejecuta el c√≥digo antes de comprobar la condici√≥n.
- Garantiza al menos una ejecuci√≥n.
- √ötil cuando la l√≥gica debe ejecutarse una vez como m√≠nimo.

## Bucle for

- Pensado para contadores.
- Ideal cuando se conoce el n√∫mero de repeticiones.
- Estructura:
    - Inicializaci√≥n.
    - Condici√≥n.
    - Incremento.

### C√≥digo ‚Äî for con List

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	List<int> lista = new List<int>();
	lista.Add(2);
	lista.Add(20);
	lista.Add(15);
	lista.Add(100);

	for (int i = 0; i < lista.Count; i++)
	{
		int numero = lista[i];
		MessageBox.Show("El numero es: " + numero);
	}
}
```
{% endraw %}

- `List<T>` es din√°mica.
- Permite a√±adir y quitar elementos en tiempo de ejecuci√≥n.

### C√≥digo ‚Äî array est√°tico

{% raw %}
```csharp
int[] listaDeItems = new int[] { 1, 2, 3, 4, 5 };
```
{% endraw %}

- Tama√±o fijo.
- M√°s simple, pero menos flexible que `List<T>`.
# c sharp Arrays multidimensionales

## Arrays multidimensionales
- Array bidimensional
	- Estructura en filas y columnas.
	- Conceptualmente es una tabla.
	- Ejemplo t√≠pico:
		- Archivo Excel (filas x columnas).
		- Escenario isom√©trico en videojuegos usando coordenadas `x, y`.
- Array multidimensional
	- Arrays anidados en m√°s de dos dimensiones.
	- Permite modelar espacios complejos.
	- Ejemplo:
		- Minecraft usando coordenadas `x, y, z` para mundo 3D.
- Casos de uso comunes
	- Mapas, tableros y grids.
	- Simulaciones espaciales.
	- Representaci√≥n de datos jer√°rquicos.

## Funciones y requerimientos de proyecto
- Objetivo t√≠pico:
	- Aplicar un descuento a un precio.
	- Mostrar el precio final al usuario.
- Concepto matem√°tico:
	- Regla de tres simple.
	- Ejemplo:
		- Precio: `40 ‚Üí x`
		- Porcentaje: `100% ‚Üí 20%`
		- El descuento se calcula proporcionalmente.

## Reutilizaci√≥n de funciones
- Ventajas
	- Evita duplicar c√≥digo.
	- Facilita mantenimiento y pruebas.
	- Permite dividir la l√≥gica en responsabilidades claras.
- Tipo de retorno
	- Define el dato que la funci√≥n devuelve.
	- Puede reutilizarse en otros m√©todos.
- Modificadores
	- `private`
		- Solo accesible dentro de la clase.
	- `public`
		- Accesible desde otras clases.

## Funci√≥n sin retorno (void)
### C√≥digo ‚Äî mostrar listado
{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	int[] listaDeItems = new int[] { 1, 2, 3, 4, 5 };

	List<int> lista = new List<int>();
	lista.Add(2);
	lista.Add(20);
	lista.Add(15);
	lista.Add(100);

	mostrarListado(lista);
}

private void mostrarListado(List<int> lista)
{
	for (int i = 0; i < lista.Count; i++)
	{
		int numero = lista[i];
		MessageBox.Show("El numero es: " + numero);
	}
}
```
{% endraw %}`

- La funci√≥n recibe datos como par√°metro.
- No devuelve informaci√≥n.
- Se utiliza solo para ejecutar una acci√≥n.

## Funci√≥n con retorno

### C√≥digo ‚Äî devolver listado cargado

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	List<int> lista = traerListado();
	mostrarListado(lista);
}

private List<int> traerListado()
{
	List<int> lista = new List<int>();
	lista.Add(2);
	lista.Add(20);
	lista.Add(15);
	lista.Add(100);
	return lista;
}

private void mostrarListado(List<int> lista)
{
	for (int i = 0; i < lista.Count; i++)
	{
		int numero = lista[i];
		MessageBox.Show("El numero es: " + numero);
	}
}
```
{% endraw %}

- La funci√≥n crea y devuelve un objeto.
- Permite separar la carga de datos del procesamiento.
- El valor retornado puede reutilizarse en m√∫ltiples lugares.

## Modo Debug y breakpoints

- Breakpoints
    - Puntos de parada en el c√≥digo.
    - Permiten detener la ejecuci√≥n en una l√≠nea espec√≠fica.
- Uso del debugger
    
    - `Start Debugging` o tecla `F5`.
    - La ejecuci√≥n se detiene al llegar al breakpoint.
- Inspecci√≥n de variables
    
    - Se pueden ver los valores actuales.
    - Ayuda a detectar errores l√≥gicos.
- Ejecuci√≥n paso a paso
    
    - `Step Over`
        - Avanza l√≠nea por l√≠nea sin entrar en funciones.
    - Permite entender el flujo real del programa.

## Ejercicio 1 ‚Äî n√∫mero mayor y menor

- Requerimiento
    - Cargar 3 n√∫meros.
    - Mostrar cu√°l es el mayor y cu√°l el menor.
- Estrategia
    
    - Tomar el primer n√∫mero como referencia.
    - Comparar y actualizar.

### C√≥digo ‚Äî mayor y menor

{% raw %}
```csharp
private void button2_Click(object sender, EventArgs e)
{
	int numero1 = Int32.Parse(textBox1.Text);
	int numero2 = Int32.Parse(textBox2.Text);
	int numero3 = Int32.Parse(textBox3.Text);

	int mayor = numero1;

	if (numero2 > mayor)
	{
		mayor = numero2;
	}
	if (numero3 > mayor)
	{
		mayor = numero3;
	}

	MessageBox.Show("El numero mayor es " + mayor);

	int menor = numero1;

	if (numero2 < menor)
	{
		menor = numero2;
	}
	if (numero3 < menor)
	{
		menor = numero3;
	}

	MessageBox.Show("El numero menor es " + menor);
}
```
{% endraw %}

- Uso de comparaciones simples.
- Evita condicionales innecesarios.
- C√≥digo claro y f√°cil de extender.

## Ejercicio 2 ‚Äî n√∫meros y promedio

- Requerimiento
    - Cargar 3 n√∫meros.
    - Calcular el promedio.
- F√≥rmula
    - `(n1 + n2 + n3) / 3`

### C√≥digo ‚Äî promedio b√°sico

{% raw %}
```csharp
int numero1 = Int32.Parse(textBox1.Text);
int numero2 = Int32.Parse(textBox2.Text);
int numero3 = Int32.Parse(textBox3.Text);

double promedio = (numero1 + numero2 + numero3);
promedio = promedio / 3;

MessageBox.Show("El numero promedio " + promedio);
```
{% endraw %}

### C√≥digo ‚Äî promedio usando casting

{% raw %}
```csharp
double promedio = (Double)(numero1 + numero2 + numero3) / 3;
```
{% endraw %}

- El casting fuerza la conversi√≥n a `double`.
- Evita la divisi√≥n entera.
- Permite obtener decimales correctamente.

## Ejercicio 3 ‚Äî n√∫mero par o impar

- Requerimiento
    - Ingresar un n√∫mero.
    - Determinar si es par o impar.
- M√©todo recomendado
    - Usar el operador resto `%`.

### C√≥digo ‚Äî par o impar con m√≥dulo

{% raw %}
```csharp
private void button2_Click(object sender, EventArgs e)
{
	int numero = Int32.Parse(textBox1.Text);

	if (numero % 2 == 0)
	{
		MessageBox.Show("El numero es par");
	}
	else
	{
		MessageBox.Show("El numero es impar");
	}
}
```
{% endraw %}

- Si el resto de dividir entre 2 es 0, el n√∫mero es par.
    

## Alternativa ‚Äî comprobaci√≥n con decimales

- Idea
    - Dividir entre 2.
    - Comprobar si el resultado es un n√∫mero entero.
- Limitaci√≥n
    - Menos clara y menos eficiente que `%`.

### C√≥digo ‚Äî par o impar con redondeo

{% raw %}
```csharp
private void button2_Click(object sender, EventArgs e)
{
	double numero = Int32.Parse(textBox1.Text);
	double resultado = numero / 2;

	if (resultado == Math.Round(resultado))
	{
		MessageBox.Show("El numero es par");
	}
	else
	{
		MessageBox.Show("El numero es impar");
	}
}
```
{% endraw %}

- `Math.Round` redondea al entero m√°s cercano.
- Comparaci√≥n √∫til para entender operaciones con decimales.
- No recomendada frente al uso de `%`.
# c sharp Ejercicio 4 ‚Äî Carrito de Compras
- Objetivo
	- Simular un carrito de compras b√°sico.
	- Permitir agregar productos.
	- Calcular el precio final.
	- Aplicar un 10% de descuento con un c√≥digo promocional.
- Productos disponibles
	- Pantal√≥n ‚Üí $20
	- Camiseta ‚Üí $35
	- Zapatos ‚Üí $24
- C√≥digo de promoci√≥n
	- `NAVIDAD`
	- Aplica un 10% de descuento sobre el total.

## Ciclo de vida del formulario
- Evento `Form1_Load`
	- Se ejecuta una sola vez al cargar el formulario.
	- Ideal para inicializar datos.
	- Se crea haciendo doble click en una zona vac√≠a del dise√±ador.
- Usos t√≠picos
	- Cargar combos.
	- Inicializar listas.
	- Preparar valores por defecto.

## Cargar productos en el ComboBox
### C√≥digo ‚Äî carga inicial del ComboBox
{% raw %}
```csharp
private void Form1_Load(object sender, EventArgs e)
{
	cboProductos.Items.Add("Pantalon");
	cboProductos.Items.Add("Camiseta");
	cboProductos.Items.Add("Zapatos");
}
```
{% endraw %}`

- `Items.Add`
    - A√±ade elementos al `ComboBox`.
- Los valores se almacenan como objetos.
- Visualmente se muestran como texto.

## Obtener el producto seleccionado

- `SelectedItem`
    - Devuelve un `object`.
    - Es necesario convertirlo a `string`.

### Conversi√≥n correcta

{% raw %}
```csharp
string productoSeleccionado = cboProductos.SelectedItem.ToString();
```
{% endraw %}

- Error com√∫n
    - Intentar asignar directamente a `string`.
- Soluci√≥n
    - Usar `ToString()`.

## Agregar producto al carrito

### C√≥digo ‚Äî bot√≥n Agregar

{% raw %}
```csharp
private void btnAgregar_Click(object sender, EventArgs e)
{
	string productoSeleccionado = cboProductos.SelectedItem.ToString();
	listCarritoDeCompras.Items.Add(productoSeleccionado);
}
```
{% endraw %}

- `ListBox` act√∫a como carrito.
- Cada item representa un producto agregado.
- Se pueden agregar productos repetidos.

## Contar productos en el carrito

- Propiedad:
    - `listCarritoDeCompras.Items.Count`
- Uso:
    - Determinar cu√°ntos productos hay.
    - Controlar bucles `for`.

## Recorrer el carrito

### C√≥digo ‚Äî recorrido inicial

{% raw %}
```csharp
private void btnCalcular_Click(object sender, EventArgs e)
{
	double precioFinal = 0;

	int totalProductosCargados = listCarritoDeCompras.Items.Count;

	for (int i = 0; i < totalProductosCargados; i++)
	{
		string productoElegido = listCarritoDeCompras.Items[i].ToString();
		MessageBox.Show(productoElegido);
	}
}
```
{% endraw %}

- Se accede a cada elemento por √≠ndice.
- Conversi√≥n necesaria a `string`.
- √ötil para depuraci√≥n y validaci√≥n inicial.

## C√°lculo del precio final

- Estrategia
    - Recorrer el carrito.
    - Identificar cada producto.
    - Sumar su precio correspondiente.
- Control mediante condicionales `if / else if`.

## C√≥digo de descuento

- Regla de tres simple
    - Total ‚Üí 100%
    - Descuento ‚Üí 10%
- Aplicaci√≥n pr√°ctica
    - 10% de descuento equivale a multiplicar por `0.9`.
- Ventaja
    - M√°s simple y legible que operaciones largas.

## C√°lculo completo con descuento

### C√≥digo ‚Äî c√°lculo del total y promoci√≥n

{% raw %}
```csharp
private void btnCalcular_Click(object sender, EventArgs e)
{
	// pantalon 20 $ camiseta 35 zapatos 24
	double precioFinal = 0;

	int totalProductosCargados = listCarritoDeCompras.Items.Count;

	for (int i = 0; i < totalProductosCargados; i++)
	{
		string productoElegido = listCarritoDeCompras.Items[i].ToString();

		if (productoElegido == "Pantalon")
		{
			precioFinal += 20;
		}
		else if (productoElegido == "Camiseta")
		{
			precioFinal += 35;
		}
		else if (productoElegido == "Zapatos")
		{
			precioFinal += 24;
		}
	}

	if (txtCodigoDescuento.Text == "NAVIDAD")
	{
		precioFinal = precioFinal * 0.9;
	}

	MessageBox.Show("El precio final es de: $" + precioFinal);
}
```
{% endraw %}

- Se eval√∫a cada producto individualmente.
- El descuento se aplica solo si el c√≥digo coincide.
- El c√°lculo final se muestra al usuario.

## Conceptos reforzados en el ejercicio

- Uso de eventos en Windows Forms.
- Manejo de `ComboBox` y `ListBox`.
- Conversi√≥n de tipos (`object` ‚Üí `string`).
- Recorridos con `for`.
- L√≥gica condicional.
- Aplicaci√≥n de descuentos con operaciones matem√°ticas simples.
# c sharp Ejercicio 5 ‚Äî 100 primeros n√∫meros primos
- Objetivo
	- Determinar si un n√∫mero es primo.
	- Generar y mostrar los primeros 100 n√∫meros primos.
- Definici√≥n de n√∫mero primo
	- Solo tiene dos divisores exactos:
		- 1
		- √âl mismo
	- Ejemplos:
		- Primos: 2, 3, 5, 7, 11, 13
		- No primo: 6 (divisible por 2 y 3)

## Estrategia para detectar si un n√∫mero es primo
- Idea principal
	- Probar si el n√∫mero es divisible por alg√∫n valor distinto de 1 y de s√≠ mismo.
- Optimizaci√≥n b√°sica
	- Empezar desde 2.
	- No comprobar 0 ni 1:
		- 0 no aporta informaci√≥n.
		- 1 es divisor de todos los n√∫meros.
- Herramienta clave
	- Operador resto `%`
		- Si `numero % i == 0`, entonces `i` es divisor.

## Comprobaci√≥n b√°sica de n√∫mero primo
### C√≥digo ‚Äî validar un n√∫mero primo
{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	double numero = 7;
	bool esNumeroPrimo = true;

	for (int i = 2; i < numero; i++)
	{
		if (numero % i == 0)
		{
			esNumeroPrimo = false;
		}
	}

	if (esNumeroPrimo)
	{
		MessageBox.Show("El numero: " + numero + " es primo");
	}
	else
	{
		MessageBox.Show("El numero: " + numero + " no es primo");
	}
}
```
{% endraw %}`

- Se asume inicialmente que el n√∫mero es primo.
- Si se encuentra alg√∫n divisor, se marca como no primo.
- El resultado se muestra mediante un mensaje.

## Reutilizaci√≥n de l√≥gica ‚Äî funci√≥n booleana

- Problema
    - El c√≥digo anterior solo muestra un mensaje.
    - No permite reutilizar el c√°lculo para otros n√∫meros.
- Soluci√≥n
    - Crear una funci√≥n que devuelva `bool`.
    - Separar l√≥gica de presentaci√≥n.

## Funci√≥n esPrimo

### C√≥digo ‚Äî funci√≥n reutilizable

{% raw %}
```csharp
private bool esNumeroPrimo(double numero)
{
	bool esPrimo = true;

	for (int i = 2; i < numero; i++)
	{
		if (numero % i == 0)
		{
			esPrimo = false;
		}
	}

	return esPrimo;
}
```
{% endraw %}

- El n√∫mero se recibe como par√°metro.
- No se declara dentro de la funci√≥n.
- Devuelve:
    - `true` si es primo.
    - `false` si no lo es.
- La variable interna se llama `esPrimo` para evitar confusi√≥n con el nombre de la funci√≥n.
    

## Generar los primeros 100 n√∫meros primos

- Estrategia
    - Empezar desde el n√∫mero 2.
    - Probar cada n√∫mero consecutivo.
    - Si es primo:
        - Guardarlo en el resultado.
        - Incrementar el contador.
    - Detener el proceso al llegar a 100 primos.

## Control del bucle

- Variables clave
    - `double numero`
        - N√∫mero que se va evaluando.
    - `int contador`
        - Cantidad de n√∫meros primos encontrados.
    - `string resultado`
        - Acumula los n√∫meros primos encontrados.
- Regla importante
    - El n√∫mero debe incrementarse siempre:
        - Sea primo o no.
        - Para evitar bucles infinitos.

## C√≥digo ‚Äî generar y mostrar 100 primos

{% raw %}
```csharp
private void button1_Click(object sender, EventArgs e)
{
	string resultado = "";
	double numero = 2;
	int contador = 0;

	while (contador < 100)
	{
		if (esNumeroPrimo(numero))
		{
			resultado = resultado + "," + numero;
			contador++;
		}

		numero++;
	}

	MessageBox.Show(resultado);
}
```
{% endraw %}

- El `while` se controla con el contador de primos.
- `numero` aumenta en cada iteraci√≥n.
- Solo cuando el n√∫mero es primo se incrementa el contador.
- El resultado final contiene los primeros 100 n√∫meros primos.

## Uso del debugger

- Breakpoints
    - Permiten detener la ejecuci√≥n en una l√≠nea concreta.
    - √ötiles para entender el flujo del programa.
- Qu√© observar
    - Valor de `numero`.
    - Valor de `contador`.
    - Evoluci√≥n de `resultado`.
- Flujo t√≠pico de depuraci√≥n
    - Colocar breakpoint en la inicializaci√≥n del resultado.
    - Ejecutar con `F5`.
    - Avanzar paso a paso para ver c√≥mo se generan los primos.

## Conceptos reforzados en esta parte

- Operador m√≥dulo `%`.
- Bucles `for` y `while`.
- Funciones con retorno booleano.
- Separaci√≥n de l√≥gica y presentaci√≥n.
- Control de bucles y prevenci√≥n de infinitos.
- Uso del debugger para an√°lisis de flujo.
# c sharp POO ‚Äî teor√≠a

## POO ‚Äî teor√≠a (Programaci√≥n Orientada a Objetos)

La Programaci√≥n Orientada a Objetos busca modelar el software a partir de entidades del mundo real, encapsulando datos y comportamientos, y facilitando la reutilizaci√≥n y extensi√≥n del c√≥digo.

### Pilares de la POO
- Herencia
- Abstracci√≥n
- Polimorfismo
- Encapsulamiento

---

## Comparaci√≥n: Programaci√≥n estructurada vs POO

### Programaci√≥n estructurada
- Uso intensivo de:
	- Arrays (incluyendo arrays multidimensionales)
	- √çndices
	- Funciones independientes
- Los datos y la l√≥gica est√°n separados.
- Ejemplo t√≠pico
	- Un sistema de registro de empleados:
		- Array para nombres
		- Array para apellidos
		- Array para salarios
		- Funci√≥n para cargar datos
- Problema principal
	- Si se desea agregar otra entidad (por ejemplo, clientes):
		- Se deben crear nuevos arrays.
		- Se repite c√≥digo.
		- Aumenta la complejidad y el riesgo de errores.

### Programaci√≥n Orientada a Objetos (POO)
- El sistema se modela usando clases.
- Cada clase representa un concepto:
	- Empleado
	- Cliente
	- Persona
- Ventajas
	- Reutilizaci√≥n de c√≥digo.
	- Extensibilidad.
	- Mejor organizaci√≥n.
	- Menor duplicaci√≥n de l√≥gica.

---

## Clases, objetos y archivos

- Clase
	- Es un molde o plantilla.
	- Contiene:
		- Propiedades (variables).
		- M√©todos (funciones).
- Objeto
	- Es una instancia concreta de una clase.
- Buenas pr√°cticas
	- Cada clase en su propio archivo.
	- Mejora la legibilidad y el mantenimiento del proyecto.

---

## Herencia

- Permite que una clase herede propiedades y m√©todos de otra.
- Ejemplo conceptual
	- Clase base: Persona
	- Clases derivadas:
		- Empleado
		- Cliente
- Beneficios
	- Evita duplicar atributos comunes:
		- Nombre
		- Apellido
		- Email
		- Tel√©fono

### Clase abstracta
- Se utiliza como base.
- No se instancia directamente.
- Sirve para definir caracter√≠sticas comunes.
- Ejemplo
	- Persona es abstracta.
	- Solo se crean objetos de:
		- Empleado
		- Cliente

---

## Polimorfismo

- Significa ‚Äúmuchas formas‚Äù.
- Permite que distintos objetos respondan de forma diferente al mismo m√©todo.

### Caso pr√°ctico
- En lugar de usar:
	- Un array de empleados.
	- Un array de clientes.
- Se utiliza:
	- Un solo array del tipo Persona.

### M√©todo com√∫n
- `ToString()`
	- Devuelve un texto con la informaci√≥n del objeto.
- Comportamiento seg√∫n el tipo
	- Cliente:
		- Nombre
		- Apellido
		- Email
		- Tel√©fono
	- Empleado:
		- Nombre
		- Apellido
		- Email
		- Tel√©fono
		- Salario
- Resultado
	- Una √∫nica funci√≥n.
	- Diferente resultado seg√∫n la clase concreta.
	- Se logra polimorfismo mediante sobrescritura de m√©todos.

---

## Encapsulamiento

- Principio fundamental
	- Ocultar el estado interno del objeto.
- Control de acceso
	- `public`
		- Accesible desde cualquier parte del c√≥digo.
	- `protected`
		- Accesible desde la propia clase y sus clases hijas.
	- `private`
		- Accesible solo dentro de la misma clase.
- Objetivo
	- Evitar modificaciones no controladas.
	- Proteger la integridad de los datos.

### Interacci√≥n con el objeto
- Toda interacci√≥n debe hacerse mediante m√©todos.
- La clase act√∫a como una ‚Äúcaja negra‚Äù.
- Se controla:
	- Qu√© se puede leer.
	- Qu√© se puede modificar.
	- Bajo qu√© condiciones.

### Getters y setters
- Permiten:
	- Leer valores.
	- Modificar valores con validaciones.
- Ejemplo conceptual
	- Evitar asignar edades negativas.
	- Controlar formatos de email.
	- Validar salarios m√≠nimos.

---

## Sistema de gesti√≥n de clientes (WinForms)

### Organizaci√≥n del proyecto
- Agregar un nuevo formulario
	- Click derecho sobre el nombre del proyecto.
	- Agregar ‚Üí Formulario de Windows Forms.
- Renombrar archivos
	- `GestionClientes.cs`
	- Renombrar `Form1` a `Menu.cs`
- Interfaz inicial
	- Bot√≥n:
		- Texto: Gestionar clientes

---

## Creaci√≥n y uso de formularios como objetos

- Una ventana tambi√©n es un objeto.
- Ejemplo de variable com√∫n
{% raw %}
```csharp
string nombre = "nombreeee";
```
{% endraw %}`

- Crear una instancia de un formulario

{% raw %}
```csharp
GestionClientes ventanaGestionClientes = new GestionClientes();
```
{% endraw %}

- Mostrar el formulario

{% raw %}
```csharp
ventanaGestionClientes.ShowDialog();
```
{% endraw %}

### Detalle sobre `string`

- Estas dos formas son equivalentes:

{% raw %}
```csharp
string nombre = "nombreeee";
string nombre = new string("nombreeee");
```
{% endraw %}

- El lenguaje simplifica la creaci√≥n de objetos muy usados.
- `string` es una clase, aunque se use con sintaxis abreviada.

---

## Orden de ejecuci√≥n y ventanas

- Problema habitual
    - El orden de ejecuci√≥n de los formularios afecta al flujo del programa.
- `ShowDialog()`
    - Abre la ventana de forma modal.
    - Bloquea la ventana anterior hasta que se cierre.
- Importancia
    - Controlar qu√© ventana se abre primero.
    - Evitar conflictos entre formularios.
    - Mantener una navegaci√≥n clara en la aplicaci√≥n.

---

## Conceptos clave reforzados en esta parte

- Diferencias entre programaci√≥n estructurada y POO.
- Clases, objetos e instancias.
- Herencia y clases abstractas.
- Polimorfismo mediante m√©todos comunes.
- Encapsulamiento y control de acceso.
- Formularios como objetos en WinForms.
- Organizaci√≥n y flujo de ejecuci√≥n del proyecto.

# Temarios de cursos de C#

## Temario estructural unificado (Super-temario)
Este **super-temario** re√∫ne los temas comunes y principales de distintos cursos de C# disponibles en internet, organizados por niveles desde b√°sico hasta avanzado. Est√° pensado como √≠ndice maestro para estudio, comparaci√≥n de cursos o creaci√≥n de notas en Obsidian.

---

## 1) Introducci√≥n a C# y .NET
- ¬øQu√© es C#? Historia y caracter√≠sticas
- La plataforma .NET
	- CLR (Common Language Runtime)
	- .NET Framework
	- .NET Core
	- .NET 5 / 6 / 7 / 8
- Herramientas de desarrollo
	- Visual Studio
	- Visual Studio Code
	- .NET CLI (`dotnet`)
- Estructura b√°sica de un programa C#
- Compilaci√≥n y ejecuci√≥n de aplicaciones

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/
- https://learn.microsoft.com/dotnet/core/introduction

---

## 2) Fundamentos del lenguaje
- Tipos de datos
	- Primitivos (`int`, `double`, `bool`, `char`)
	- Referencia (`string`, `object`)
	- Tipos num√©ricos y rangos
- Variables y constantes
- Operadores
	- Aritm√©ticos
	- L√≥gicos
	- Relacionales
	- Bitwise
- Expresiones y precedencia
- Conversi√≥n de tipos
	- Impl√≠cita
	- Expl√≠cita (casting)
	- `Parse`, `TryParse`

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/fundamentals/types/

---

## 3) Control de flujo
- Condicionales
	- `if`
	- `else`
	- `else if`
	- `switch`
- Bucles
	- `for`
	- `while`
	- `do while`
	- `foreach`
- Control de ejecuci√≥n
	- `break`
	- `continue`
	- `return`

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/language-reference/statements/

---

## 4) Funciones y m√©todos
- Declaraci√≥n de m√©todos
- Par√°metros
	- Por valor
	- Por referencia (`ref`, `out`)
- Valores de retorno
- Sobrecarga de m√©todos
- Scope y ciclo de vida de variables
- M√©todos est√°ticos vs m√©todos de instancia

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/methods

---

## 5) Colecciones y estructuras de datos
- Arrays
	- Unidimensionales
	- Multidimensionales
- Colecciones gen√©ricas
	- `List<T>`
	- `Dictionary<TKey, TValue>`
	- `Queue<T>`
	- `Stack<T>`
- Iteraci√≥n con `foreach`
- Diferencias entre arrays y colecciones din√°micas

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/collections

---

## 6) Manejo de cadenas de texto (Strings)
- Concatenaci√≥n
- Interpolaci√≥n (`$""`)
- M√©todos comunes de `string`
- Inmutabilidad de strings
- `StringBuilder`

**Recursos**
- https://learn.microsoft.com/dotnet/api/system.string

---

## 7) Manejo de excepciones y depuraci√≥n
- Manejo de errores
	- `try`
	- `catch`
	- `finally`
- Excepciones personalizadas
- Debugging
	- Breakpoints
	- Step Over / Step Into
	- Inspecci√≥n de variables
	- Call Stack

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/fundamentals/exceptions/

---

## 8) Programaci√≥n Orientada a Objetos (POO)
- Clases y objetos
- Propiedades y campos
- Constructores y destructores
- Encapsulamiento
	- `public`
	- `private`
	- `protected`
	- `internal`
- Herencia
- Polimorfismo
- Abstracci√≥n
	- Clases abstractas
	- Interfaces
- `virtual`, `override`, `sealed`

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/fundamentals/object-oriented/

---

## 9) Delegados, eventos y expresiones lambda
- Delegados
- Eventos
- Expresiones lambda
- Funciones an√≥nimas
- Uso en interfaces gr√°ficas y l√≥gica de negocio

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/programming-guide/delegates/

---

## 10) LINQ y consultas de datos
- Introducci√≥n a LINQ
- Sintaxis de m√©todos
- Sintaxis de consulta
- `Where`, `Select`, `OrderBy`
- Proyecciones y filtros
- LINQ sobre colecciones y objetos

**Recursos**
- https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/

---

## 11) Archivos y entrada/salida
- Lectura y escritura de archivos
- `File`, `FileInfo`
- `StreamReader`, `StreamWriter`
- Rutas y directorios
- Serializaci√≥n b√°sica (JSON / XML)

**Recursos**
- https://learn.microsoft.com/dotnet/standard/io/

---

## 12) Temas avanzados y aplicaciones reales
- Programaci√≥n as√≠ncrona
	- `async` / `await`
	- `Task`
- Paralelismo y concurrencia
- Gen√©ricos avanzados
- Gesti√≥n de memoria
- Rendimiento
- Desarrollo de aplicaciones reales
	- ASP.NET Core
	- APIs REST
	- Entity Framework Core
	- Desktop (WinForms / WPF)

**Recursos**
- https://learn.microsoft.com/dotnet/standard/async/
- https://learn.microsoft.com/aspnet/core/

---


## Curso C# desde cero ‚Äî YouTube
- https://www.youtube.com/watch?v=TqiysLEBZo4
- Variables, condicionales, bucles
- Windows Forms
- Ejercicios pr√°cticos

---

## Curso C# Completo ‚Äî Udemy
- https://www.udemy.com/course/c-sharp-beginner-to-advanced/
- Fundamentos ‚Üí POO ‚Üí LINQ ‚Üí Avanzado
- Proyectos pr√°cticos

---

## Microsoft Learn ‚Äî Ruta oficial C#
- https://learn.microsoft.com/training/paths/csharp-first-steps/
- Contenido oficial y actualizado
- Enfoque profesional

# libro c sharp NET en accion

## Referencias principales
- lockASPNETCore2018

## Contexto del libro
- Libro enfocado en **ASP.NET Core aplicado a proyectos reales**.
- Orientado a entender:
	- El ciclo de vida de una aplicaci√≥n web en .NET.
	- La arquitectura interna de ASP.NET Core.
	- El uso pr√°ctico del framework m√°s all√° de ejemplos b√°sicos.
- Combina teor√≠a con implementaci√≥n paso a paso.
- Adecuado para desarrolladores con base previa en C# que quieren dar el salto a backend profesional.

## Tecnolog√≠as y conceptos clave cubiertos
- ASP.NET Core
- Middleware y pipeline HTTP
- Inyecci√≥n de dependencias
- Configuraci√≥n y entornos
- Hosting web con Kestrel
- Routing
- MVC y APIs
- Seguridad y autenticaci√≥n
- Rendimiento y despliegue

## Recursos oficiales y repositorios
- C√≥digo fuente del libro
	- [ASP.NET Core in Action ‚Äì Repositorio oficial](https://github.com/andrewlock/asp-dot-net-core-in-action)
- Organizaci√≥n ASP.NET en GitHub
	- [ASP.NET GitHub](https://github.com/aspnet)
- Servidor web Kestrel
	- [Kestrel HTTP Server](https://github.com/aspnet/KestrelHttpServer)
- Repositorio principal de ASP.NET Core
	- [ASP.NET Core](https://github.com/dotnet/aspnetcore)

## Uso recomendado del libro
- Como **gu√≠a de arquitectura backend en . NET**.
- Para entender **qu√© ocurre internamente** cuando se procesa una request.
- Como apoyo a cursos de:
	- [Backend](/uncategorized/backend/)
- Para leer en paralelo mientras se desarrolla un proyecto real.

## Relaci√≥n con otros temas
- Complementa:
	- POO
	- Inyeccion-de-dependencias
	- Arquitectura-software
- Base s√≥lida para:
	- APIs REST
	- Microservicios en .NET
	- Aplicaciones web de alto rendimiento
