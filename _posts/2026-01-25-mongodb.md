---
title: mongodb
tags:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: DB
categories:
  - DB
  - mongodb
  - Databases
---
# MongoDB
`$= dv.current().file.tags.join(" ")`

- [MongoDB Curso, Introducci√≥n Practica a NoSQL](https://www.youtube.com/watch?v=lWMemPN9t6Q) 
- mongodb ejemplos de codigo
- [Databases](/uncategorized/databases/)

## Introducci√≥n
- MongoDB es:
	- escalable, con soporte nativo para **clusters** y **replicaci√≥n**.
	- orientado a documentos en formato **JSON/BSON**.
	- escrito en **C++** y optimizado para rendimiento.
	- schema-less (permite documentos con estructura flexible).
	- dise√±ado para **escalado horizontal** mediante sharding.
	- de prop√≥sito general: adecuado para APIs, microservicios, IoT, anal√≠tica b√°sica, logging, e-commerce.
- Ventajas clave:
	- consultas ricas con operadores avanzados.
	- integraci√≥n natural con ecosistemas JavaScript.
	- JSON como formato principal ‚Üí curva de aprendizaje m√°s r√°pida.
	- drivers oficiales para m√∫ltiples lenguajes.

## Instalaci√≥n
- Instalar **MongoDB Community Server**.
- Instalar **MongoDB Compass** (cliente visual).
- Ejecutar la instalaci√≥n sin configurarlo como servicio (opcional seg√∫n necesidades).
- A√±adir al PATH la carpeta `/bin`.
- Verificar instalaci√≥n:
	- `mongod --version`
	- `mongod.exe --version`

## Configuraci√≥n Inicial
- A√±adir variable de entorno apuntando a la carpeta `bin`.
- Crear carpeta para almacenamiento:
	- `C:\data\db`
- Iniciar el servidor:
	- `mongod`
- Mantener la ventana abierta con `mongod` para que el servidor siga activo.
- Abrir otra consola para el cliente:
	- `mongo`
- Mongo shell funciona como un int√©rprete de JavaScript.
- Comprobar acceso:
	- ejecutar funciones JS (`Math.sin`, `Date`, funciones propias).

## Conceptos B√°sicos
- **Base de datos:** agrupaci√≥n l√≥gica de colecciones.
- **Colecci√≥n:** conjunto de documentos relacionados, similar a tablas.
- **Documento:** objeto JSON/BSON con estructura flexible.

## Mongo Shell (JS Interpreter)
- Comandos b√°sicos:
	- ver db actual: `db`
	- listar dbs: `show dbs`
	- ayuda: `db.help()`
- Crear y usar bases de datos:
	- `use webstore`
- Crear colecciones:
	- `db.products.insert({"name": "laptop"})`
	- `show collections`
- Eliminar una base de datos:
	- `db.dropDatabase()`
- Funcionalidades JS:
	- `Math.sin(Math.PI / 2)`
	- `new Date()`
	- creaci√≥n de funciones personalizadas

## Funcionamiento de Colecciones
- Crear colecciones expl√≠citas:
	- `db.createCollection("users")`
	- `db.createCollection("products")`
- Borrar colecciones:
	- `db.products.drop()`
- Insertar documentos:
	- `db.products.insert(<json>)`
- B√∫squeda:
	- `db.products.find()`
	- `db.products.find().pretty()`
- BSON:
	- JSON se transforma a BSON (binario eficiente).
- Expresiones regulares:
	- `"x": /foobar/i`

## Operaciones T√≠picas (CRUD Avanzado)
- Insertar datos:
	- `db.products.insert({"name": "keyboard"})`
	- `db.products.insert({"name": "laptop", "price": 999.99})`
- Buscar documentos:
	- `db.products.find({name: "mouse"})`
	- `db.products.find({price: 999.99})`
	- `db.products.find({"tags":"computers"})`
	- `db.products.findOne({"tags": "computers"})`
- Proyecciones:
	- `db.products.findOne({"tags": "computers"}, {"name": 1, "description": 1, "_id": 0})`
- Ordenaci√≥n:
	- `db.products.find().sort({name: 1})`
- L√≠mites:
	- `db.products.find().limit(2)`
- Contar documentos:
	- `db.products.count()`

## Uso de Funciones en Consultas
- Recorrer resultados:
	- `db.products.find().forEach(product => print("Product Price: " + product.price))`
- Actualizaciones:
	- Reemplazo completo:
		- `db.products.update({"name": "keyboard"}, {"price": 99.99})`
	- Uso de `$set`:
		- `db.products.update({"name": "laptop"}, {$set: {"description": "lg gram laptop"}})`
	- Upsert:
		- `db.products.update({"name": "desktop"}, {$set: {"description": "Gaming Desktop"}}, {upsert: true})`
	- Incrementos:
		- `db.products.update({"name": "keyboard"}, {$inc: {"price": 0.01}})`
	- Renombrar atributos:
		- `db.products.update({"name": "laptop"}, {$rename: {"name": "nombre"}})`
- Eliminaciones:
	- `db.products.remove({"nombre": "keyboard"})`
	- `db.products.remove({})` (todos los documentos)

## MongoDB Compass
- Cliente visual para interactuar con MongoDB.
- Conexi√≥n por defecto: puerto `27017`.
- Permite ver colecciones, insertar documentos y ejecutar consultas visualmente.
- El servidor debe estar ejecut√°ndose con `mongod`.

# MongoDB ‚Äî Conceptos Avanzados y Arquitectura

## BSON y Tipos de Datos
- MongoDB almacena documentos en **BSON**, una representaci√≥n binaria de JSON.
- Ventajas:
	- m√°s velocidad en la lectura/escritura.
	- tipos adicionales no presentes en JSON.
- Tipos relevantes:
	- `ObjectId`
	- `Date`
	- `Timestamp`
	- `Binary`
	- `Decimal128`
	- arrays, documentos anidados, regex.

## Dise√±o de Documentos
- Dos enfoques:
	- **Embedding:** incluir documentos dentro de otro documento ‚Üí consultas r√°pidas.
	- **Referencing:** enlazar documentos mediante IDs ‚Üí √∫til para conjuntos grandes y relaciones flexibles.
- Consideraciones:
	- documentos demasiado grandes degradan el rendimiento.
	- mejor desnormalizar cuando se prioriza la lectura.

## √çndices
- Principales tipos:
	- **√çndices simples:** un solo campo.
	- **√çndices compuestos:** varios campos, con orden espec√≠fico.
	- **√çndices √∫nicos:** no permite duplicados.
	- **√çndices TTL:** eliminan documentos autom√°ticamente tras un tiempo.
	- **√çndices de texto:** b√∫squedas sem√°nticas.
	- **√çndices geoespaciales:** admite coordenadas y mapas.
	- **√çndices parciales:** solo indexan documentos que cumplen una condici√≥n.
	- **√çndices sparse:** ignoran campos inexistentes.

## Consultas Avanzadas
- Comparaciones:
	- `$gt`, `$lt`, `$gte`, `$lte`, `$eq`, `$ne`.
- Arrays:
	- `$elemMatch`, `$size`, `$all`.
- Operadores l√≥gicos:
	- `$and`, `$or`, `$nor`, `$not`.
- Expresiones regulares avanzadas usadas en b√∫squedas flexibles.

## Aggregation Framework
- Sistema similar a pipelines tipo SQL:
	- `$match`: filtrar.
	- `$project`: seleccionar campos.
	- `$group`: agrupaciones y sumatorias.
	- `$sort`: ordenar.
	- `$unwind`: expandir arrays.
	- `$lookup`: realizar joins con otras colecciones.
	- `$facet`: m√∫ltiples pipelines en paralelo.
- Usado para:
	- reportes,
	- dashboards,
	- res√∫menes,
	- an√°lisis avanzado.

### Ejemplo de Aggregation
{% raw %}
```js
db.sales.aggregate([
	{ $match: { status: "paid" }},
	{ $group: { _id: "$seller", total: { $sum: "$amount" }}},
	{ $sort: { total: -1 }}
])
```
{% endraw %}`

## Transacciones y ACID

* Desde MongoDB 4.0:

  * Permite **transacciones multi-documento** en replica sets.
  * Lecturas/escrituras atomizadas.
* √ötil para:

  * operaciones financieras,
  * integridad fuerte en varias colecciones.

## Replicaci√≥n (Replica Sets)

* Un replica set contiene:
	* un **primary**
	* uno o varios **secondary**
	* opcionalmente un **arbiter** (solo participa en votaciones).
* Beneficios:
  * tolerancia a fallos,
  * lecturas distribu√≠das.
* Configuraciones avanzadas:
  * ajustar prioridades para decidir qu√© nodo es elegible como primary,
  * crear nodos retrasados (delayed) para recuperaci√≥n hist√≥rica,
  * elegir read concern y write concern seg√∫n consistencia.

## Sharding

* Estrategia para escalar horizontalmente.
* Componentes:
	* **mongos:** router de consultas.
	* **config servers:** almacenan metadatos.
	* **shards:** conjuntos de datos distribuidos.
* M√©todos de particionamiento:
	* **rangos:** adecuado si los valores tienen una distribuci√≥n uniforme.
	* **hash:** balanceo autom√°tico m√°s uniforme.
* Shard key adecuada:
	* evita hotspots,
	* distribuye cargas de forma estable.

## Seguridad

* MongoDB implementa:
	* autenticaci√≥n por usuario/contrase√±a,
	* roles con permisos espec√≠ficos,
	* encriptaci√≥n TLS en tr√°nsito,
	* encriptaci√≥n en reposo mediante claves KMS o integraciones con Atlas,
	* auditor√≠a para entornos de producci√≥n.

## Herramientas del Ecosistema

* **MongoDB Atlas:** servicio en la nube con backups, m√©tricas, escalado autom√°tico y funciones serverless.
* **mongodump/mongorestore:** backups binarios.
* **mongoexport/mongoimport:** importaci√≥n/exportaci√≥n JSON/CSV.
* **mongosh:** shell moderno reemplazando a `mongo`.
* **Drivers oficiales:** Node.js, Python, Go, Java, C#, Rust‚Ä¶
* **Mongoose (Node.js):**
  * ODM para modelar schemas,
  * middlewares,
  * validaciones.

## Patrones de Modelado NoSQL

* **Bucket Pattern:** ideal para logs o streams.
* **Subset Pattern:** guardar solo parte de un conjunto grande.
* **Computed Pattern:** almacenar datos calculados para acelerar lecturas.
* **Tree Patterns:** representaci√≥n de jerarqu√≠as.
* **Outlier Pattern:** separar elementos que rompen el tama√±o t√≠pico del documento.

# MongoDB ‚Äî Arquitectura, Patrones y Casos de Uso Exhaustivos
## Arquitectura ‚Äî Componentes y Fundamentos
- Componentes principales:
	- **mongod** ‚Äî proceso servidor que almacena datos y atiende consultas.
	- **mongos** ‚Äî router de consulta en clusters sharded; act√∫a como puerta de enlace.
	- **Config Servers** ‚Äî almacenan metadatos del cluster sharded (topolog√≠a, chunks).
	- **Clients / Drivers** ‚Äî conexiones desde apps (drivers oficiales y ORMs/ODMs).
- Flujo de operaciones:
	- Cliente ‚Üí mongos (si hay sharding) ‚Üí shard(s) / replica set primary ‚Üí escritura en `oplog` ‚Üí replicaci√≥n a secondaries.
- Otras piezas:
	- **OpsLog (oplog)** ‚Äî registro de operaciones para replicaci√≥n.
	- **Journaling** ‚Äî durabilidad a nivel de servidor (WiredTiger journaling).
	- **Storage Engine** (WiredTiger por defecto, In-Memory opcional).

## Storage Engines y Persistencia
- **WiredTiger**:
	- MVCC (versiones m√∫ltiples) ‚Üí mayor concurrencia.
	- Compresi√≥n configurable (snappy, zlib, zstd).
	- Buen rendimiento en escritura/escritura concurrente.
- **In-Memory Engine**:
	- Datos residen en RAM, uso en casos de latencia ultra baja.
	- No persistente por defecto (√∫til para caches o pruebas).
- Consideraciones:
	- Tama√±o m√°ximo de documento (16MB).
	- Limitaciones del tama√±o de la base de datos por recursos del nodo.

## Replicaci√≥n (Replica Sets) ‚Äî Alta Disponibilidad
- Conceptos:
	- R√©plica compuesta por un **primary** (lee/escribe) y m√∫ltiples **secondaries** (replican).
	- **Arbiter** participa en votaciones pero no guarda datos.
	- **Read/Write Concerns**:
		- `w` (write concern): numero de r√©plicas que deben confirmar.
		- `wtimeout` y `majority` para garant√≠as fuertes.
		- `readPreference`: `primary`, `primaryPreferred`, `secondary`, `nearest`.
- Consideraciones de dise√±o:
	- Nodos en distintas zonas/centros para resiliencia.
	- Nodos delayed para proteger contra eliminaci√≥n accidental (p.ej. delay: 86400s).
	- Prioridades para control de elecciones.

## Oplog y Consistencia
- **Oplog**:
	- Cola capped que registra operaciones en el primary.
	- Secondaries reproducen el oplog para alcanzar consistencia eventual.
- Consistencia:
	- Lecturas desde `primary` ‚Üí m√°s consistencia.
	- Lecturas desde `secondary` ‚Üí latencia reducida pero posible retraso (staleness).

## Sharding ‚Äî Escalado Horizontal
- Elementos:
	- **Shards**: cada shard puede ser un replica set.
	- **mongos**: router que transparently reparte queries.
	- **config servers**: normalmente 3 nodos (replica set) que guardan metadata.
- Selecci√≥n de Shard Key:
	- Debe distribuir uniformemente la carga.
	- Evitar keys monotonas (timestamp, _id incrementales) que generan hotspots.
	- Considerar cardinalidad, frecuencia de consulta, y uso en filtros.
- Estrategias:
	- **Rango** (range sharding): bueno para queries por rango pero riesgo de hotspots.
	- **Hash** (hashed sharding): balanceo m√°s uniforme, peor para rangos.
- Rebalanceo:
	- Micro-movimientos de chunks entre shards.
	- Impacto en I/O y red; planificar mantenimiento.

## Seguridad, Networking y Operaciones
- Autenticaci√≥n:
	- SCRAM, x.509, LDAP integrable.
- Autorizaci√≥n:
	- Roles basados en privilegios (built-in roles + roles personalizados).
- Encriptaci√≥n:
	- TLS/SSL en tr√°nsito.
	- Encriptaci√≥n en reposo: en disco (proveedores KMS para llaves).
- Auditor√≠a y cumplimiento:
	- Logging de eventos, retenci√≥n y conservaci√≥n para auditor√≠a.
- Networking:
	- Abrir puertos m√≠nimos (27017, 27019, 27018 seg√∫n roles).
	- Whitelists / VPC para limitar accesos.
- Backups:
	- Snapshots del filesystem (si storage engine lo permite).
	- `mongodump`/`mongorestore` para migraciones y backups l√≥gicos.
	- Backups consistentes en cluster sharded o Atlas snapshots.

## Monitorizaci√≥n y Observabilidad
- M√©tricas importantes:
	- Latencia de operaciones, QPS, uso CPU/RAM, I/O disco, lock percentage.
- Herramientas:
	- MongoDB Cloud Manager / Ops Manager / Atlas Monitoring.
	- Integraciones con Prometheus, Grafana.
	- Logs y slow query profiler (`db.system.profile`).

## C√≥digo: Iniciar Replica Set (ejemplo)
### Iniciar Replica Set (shell)
{% raw %}
```js
// en cada nodo mongod (con --replSet rs0) y luego en shell:
rs.initiate({
	_id: "rs0",
	members: [
		{ _id: 0, host: "mongo1:27017" },
		{ _id: 1, host: "mongo2:27017" },
		{ _id: 2, host: "mongo3:27017" }
	]
})
```
{% endraw %}`

## C√≥digo: Habilitar Sharding en DB y Colecci√≥n (ejemplo)

### Habilitar Shard y Shard Key (mongos)

{% raw %}
```js
sh.enableSharding("commerce")
sh.shardCollection("commerce.orders", { "customerId": "hashed" })
```
{% endraw %}

## Patrones de Modelado ‚Äî Descripci√≥n y Ejemplos

* Principios generales:
  * Priorizar patrones seg√∫n los requerimientos de lectura/escritura y consistencia.
  * Evaluar trade-offs: duplicaci√≥n (desnormalizaci√≥n) vs consistencia y costos de actualizaci√≥n.

### Embedding vs Referencing

* **Embedding**: almacenar subdocumentos dentro del documento padre.
  * Pros:
    * Lecturas at√≥micas y r√°pidas (1 consulta).
    * Simplicidad conceptual.
  * Contras:
    * Documentos pueden crecer demasiado (> 16MB).
    * Actualizaciones parciales m√°s costosas si se repite en muchos documentos.
* **Referencing**: guardar referencias (ObjectId) a otros documentos.
  * Pros:
    * Evita documentos enormes.
    * Mejor para relaciones N:N y colecciones grandes.
  * Contras:

    * Requiere m√∫ltiples queries o `$lookup`.
### Pattern: Bucket (time-series / logs)

* Agrupa eventos por intervalos (por ejemplo, por d√≠a o por hora) dentro de un documento para reducir n√∫mero de documentos.
* Uso: m√©tricas, telemetr√≠a, logs.
* Consideraci√≥n: tama√±o del bucket (no superar l√≠mites de documento).

### Pattern: Subset / Partial Aggregation

* Guardar solo los campos m√°s consultados o una vista parcial para acelerar queries frecuentes.
* Ideal cuando el documento original es grande pero las consultas requieren solo un subconjunto.

### Pattern: Outlier

* Separar documentos que no encajan en el esquema ‚Äút√≠pico‚Äù (outliers) a otra colecci√≥n para mantener tama√±os y rendimiento.

### Pattern: Computed/Pre-Aggregation

* Guardar valores calculados (totales, contadores) para evitar c√°lculos pesados en cada lectura.
* Requiere estrategia de actualizaci√≥n (triggers de aplicaci√≥n o transacciones).

### Pattern: Tree / Jerarqu√≠as

* **Adjacency List**:
	* Cada nodo contiene `parentId`. F√°cil de mantener, consultas recursivas costosas.
* **Materialized Path**:
	* Guardar ruta completa en un campo (`"path": "root/child/grandchild"`). F√°cil filtrado por prefijo.
* **Nested Sets**:
	* Representaci√≥n con `lft`/`rgt`, ideal para lecturas de sub√°rboles, costoso en escrituras.
	* Elegir seg√∫n patr√≥n de lecturas vs escrituras.

### Pattern: Versioning / Audit Trail

* Mantener versiones hist√≥ricas de documentos (copias o snapshots).
* Uso en compliance y auditor√≠a.

### Pattern: Time-Series (espec√≠fico)

* Usar colecciones con bucket pattern o Timeseries Collections (feature nativa en versiones recientes).
* Ventajas: compresi√≥n especializada y consultas optimizadas por tiempo.

### Pattern: Leaderboard / Counters

* Uso de documentos con contadores (`$inc`) y sharding por ranges/hashed para escalar.
* Considerar limitaciones de concurrencia en hotspots.

## Ejemplos de C√≥digo: Aggregation para Patrones Comunes

### Aggregation ‚Äî Top Sellers por Mes

{% raw %}
```js
db.orders.aggregate([
	{ $match: { status: "paid", date: { $gte: ISODate("2025-01-01") } } },
	{ $group: { _id: { seller: "$sellerId", month: { $month: "$date" } }, total: { $sum: "$amount" } } },
	{ $sort: { total: -1 } },
	{ $limit: 10 }
])
```
{% endraw %}

## Casos de Uso y Recomendaciones de Patrones

* **E-commerce (cat√°logo, orders, carritos)**:
	* Cat√°logo: usar embedding para atributos peque√±os; referencing para relaciones complejas (reviews, suppliers).
	* Orders: documentos por order (embedding items) + computed totals; replica sets para HA.
	* Sharding por `customerId` o `orderDate` (evitar hotspot si es secuencial).
* **Sistemas de logging y m√©tricas (telemetr√≠a, IoT)**:
	* Bucket pattern o Time-Series Collections; compresi√≥n y TTL para retenci√≥n.
* **Redes sociales / Feed**:
	* Denormalizar actividad (write-heavy): Precompute feeds o fan-out on write.
	* Graph-like queries limitados; considerar DB especializada (graph DB) para queries profundas.
* **Geolocalizaci√≥n / Geospatial**:
	* √çndices 2dsphere, consultas por proximidad; shards por regiones si necesario.
* **Gaming (estad√≠sticas, leaderboards)**:
	* Contadores con `$inc`, TTL para datos ef√≠meros, shard por region/gameId.
* **Catalog/Content Management**:
	* Flexibilidad de esquema para m√∫ltiples tipos de contenido; indexing de texto y facets.
* **Financial / Transaccional (banking)**:
	* Usar transacciones multi-documento y replica sets con `majority` write concern.
* **Anal√≠tica y BI**:
	* Pipeline de aggregation, `$lookup` para combinar datasets, export a data warehouse cuando se requiera consultas complejas.

## Operaciones y Pr√°cticas Recomendadas (Best Practices)

* Dise√±ar shard key antes de la fase de crecimiento serio.
* Monitorizar √≠ndices y eliminar √≠ndices sin uso.
* Usar `w: "majority"` para operaciones cr√≠ticas.
* Mantener replica sets en 3+ nodos (o 5 para tolerancia mayor).
* Automatizar backups y pruebas de restore.
* Probar failover y recuperaci√≥n peri√≥dicamente.
* Mantener m√©tricas y alertas para latencia, conexiones y uso de locks.

## Recursos y Referencias

* Considerar migraci√≥n a **MongoDB Atlas** para manejo operativo (backups autom√°ticos, autoscaling).
* Herramientas de utilidad:
  * `mongodump`, `mongorestore`, `mongoexport`, `mongoimport`, `mongotop`, `mongostat`.

# Fundamentos y Conceptos Clave de MongoDB
`$= dv.current().file.tags.join(" ")`

## Introducci√≥n
**MongoDB** es un Sistema de Gesti√≥n de Bases de Datos **NoSQL orientado a documentos**, dise√±ado para manejar datos semiestructurados, distribuidos y altamente escalables.  
A diferencia de los modelos relacionales, en MongoDB los datos se almacenan como **documentos BSON**, permitiendo flexibilidad estructural, escalabilidad horizontal nativa y consultas ricas incluso sin esquema r√≠gido.

Esta nota recoge los **fundamentos te√≥ricos esenciales** que forman la base conceptual de MongoDB.

---

## 1. Modelo de Datos en MongoDB

### 1.1 Documento
Unidad fundamental de almacenamiento:
- Formato **BSON** (Binary JSON).
- Permite tipos extendidos: fechas, binarios, ObjectId, enteros de 64 bits, decimal128.
- Soporte nativo para:
	- Subdocumentos.
	- Arrays.
	- Tipos heterog√©neos.

### 1.2 Colecci√≥n
Conjunto de documentos relacionados:
- No requieren esquema fijo.
- Pueden contener documentos parcialmente distintos.
- Equivalente conceptual a una ‚Äútabla‚Äù, pero sin tipado estricto.

### 1.3 Base de Datos
Agrupa colecciones l√≥gicamente, con espacio de nombres propio.

---

## 2. Esquema Flexible

### 2.1 Flexibilidad del Esquema
- No existe un esquema r√≠gido.
- Permite evolucionar los datos sin migraciones masivas.
- Implica **dise√±ar con intenci√≥n**, aunque sea flexible.

### 2.2 Embedding
Se recomienda embeber cuando:
- Relaci√≥n **1:1** o **1:N** con tama√±o acotado.
- Se requiere lectura r√°pida en una sola operaci√≥n.
- La consistencia depende del mismo documento.

### 2.3 Referencing
Recomendado para:
- Relaciones **N:M**.
- Volumen grande de datos o crecimiento indefinido.
- Necesidad de reutilizar entidades en m√∫ltiples documentos.

### 2.4 Anti-Patrones
- Documentos que superan l√≠mites l√≥gicos (>16 MB).
- Arrays infinitos.
- Crecimiento continuo del documento principal.
- Demasiadas referencias entre colecciones.

---

## 3. Relaciones en MongoDB

### 3.1 1:1
Embedding casi siempre recomendable.

### 3.2 1:N
- Embedding si el tama√±o es moderado.
- Referencing si crece de forma ilimitada o si los hijos cambian mucho.

### 3.3 N:M
Soluciones comunes:
- Documentos puente.
- Referencias duales.
- `$lookup` en agregaciones.

---

## 4. √çndices

### 4.1 B-Trees
√çndice general para la mayor√≠a de consultas.

### 4.2 Multikey
- Indexa arrays.
- Cada valor del array se indexa independientemente.

### 4.3 Text Index
- B√∫squeda por relevancia.
- Stemming.
- Idioma configurable.

### 4.4 Geo Index
`2dsphere` y `2d`:
- Cercan√≠a (near).
- Pol√≠gonos, intersecciones.
- GeoJSON nativo.

### 4.5 TTL Index
Elimina documentos autom√°ticamente tras un tiempo.

### 4.6 √çndices para Sharding
Necesarios para claves de shard distribuidas.

---

## 5. Fundamentos del Motor Interno

### 5.1 WiredTiger
- Compresi√≥n.
- MVCC.
- Checkpoints.
- Concurrencia optimizada a nivel documento.

### 5.2 BSON
- Binario.
- R√°pida serializaci√≥n/deserializaci√≥n.
- Tipos extendidos optimizados.

### 5.3 L√≠mite de Documento
16 MB por documento:
- Evita fragmentaci√≥n extrema.
- Favorece patrones de dise√±o correctos.

---

## 6. CRUD y Operadores

### 6.1 CRUD
- `insertOne`, `insertMany`
- `find`, `findOne`
- `updateOne`, `updateMany`
- `deleteOne`, `deleteMany`

### 6.2 Operadores B√°sicos
- `$set`, `$unset`
- `$inc`, `$mul`
- `$push`, `$pull`, `$addToSet`
- `$exists`, `$regex`

### 6.3 Operadores Avanzados
- `$currentDate`
- `$rename`
- `$min`, `$max`

### 6.4 Proyecciones
- Inclusi√≥n/exclusi√≥n de campos.
- Control del tama√±o del documento resultante.

---

## 7. Agregaciones (Aggregation Pipeline)

### 7.1 Concepto
Pipeline tipo data-flow similar a ETL, compuesto de etapas secuenciales.

### 7.2 Etapas Frecuentes
- `$match`
- `$project`
- `$sort`
- `$group`
- `$unwind`
- `$lookup`
- `$facet`
- `$limit`, `$skip`

### 7.3 Caracter√≠sticas
- Altamente optimizado.
- Permite modelado anal√≠tico avanzado.
- Reemplaza complejas consultas SQL.

---

## 8. Consistencia y Transacciones

### 8.1 Modelo de Consistencia
- **Fuerte a nivel de documento.**
- **Eventual** en sistemas distribuidos.

### 8.2 Write Concern
Control sobre la confirmaci√≥n:
- `acknowledged`
- `journaled`
- `majority`
- `linearizable`

### 8.3 Read Concern
- `local`
- `majority`
- `linearizable`
- `snapshot`

### 8.4 Transacciones Multi-Documento
- √ötiles para integridad compleja.
- M√°s lentas que operaciones at√≥micas nativas.

---

## 9. Concurrencia Interna

### 9.1 MVCC
- Lecturas no bloquean escrituras.
- Escrituras no bloquean lecturas.
- Ideal para cargas mixtas.

### 9.2 Locking
- Granularidad fina.
- Locks por documento.
- Locks de intenci√≥n a nivel colecci√≥n/DB.

---

## 10. Replicaci√≥n

### 10.1 Replica Sets
Conjunto de nodos:
- Primario recibe escrituras.
- Secundarios replican.
- Procesos de election automatizados.

### 10.2 Preferencias de Lectura
- `primary`
- `primaryPreferred`
- `secondary`
- `secondaryPreferred`
- `nearest`

---

## 11. Sharding (Escalado Horizontal)

### 11.1 Clave de Shard
Requisitos:
- Alta cardinalidad.
- Buena distribuci√≥n.
- No monot√≥nica (evitar hot spots).

### 11.2 Componentes
- Shards.
- Config servers.
- Routers `mongos`.

### 11.3 Balancer
- Reorganiza ‚Äúchunks‚Äù.
- Evita sobrecarga en nodos concretos.

### 11.4 M√©todos de Sharding
- Por rango.
- Por hash.
- Por zonas etiquetadas (tag aware).

---

## 12. Seguridad

### 12.1 Autenticaci√≥n
- SCRAM-SHA.
- LDAP.
- X.509.

### 12.2 Autorizaci√≥n
- Roles integrados.
- Roles definidos por el usuario.

### 12.3 Encriptaci√≥n
- En tr√°nsito.
- En reposo.
- A nivel de campo (Client-Side FLE).

---

## 13. Observabilidad

### 13.1 Herramientas
- `mongostat`
- `mongotop`
- Profiler
- Logs estructurados

### 13.2 M√©tricas Clave
- Latencia.
- Lock ratio.
- Cache hit ratio.
- Fragmentaci√≥n.
- Uso del disco.

---

## 14. Patrones de Dise√±o

### 14.1 Bucket Pattern
Agrupar documentos peque√±os por lotes/tiempo.

### 14.2 Attribute Pattern
Aplanar estructuras complicadas para mejor indexaci√≥n.

### 14.3 Outlier Pattern
Separar valores an√≥malos en otra colecci√≥n.

### 14.4 Extended Reference Pattern
Combinaci√≥n de embedding parcial + referencia.

### 14.5 Polymorphic Pattern
Documentos con m√∫ltiples formas o estructuras bajo una misma colecci√≥n.

---

## 15. Limitaciones

### 15.1 Transacciones Limitadas
Multi-documento es m√°s costoso.

### 15.2 No Hay Foreign Keys Internas
La integridad referencial debe gestionarse en la aplicaci√≥n o mediante agregaciones.

### 15.3 Riesgo de Fragmentaci√≥n
Documentos de crecimiento constante pueden fragmentarse.

### 15.4 Elecci√≥n Incorrecta de Shard Key
Causa particiones calientes y p√©rdida de escalabilidad.

---

## Conclusi√≥n
MongoDB se basa en un modelo flexible, distribuido y optimizado para escalabilidad horizontal. Sus fundamentos te√≥ricos permiten dise√±ar modelos eficientes, entender su comportamiento interno y aprovechar al m√°ximo su capacidad para manejar datos modernos y aplicaciones distribuidas.


