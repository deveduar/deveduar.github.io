---
date: 2024-11-16 17:08
title: redis
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: Databases
tags:
  - db
  - redis
  - backend
  - devops
---
# Redis  
`$= dv.current().file.tags.join(" ")`  

- [Databases](/uncategorized/databases/)  
- cache  
- Message Brokers  
- Valkey 
---

## üìò Documentaci√≥n y Alternativas  

- Community Edition - Docs  
- Alternativa open source: Valkey Documentation Quick start guide-  
	- Valkey surge como una bifurcaci√≥n de Redis mantenida por la comunidad tras cambios en la licencia de Redis.
	- Ofrece compatibilidad con el protocolo Redis, por lo que se puede usar como reemplazo directo.
	- Enfocada en mantener un modelo 100% open source y extender las capacidades de Redis en entornos distribuidos.
- What is BullMQ  BullMQ-
---

## ‚öôÔ∏è Conceptos Fundamentales  

- **Base de datos NoSQL tipo Key-Value:**  
	Redis almacena datos como pares clave-valor, soportando tipos complejos como listas, hashes, sets, y sorted sets.  
	Es extremadamente r√°pido debido a que trabaja principalmente en memoria (RAM).

- **Cache, Disco y Streaming:**  
	Redis puede actuar como:
	- *Cache en memoria* (baja latencia y alto rendimiento).  
	- *Persistencia en disco* mediante snapshots (RDB) o logs de operaciones (AOF).  
	- *Sistema de streaming* con `Redis Streams`, ideal para colas de mensajes y procesamiento de eventos.

- **1 solo hilo (single-threaded):**  
	El procesamiento de comandos se ejecuta en un √∫nico hilo principal, aunque puede haber procesos auxiliares para tareas de E/S o persistencia.  
	Redis aprovecha operaciones at√≥micas en memoria, eliminando la necesidad de locks complejos.

- **Estructuras de datos principales:**  
	- **Strings:** valores simples o binarios.  
	- **Lists:** colas FIFO/LIFO.  
	- **Sets:** conjuntos sin duplicados.  
	- **Sorted Sets:** conjuntos ordenados con puntuaci√≥n (ranking).  
	- **Hashes:** representaci√≥n eficiente de objetos (similar a JSON o diccionarios).  
	- **Streams:** listas de eventos con IDs √∫nicos, ideales para mensajer√≠a o logs.

---

## üß© Persistencia y Recuperaci√≥n de Datos  

- **RDB (Redis Database Backup):**  
	- Crea snapshots peri√≥dicos del dataset.  
	- R√°pido para restaurar pero puede perder los √∫ltimos cambios si Redis se apaga abruptamente.

- **AOF (Append Only File):**  
	- Registra cada comando de escritura.  
	- Permite reconstruir el estado exacto del servidor tras un fallo.  
	- Puede combinarse con RDB (modo h√≠brido) para optimizar rendimiento y seguridad.

- **Recuperaci√≥n de datos (AOF / RDB):**  
	- Configurable en `redis.conf`.  
	- Puede activarse la reescritura del AOF para reducir tama√±o y mejorar eficiencia.

- **P√©rdida de datos:**  
	- Si solo se usa RDB, existe riesgo de p√©rdida entre snapshots.  
	- Usar AOF o replicaci√≥n minimiza este riesgo.  
	- Redis tambi√©n soporta `appendfsync always` para m√°xima seguridad (aunque con menor rendimiento).

---

## üîí Transacciones y Modo Multi  

- **Transacciones (`MULTI` / `EXEC`):**  
	- Agrupan comandos que se ejecutan secuencialmente sin interrupciones.  
	- No hay *rollback* autom√°tico, pero s√≠ aislamiento durante la ejecuci√≥n.  

- **Modo Multi / Atomicidad:**  
	- Todos los comandos entre `MULTI` y `EXEC` son at√≥micos.  
	- Puede usarse junto con `WATCH` para detectar cambios y evitar condiciones de carrera.

---

## ‚ö°Ô∏è Conjuntos, Rankings y Operaciones Avanzadas  

- **Ranking:**  
	- Con `ZADD`, `ZRANGE`, `ZREVRANK`, Redis permite crear sistemas de puntuaci√≥n o leaderboards.  
	- Ideal para aplicaciones de juegos o m√©tricas.

- **√çndices y b√∫squedas:**  
	- Redis no tiene √≠ndices como SQL, pero puede simularlos usando hashes o sorted sets.  
	- RedisJSON y RediSearch extienden estas capacidades.

---

## üîÑ Integraci√≥n con Node.js  

- [Getting Started with Node and Redis](https://redis.io/learn/develop/node/gettingstarted)  
	- Uso de `redis` (cliente oficial) o `ioredis`.  
	- Ejemplo b√°sico:

### Ejemplo: conexi√≥n y set/get
{% raw %}
```js
import { createClient } from 'redis';

const client = createClient();

await client.connect();
await client.set('message', 'Hola Redis!');
const value = await client.get('message');
console.log(value);

await client.quit();
```
{% endraw %}`

---

## üß∞ Recursos y Cheatsheets

* [Redis Commands Cheat sheet](https://redis.io/learn/howtos/quick-start/cheat-sheet)

  * Incluye comandos esenciales: `SET`, `GET`, `DEL`, `INCR`, `LPUSH`, `SADD`, `HSET`, `ZADD`, etc.
  * √ötil para recordatorio r√°pido de sintaxis y opciones.

---

## üé• Videos y Aprendizaje Visual

* [Redis: base de datos multi-prop√≥sito - YouTube](https://youtu.be/Zpag2CTLC0E)

  * Explica el uso de Redis como cache, base de datos, y message broker.
  * Incluye demostraciones pr√°cticas y casos de uso reales.

---

## üí° Casos de Uso Recomendados

* Cachear resultados de consultas SQL o API.
* Sesiones de usuario en aplicaciones web.
* Sistemas de colas y eventos (con Streams o Pub/Sub).
* Rankings y conteo de puntuaciones.
* Control de tasa (*rate limiting*) mediante incrementos at√≥micos.
* Almacenamiento temporal de tokens o datos de sesi√≥n.

---

## üîß Consejos de Configuraci√≥n

* Ajustar `maxmemory-policy` para definir qu√© hacer cuando se llena la memoria (por ejemplo, `volatile-lru`).
* Activar persistencia h√≠brida (AOF + RDB) para equilibrio entre rendimiento y seguridad.
* Usar r√©plicas (`replicaof`) para alta disponibilidad.
* Configurar `redis-cli --latency` para medir rendimiento.

# Redis - Avanzado y Arquitectura  

- Redis  
- [Databases](/uncategorized/databases/)  
- cache  
- Message Brokers  
- High Availability  
- Scalability  
- Security  
- Performance Tuning  
- Observability  
- Cluster Mode  
- Replication  

---

## üß± Arquitectura Interna  

- **Modelo en memoria:**  
	Redis mantiene todos los datos en RAM, con respaldo opcional en disco.  
	Esto permite tiempos de respuesta del orden de microsegundos.  
	El trade-off es el consumo de memoria y el coste de almacenamiento.

- **Event Loop:**  
	Redis usa un bucle de eventos no bloqueante basado en `epoll` (Linux) o `kqueue` (BSD/Mac).  
	Todas las conexiones se manejan de forma as√≠ncrona en un √∫nico hilo principal, maximizando el rendimiento.

- **I/O threads (Redis 6+):**  
	Desde Redis 6, puede habilitarse procesamiento de entrada/salida en hilos paralelos, mejorando throughput en cargas intensivas de red.  
	Se activa con `io-threads-do-reads yes`.

---

## ‚öôÔ∏è Modo Cluster y Replicaci√≥n  

- **Cluster Mode:**  
	Permite distribuir los datos en m√∫ltiples nodos (sharding autom√°tico).  
	Las claves se asignan mediante *hash slots* (0‚Äì16383) repartidos entre nodos.  
	Redis Cluster ofrece:
	- Escalabilidad horizontal.  
	- Failover autom√°tico.  
	- Alta disponibilidad.

- **Replicaci√≥n:**  
	- Cada nodo primario puede tener uno o m√°s r√©plicas (read-only).  
	- Sincronizaci√≥n as√≠ncrona mediante `PSYNC`.  
	- Comando: `replicaof <host> <port>` o configuraci√≥n en `redis.conf`.

- **Failover autom√°tico:**  
	En Cluster o Sentinel, si un master falla, una r√©plica es promovida autom√°ticamente.  
	Esto garantiza continuidad sin intervenci√≥n manual.

---

## üß≠ Sentinel - Alta Disponibilidad  

- **High Availability con Sentinel:**  
	Redis Sentinel supervisa instancias Redis y maneja:
	- *Monitoring:* detecci√≥n de fallos.  
	- *Notification:* alertas cuando un nodo no responde.  
	- *Automatic failover:* elecci√≥n de nueva r√©plica principal.  
	- *Configuration provider:* clientes pueden consultar qu√© nodo es el actual master.

- Ejemplo de configuraci√≥n m√≠nima:
{% raw %}
```bash
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
```
{% endraw %}`

---

## üîê Seguridad

* **Autenticaci√≥n:**

  * Configurar `requirepass <password>` en `redis.conf`.
  * Redis 6+ permite usuarios y ACLs (`ACL SETUSER`, `ACL SAVE`).

* **ACLs (Access Control Lists):**
  Permiten asignar permisos granulares a usuarios espec√≠ficos.
  Ejemplo:

{% raw %}
```bash
ACL SETUSER api_user on >secretpass ~api:* +get +set
```
{% endraw %}

* **Cifrado:**
  Redis soporta TLS/SSL nativo (`tls-port 6380`, `tls-cert-file`, `tls-key-file`).
  Ideal para entornos en nube o comunicaciones inter-nodo seguras.

* **Aislamiento de red:**
  Siempre ejecutar Redis detr√°s de firewalls, proxies inversos o redes privadas (VPN, VPC).

---

## üöÄ Performance y Optimizaci√≥n

* **Evitar grandes keys o valores:**
  Redis no fragmenta internamente, por lo que usar objetos grandes degrada el rendimiento.

* **Pipeline y batch:**
  Enviar m√∫ltiples comandos en un solo round trip para reducir latencia:

{% raw %}
```js
const pipeline = client.multi();
pipeline.set("a", 1);
pipeline.incr("a");
const results = await pipeline.exec();
```
{% endraw %}

* **Eviction policies:**
  Define c√≥mo Redis maneja la memoria llena (`maxmemory-policy`):

  * `noeviction`, `allkeys-lru`, `volatile-lfu`, etc.
  * Ejemplo: `maxmemory-policy volatile-lru`

* **Evitar bloqueo con Lua Scripts:**
  Permite ejecutar operaciones at√≥micas complejas:

{% raw %}
```lua
EVAL "return redis.call('incr', KEYS[1])" 1 mycounter
```
{% endraw %}

---

## üìà Observabilidad y Monitorizaci√≥n

* **Logs y m√©tricas:**

  * `INFO` muestra estad√≠sticas detalladas del servidor.
  * `MONITOR` permite observar en tiempo real todos los comandos ejecutados.
  * `SLOWLOG get` identifica operaciones lentas.

* **Integraci√≥n con Prometheus / Grafana:**

  * Exportadores oficiales: `redis_exporter`.
  * M√©tricas clave: latencia, memoria usada, hits/misses, clients connected.

* **Comando `LATENCY DOCTOR`:**
  Analiza problemas de latencia y recomienda optimizaciones.

---

## üåê Redis Modules

* **RedisJSON:** almacenamiento de documentos JSON.
* **RediSearch:** b√∫squeda full-text e √≠ndices secundarios.
* **RedisGraph:** consultas tipo grafo (Cypher).
* **RedisBloom:** filtros probabil√≠sticos (Bloom, Cuckoo, Top-K).
* **RedisTimeSeries:** series temporales con agregaciones y compresi√≥n.

Cada m√≥dulo extiende Redis sin modificar su n√∫cleo, manteniendo el mismo protocolo y API.

---

## üß∞ Integraci√≥n con Entornos Modernos

* **Docker & Compose:**
  Redis puede ejecutarse en contenedores f√°cilmente:

{% raw %}
```yaml
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - ./data:/data
```
{% endraw %}

* **Kubernetes:**

  * Redis Operator simplifica despliegues con Sentinel, r√©plicas y PVCs.
  * Escalado autom√°tico con `HorizontalPodAutoscaler`.

* **Cloud Services:**

  * Redis Enterprise (Redis Inc.)
  * AWS ElastiCache
  * Azure Cache for Redis
  * Google Memorystore

---

## üß† Casos de Uso Avanzados

* **Pub/Sub:** comunicaci√≥n entre microservicios.
* **Rate Limiting:** control de peticiones por IP o token.
* **Job Queues:** usando listas o Streams (`XADD`, `XREADGROUP`).
* **Session Store:** persistencia de sesiones en Node.js, Python, PHP.
* **Real-Time Analytics:** contadores, leaderboard, y dashboards en vivo.
* **Event Sourcing:** almacenar cambios como eventos inmutables en Streams.

---

## üîç Recursos Adicionales

* [Redis Architecture Explained - Redis.io](https://redis.io/docs/latest/develop/data-modeling/architecture/)
* [Redis Security Guide](https://redis.io/docs/latest/operate/security/)
* [Redis Modules Hub](https://redis.io/modules/)
* [RedisInsight (GUI oficial)](https://redis.io/insight/)

---

# Redis en Entornos de Producci√≥n  
`$= dv.current().file.tags.join(" ")`  

- Redis  
- Redis - Avanzado y Arquitectura  
- Production Deployment  
- High Availability  
- Monitoring  
- Security  
- DevOps  
- [Docker](/software%20engineering/docker/)  
- [Kubernetes](/virtualizacion/kubernetes/)  

---

## üèóÔ∏è Arquitectura de Producci√≥n  

- **Dise√±o base:**  
	Redis debe desplegarse con redundancia y persistencia activada.  
	El esquema m√°s com√∫n:
	- 1 master + m√∫ltiples r√©plicas.  
	- Sentinel o Cluster para failover.  
	- Monitorizaci√≥n constante (Prometheus/Grafana).  
	- Backups autom√°ticos a disco o nube.

- **Topolog√≠a recomendada:**  
	- Entorno m√≠nimo:
		- `redis-master`
		- `redis-replica-1`, `redis-replica-2`
		- `redis-sentinel-1`, `redis-sentinel-2`, `redis-sentinel-3`  
	- En producci√≥n se recomienda separar r√©plicas por zonas de disponibilidad (AZ).

---

## ‚öôÔ∏è Configuraci√≥n Recomendada  

- **Archivo redis.conf:**
	- `save 900 1` ‚Üí Snapshot cada 15 min si al menos 1 key cambia.  
	- `appendonly yes` ‚Üí Activar AOF.  
	- `appendfsync everysec` ‚Üí Seguridad + rendimiento equilibrado.  
	- `maxmemory <cantidad>` ‚Üí Limitar uso de RAM.  
	- `maxmemory-policy volatile-lru` ‚Üí Evicta las menos usadas.  
	- `protected-mode yes` ‚Üí Imprescindible en entornos abiertos.  
	- `tcp-keepalive 60` ‚Üí Detectar desconexiones de clientes.  
	- `loglevel notice` ‚Üí Nivel equilibrado de logs.

- **Logs:**
	- Registrar en `/var/log/redis/redis-server.log` o redirigir a un sistema central (ELK, Loki).  
	- Usar `syslog-enabled yes` para integraci√≥n con journald.

---

## üß© Despliegue con Docker Compose  

{% raw %}
```yaml
version: "3.9"
services:
  redis:
    image: redis:7-alpine
    container_name: redis-master
    ports:
      - "6379:6379"
    volumes:
      - ./data:/data
      - ./redis.conf:/usr/local/etc/redis/redis.conf
    command: ["redis-server", "/usr/local/etc/redis/redis.conf"]
    restart: unless-stopped

  redis-replica:
    image: redis:7-alpine
    depends_on:
      - redis
    command: ["redis-server", "--replicaof", "redis", "6379"]
    restart: unless-stopped
```
{% endraw %}`

* Escalar r√©plicas:

{% raw %}
```bash
docker compose up --scale redis-replica=2 -d
```
{% endraw %}

---

## ‚ò∏Ô∏è Despliegue en Kubernetes

* **Operador oficial:**
  `Redis Operator` gestiona pods, r√©plicas, backups y Sentinel autom√°ticamente.

* **Ejemplo b√°sico (StatefulSet + Service):**

{% raw %}
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis
spec:
  serviceName: redis
  replicas: 3
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
        - name: redis
          image: redis:7-alpine
          ports:
            - containerPort: 6379
          volumeMounts:
            - name: data
              mountPath: /data
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 1Gi
```
{% endraw %}

---

## üîí Seguridad en Producci√≥n

* **Red:**

  * No exponer Redis directamente a internet (`bind 127.0.0.1`).
  * Usar VPN o VPC privada.
  * Filtrar tr√°fico con firewalls o `iptables`.

* **Autenticaci√≥n y Roles:**

  * Activar `requirepass` y definir usuarios ACL (`redis-cli ACL SETUSER`).
  * Rotar contrase√±as peri√≥dicamente.
  * Desactivar comandos peligrosos (`FLUSHALL`, `CONFIG`, `SHUTDOWN`) para usuarios limitados.

* **TLS:**

  * Activar cifrado con certificados:

{% raw %}
```bash
tls-port 6380
tls-cert-file /etc/ssl/redis.crt
tls-key-file /etc/ssl/redis.key
tls-ca-cert-file /etc/ssl/ca.crt
```
{% endraw %}

* **Protecci√≥n ante ataques comunes:**

  * Limitar conexiones con `maxclients`.
  * Bloquear IPs sospechosas.
  * Usar namespaces o prefijos de clave para evitar colisiones (`app:user:123`).

---

## üíæ Backups y Recuperaci√≥n

* **Snapshots autom√°ticos (RDB):**

  * Guardar cada cierto tiempo o en eventos espec√≠ficos.
  * Copiar el archivo `dump.rdb` peri√≥dicamente a almacenamiento externo (S3, GCS).

* **AOF:**

  * Permite restaurar el estado exacto antes de un fallo.
  * Combinar con `aof-rewrite-percentage` y `aof-rewrite-min-size` para mantenimiento.

* **Backup h√≠brido:**

  * Activar ambos:
    `save 900 1` y `appendonly yes`.
  * Esto asegura recuperaci√≥n r√°pida y m√≠nima p√©rdida.

* **Recuperaci√≥n manual:**

{% raw %}
```bash
cp dump.rdb /var/lib/redis/
chown redis:redis dump.rdb
systemctl restart redis
```
{% endraw %}

---

## üìä Monitorizaci√≥n y Alertas

* **Comandos √∫tiles:**

  * `INFO memory` ‚Üí uso de RAM.
  * `CLIENT LIST` ‚Üí conexiones activas.
  * `MONITOR` ‚Üí actividad en tiempo real.
  * `SLOWLOG get` ‚Üí detectar operaciones lentas.
  * `LATENCY DOCTOR` ‚Üí diagn√≥stico de retrasos.

* **Prometheus Exporter:**

  * `oliver006/redis_exporter`
  * Expone m√©tricas en `/metrics` para Grafana.
  * M√©tricas clave:

    * `redis_memory_used_bytes`
    * `redis_connected_clients`
    * `redis_commands_processed_total`
    * `redis_keyspace_hits_ratio`

* **Alertas recomendadas:**

  * Uso de memoria > 80%.
  * Latencia > 100ms.
  * Fallos de conexi√≥n.
  * Tasa de misses en cache > 20%.

---

## üîÅ Escalado y Alta Disponibilidad

* **Escalado Vertical:**
  Aumentar CPU/RAM en la instancia principal.

* **Escalado Horizontal:**

  * Redis Cluster o particionado manual de keys (hashing).
  * Uso de r√©plicas solo lectura para distribuci√≥n de carga.
  * Uso de Proxy (p.ej. Twemproxy o Envoy) para balancear peticiones.

* **Sentinel:**
  Mecanismo de failover autom√°tico.
  Detecta ca√≠da del master y promueve una r√©plica.

---

## ‚ö° Estrategias de Rendimiento

* **Pipeline:** agrupar comandos reduce RTT.
* **Sharding:** distribuir claves grandes entre nodos.
* **Evitar claves enormes:** usar TTL y expiraciones.
* **Redis Streams:** mejor opci√≥n que listas para colas con persistencia.
* **Prefijos estructurados:** facilitan limpieza y b√∫squedas (`app:users:*`).
* **Evitar hot keys:** particionar o usar hash tags (`{}` en Cluster).

---

## üß† Buenas Pr√°cticas de Operaci√≥n

* Mantener Redis actualizado a la √∫ltima versi√≥n estable.
* Automatizar despliegues (Ansible, Terraform, Helm).
* Evitar usar Redis como base de datos primaria persistente.
* Probar restauraciones de backup regularmente.
* Supervisar el tama√±o del AOF y reescribirlo peri√≥dicamente.
* Documentar configuraci√≥n, claves cr√≠ticas y TTLs.
* Limpiar datos hu√©rfanos o expirados con scripts programados.

---

## üìö Recursos Recomendados

* [Redis Production Checklist - Redis.io](https://redis.io/docs/latest/operate/production-checklist/)
* [Redis Sentinel Documentation](https://redis.io/docs/latest/operate/oss_and_stack/management/sentinel/)
* [Redis Cluster Management Guide](https://redis.io/docs/latest/operate/oss_and_stack/management/cluster-tutorial/)
* [Redis Exporter for Prometheus](https://github.com/oliver006/redis_exporter)
* [Redis Security Guide](https://redis.io/docs/latest/operate/security/)

---
# Redis - Casos de Uso Reales y Patrones de Dise√±o  
`$= dv.current().file.tags.join(" ")`  

- Redis  
- Redis - Avanzado y Arquitectura  
- Redis en Entornos de Producci√≥n  
- [microservicios](/backend/microservicios/)  
- Node.js  
- Python  
- Scalability Patterns  
- System Design  

---

## üí° Introducci√≥n  

Redis no solo funciona como cach√© o base de datos en memoria:  
es un **componente estrat√©gico** en arquitecturas modernas, microservicios y sistemas distribuidos.  
Sus estructuras de datos permiten implementar patrones comunes de comunicaci√≥n, sincronizaci√≥n y almacenamiento temporal de forma eficiente.

---

## ‚ö° Patr√≥n: Cache Distribuida  

- **Objetivo:** reducir carga en bases de datos persistentes y mejorar latencia.  
- **Claves:** TTL, invalidaci√≥n, consistencia eventual.  

### Ejemplo Node.js  
{% raw %}
```js
import { createClient } from 'redis';
const redis = createClient();

await redis.connect();

const cacheKey = "user:42";
let user = await redis.get(cacheKey);

if (!user) {
  user = await db.query("SELECT * FROM users WHERE id=42");
  await redis.set(cacheKey, JSON.stringify(user), { EX: 60 }); // TTL 60s
}

console.log(JSON.parse(user));
```
{% endraw %}`

### Ejemplo Python

{% raw %}
```python
import redis
r = redis.Redis()

cache_key = "product:1001"
data = r.get(cache_key)
if not data:
    data = db.get_product(1001)
    r.setex(cache_key, 120, json.dumps(data))
print(json.loads(data))
```
{% endraw %}

### Buenas pr√°cticas

* Definir TTLs cortos (30‚Äì300s) para coherencia.
* Usar *cache-aside* pattern (solo cachea si no existe).
* Invalidar manualmente tras escritura en DB.

---

## üì® Patr√≥n: Pub/Sub (Mensajer√≠a entre Microservicios)

* **Objetivo:** comunicaci√≥n reactiva entre componentes sin acoplamiento directo.
* **Ventaja:** simple, baja latencia y sin intermediarios complejos como Kafka.

### Ejemplo Node.js

{% raw %}
```js
import { createClient } from 'redis';

const publisher = createClient();
const subscriber = createClient();

await publisher.connect();
await subscriber.connect();

await subscriber.subscribe('notifications', (msg) => {
  console.log('Mensaje recibido:', msg);
});

await publisher.publish('notifications', JSON.stringify({ event: 'user_signed_up' }));
```
{% endraw %}

### Ejemplo Python

{% raw %}
```python
import redis
import threading

r = redis.Redis()

def listener():
    pubsub = r.pubsub()
    pubsub.subscribe("logs")
    for message in pubsub.listen():
        print("Recibido:", message["data"])

threading.Thread(target=listener).start()
r.publish("logs", "Evento de sistema iniciado")
```
{% endraw %}

### Usos comunes

* Microservicios desacoplados (notificaciones, colas simples).
* Broadcasting de eventos (websockets, dashboards).
* Logging distribuido y alertas.

---

## ‚è±Ô∏è Patr√≥n: Rate Limiting

* **Objetivo:** limitar peticiones por usuario o IP para prevenir abuso.
* **Redis se usa por sus operaciones at√≥micas (`INCR`, `EXPIRE`).**

### Ejemplo Node.js

{% raw %}
```js
const limitKey = `rate:${userId}`;
const count = await redis.incr(limitKey);

if (count === 1) await redis.expire(limitKey, 60); // Ventana de 60s
if (count > 10) throw new Error("Demasiadas peticiones");

console.log(`Intento ${count}/10`);
```
{% endraw %}

### Ejemplo Python

{% raw %}
```python
import redis, time

r = redis.Redis()
key = f"rate:{user_id}"
count = r.incr(key)
if count == 1:
    r.expire(key, 60)
if count > 5:
    raise Exception("Rate limit excedido")
```
{% endraw %}

### Extensi√≥n: Token Bucket

Implementaci√≥n m√°s avanzada basada en contadores y timestamps para suavizar r√°fagas.

---

## üßµ Patr√≥n: Job Queue (Colas de Trabajo As√≠ncronas)

* **Objetivo:** procesar tareas en background sin bloquear el flujo principal.
* Redis permite implementarlas con **listas (`LPUSH`/`BRPOP`)** o **Streams (`XADD`, `XREADGROUP`)**.

### Ejemplo b√°sico con Node.js

{% raw %}
```js
// productor
await redis.lPush("jobs", JSON.stringify({ type: "email", to: "user@example.com" }));

// consumidor
while (true) {
  const job = await redis.brPop("jobs", 0);
  const data = JSON.parse(job.element);
  console.log("Procesando tarea:", data);
}
```
{% endraw %}

### Ejemplo avanzado con Streams

{% raw %}
```js
await redis.xAdd("job_stream", "*", { type: "resize", file: "image.jpg" });
const messages = await redis.xReadGroup("workers", "w1", [{ key: "job_stream", id: ">" }]);
```
{% endraw %}

### Python + RQ (Redis Queue)

{% raw %}
```python
from redis import Redis
from rq import Queue
from tasks import send_email

r = Redis()
q = Queue(connection=r)
q.enqueue(send_email, "user@example.com")
```
{% endraw %}

---

## üîë Patr√≥n: Gesti√≥n de Sesiones

* **Objetivo:** almacenar sesiones de usuario compartidas entre servidores.
* Redis es ideal por su baja latencia y soporte TTL.

### Node.js con express-session

{% raw %}
```js
import session from 'express-session';
import connectRedis from 'connect-redis';
import { createClient } from 'redis';

const RedisStore = connectRedis(session);
const redisClient = createClient();

app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: 'secreto',
  resave: false,
  saveUninitialized: false,
  cookie: { secure: false, maxAge: 60000 }
}));
```
{% endraw %}

### Python Flask-Session

{% raw %}
```python
from flask import Flask, session
from flask_session import Session
app = Flask(__name__)
app.config["SESSION_TYPE"] = "redis"
Session(app)
```
{% endraw %}

### Ventajas

* Persistencia entre reinicios del servidor.
* Compatible con balanceo de carga.
* Control autom√°tico de expiraciones.

---

## üìä Patr√≥n: Leaderboards y Rankings

* **Uso:** juegos, m√©tricas, puntuaciones, estad√≠sticas.
* **Estructura:** Sorted Sets (`ZADD`, `ZRANGE`).

### Ejemplo Node.js

{% raw %}
```js
await redis.zAdd("scores", [{ score: 100, value: "player1" }]);
await redis.zAdd("scores", [{ score: 250, value: "player2" }]);

const top = await redis.zRevRange("scores", 0, 2, { WITHSCORES: true });
console.log(top);
```
{% endraw %}

### Ejemplo Python

{% raw %}
```python
r.zadd("ranking", {"alice": 50, "bob": 70, "carol": 60})
top = r.zrevrange("ranking", 0, 2, withscores=True)
print(top)
```
{% endraw %}

### Patr√≥n extendido

* Usar `ZINCRBY` para actualizaciones din√°micas.
* TTL para tablas temporales.
* Redis Streams para almacenar eventos hist√≥ricos paralelos.

---

## üìÖ Patr√≥n: Colas de Retraso (Delayed Jobs)

* **Objetivo:** ejecutar tareas diferidas (recordatorios, reintentos, expiraciones).
* Redis no tiene scheduler interno, pero puede simularse con Sorted Sets.

### Ejemplo Node.js

{% raw %}
```js
const now = Date.now();
await redis.zAdd("delayed", [{ score: now + 5000, value: "send_email" }]);

setInterval(async () => {
  const jobs = await redis.zRangeByScore("delayed", 0, Date.now());
  for (const job of jobs) {
    console.log("Ejecutando:", job);
    await redis.zRem("delayed", job);
  }
}, 1000);
```
{% endraw %}

---

## üß† Patr√≥n: Distributed Lock (Bloqueos distribuidos)

* **Objetivo:** evitar condiciones de carrera en sistemas distribuidos.
* Implementado con el algoritmo **Redlock**.

### Ejemplo con Redlock.js

{% raw %}
```js
import { createClient } from 'redis';
import Redlock from 'redlock';

const client = createClient();
await client.connect();

const redlock = new Redlock([client]);
const lock = await redlock.acquire(['locks:resource'], 2000);
console.log("Bloqueo adquirido");

await lock.release();
```
{% endraw %}

### Conceptos

* Los bloqueos se almacenan como claves con TTL.
* Si el cliente muere, el bloqueo expira autom√°ticamente.
* Usado en sistemas con escritura concurrente o tareas √∫nicas (cron jobs).

---

## üß© Integraci√≥n en Arquitecturas de Microservicios

* **Patrones comunes:**

  * *Command Bus* ‚Üí Pub/Sub entre servicios.
  * *Event Store* ‚Üí Streams como fuente de eventos.
  * *Job Queue centralizada* ‚Üí orquestaci√≥n de tareas.
  * *Cache distribuida global* ‚Üí rendimiento compartido.

* **Ejemplo de pipeline real:**

  1. Microservicio API ‚Üí guarda evento en `XADD event_stream`.
  2. Servicio de Workers ‚Üí `XREADGROUP` procesa tareas pendientes.
  3. Redis almacena resultados temporales (`SETEX`) y estados (`HSET`).
  4. Dashboard consulta resultados en tiempo real mediante `Pub/Sub`.

---

## üß∞ Herramientas y Librer√≠as

* **Node.js:** `ioredis`, `bullmq`, `redis`, `redlock`.
* **Python:** `redis-py`, `rq`, `aioredis`, `huey`.
* **Dashboard:** [RedisInsight](https://redis.io/insight/).
* **Testing:** RedisMock, local Redis containers (`redis:alpine`).

---

## üìö Recursos

* [Redis Patterns Catalog - Redis.io](https://redis.io/docs/latest/develop/use/patterns/)
* [The Little Redis Book (PDF)](https://openmymind.net/redis.pdf)
* [BullMQ Queue System (Node.js)](https://docs.bullmq.io/)
* [RQ (Python Redis Queue)](https://python-rq.org/)
* [Redis Streams Intro](https://redis.io/docs/latest/develop/data-types/streams/)

---



