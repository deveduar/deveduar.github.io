---
date: 2024-11-07 03:11
title: nestjs
keywords:
source:
status: ğŸŒŸ
Parent: "[[Area-Prog]]"
public_note: "true"
category: nestjs
tags:
  - nestjs
  - backend
  - Backend
---
# NestJS
`$= dv.current().file.tags.join(" ")`

- [Backend](/uncategorized/backend/)
- [typescript](/software%20engineering/typescript/)
- [node.js](/backend/node-js/)
-  
- [Documentation | NestJS - A progressive Node.js framework](https://docs.nestjs.com/)
- [OpenAPI (Swagger) | NestJS - A progressive Node.js framework](https://docs.nestjs.com/openapi/introduction)

---

## IntroducciÃ³n general
- Framework progresivo para Node.js basado en **TypeScript**, inspirado en **Angular**.
- Promueve **mantenibilidad**, **modularidad**, **testabilidad** y una arquitectura limpia.
- Construido sobre **Express** (por defecto) o **Fastify** (para mejor rendimiento).
- Enfoque basado en **decoradores** y **metadatos**, aprovechando la **inyecciÃ³n de dependencias**.

### Elementos principales
- **Controllers** â†’ manejan rutas y peticiones HTTP.
- **Services (Providers)** â†’ encapsulan la lÃ³gica de negocio.
- **Entities y DTOs** â†’ estructuras de datos para persistencia y transporte.
- **Middleware** â†’ lÃ³gica intermedia en el flujo de peticiÃ³n.
- **Pipes** â†’ validaciÃ³n y transformaciÃ³n de datos.
- **Guards** â†’ control de acceso y autorizaciÃ³n.
- **Interceptors** â†’ manipulaciÃ³n de respuesta o comportamiento en runtime.
- **Decoradores personalizados** â†’ metaprogramaciÃ³n reutilizable.
- **CLI** â†’ automatiza creaciÃ³n de mÃ³dulos, controladores, servicios y recursos.
- **Testing** â†’ integraciÃ³n nativa con Jest.

---

## Recursos introductorios
- [Â¿QuÃ© es NESTJS? ğŸ¤” Nest JS vs Express Parte 1 - YouTube](https://www.youtube.com/watch?v=lonpW-0EybY&list=PL_WGMLcL4jzWCFea1NUVOfaf4IqIMFN4P)
	- **Controller:** usa decoradores (`@Controller`, `@Get`, `@Post`) y define rutas.
	- **Service:** se inyecta mediante el constructor (`constructor(private readonly service: ...)`).
	- **Base de datos:** se modela y conecta desde los services.
	- **Postman:** usado para comprobar endpoints.
	- **CLI Resource:** 
		- Comando: ``nest generate resource <nombre>``
		- Crea automÃ¡ticamente clases, mÃ©todos y respuestas.
		- Permite acceso directo a rutas pasando strings en el controller.
	- **Swagger:** integraciÃ³n directa para documentaciÃ³n.
		- OpenAPI (Swagger) - NestJS - A progressive Node.js framework
		- Decorador `@ApiTags` organiza los endpoints.
		- Permite crear **API tipadas**.

---

## NestJS + Next.js + Prisma (Fullstack moderno)
- [Nextjs y Nestjs - AplicaciÃ³n CRUD (con Typescript, Shadcn, prisma y mÃ¡s) - YouTube](https://www.youtube.com/watch?v=x2vY7gLzeCY)
- [Get started with Prisma | Prisma Documentation](https://www.prisma.io/docs/getting-started)
	- NestJS: **backend API** (REST o GraphQL).
	- Next.js: **frontend React SSR/SSG**.
	- **Prisma ORM:** acceso tipado a base de datos.
	- CRUD completo (Create, Read, Update, Delete).
	- IntegraciÃ³n con **Shadcn/UI**.
	- Ideal para proyectos con frontend moderno y backend modular.

---

## Estructura de proyectos
- [Si tuviera que empezar un nuevo proyecto de NestJS usarÃ­a esto! - YouTube](https://youtu.be/l--D8yslyUk)
- Mejores prÃ¡cticas de estructura y rendimiento:
	- Evitar mala estructura de carpetas que viole principios **SOLID**.
	- Separar **tests unitarios** y **tests e2e** con convenciÃ³n clara en `package.json`.
	- Optimizar para producciÃ³n (especialmente en [Kubernetes](/virtualizacion/kubernetes/)).
	- Usar **SWC** como compilador (sustituye `tsc`, mÃ¡s rÃ¡pido y eficiente).
	- Sustituir **Express** por **Fastify** â†’ menor latencia, mÃ¡s rendimiento.
	- Mantener **niveles de log** configurables.
	- Implementar **husky** para pre-commit hooks y **merge coverage** en CI/CD.
- **Templates personalizados:**
	- [GitHub - AlbertHernandez/nestjs-service-template](https://github.com/AlbertHernandez/nestjs-service-template)
	- [GitHub - AlbertHernandez/express-typescript-service-template](https://github.com/AlbertHernandez/express-typescript-service-template)
- [ ] Cambiar el **template por defecto** del comando `nest new` para usar una estructura personalizada.

---

## Sistema de pagos con Arquitectura Hexagonal (Clean Architecture)
- [GitHub - AlbertHernandez/nestjs-hexagonal-architecture-example](https://github.com/AlbertHernandez/nestjs-hexagonal-architecture-example)
- [Arquitectura Hexagonal en NestJS | Clean Architecture - YouTube](https://www.youtube.com/watch?v=4_4p5Ojs5XA)
- Ideal para **apps grandes** y con dominio complejo.
- [ ] Crear y listar pagos, aplicando principios de **Domain-Driven Design**.

### Arquitectura Hexagonal
- Divide el sistema en **Dominios**, **AplicaciÃ³n** e **Infraestructura**.
- Las **capas internas** no dependen de las externas.
- ComunicaciÃ³n mediante **Puertos (Interfaces)** y **Adaptadores (Implementaciones)**.
- Uso del patrÃ³n **Unit of Work** para operaciones atÃ³micas (por ejemplo, decoradores para transacciones en MongoDB o PostgreSQL).
	- Decorador de transacciÃ³n (ejemplo implementado en Middleware) ğŸ‘†

---

## Dominio (Domain Layer)
- Carpeta: `context/payments/domain`
- Entidad `payment.ts`
	- Define **primitivos** (ID, cliente, cantidad) con interfaces.
	- ConstrucciÃ³n de la entidad usando atributos tipados.
	- MÃ©todos:
		- `static createPayment()`
		- `toPrimitives()` â†’ convierte el objeto a datos simples.
	- Uso de **uuid** para IDs Ãºnicos.
	- Ejemplo de creaciÃ³n de pago:
{% raw %}
```ts
const payment = Payment.create({
	id: uuid(),
	customerId: '123',
	amount: 100
});
```
{% endraw %}

---

## Clases abstractas y repositorios
- **Archivo:** `payment.repository.ts`
	{% raw %}
```ts
	export abstract class PaymentRepository {
		abstract save(payment: Payment): Promise<void>;
		abstract findById(id: string): Promise<Payment | null>;
	}
	```
{% endraw %}
- **Excepciones personalizadas:**
	{% raw %}
```ts
	export class PaymentNotFoundException extends Error {
		constructor(id: string) {
			super(`Payment with ID ${id} not found`);
		}
	}
	```
{% endraw %}

---

## Casos de uso (Application Layer)
- Ejemplo: `create-payment.usecase.ts`
	{% raw %}
```ts
	export interface CreatePaymentDto {
		id: string;
		customerId: string;
		amount: number;
	}
	```
{% endraw %}

	{% raw %}
```ts
	export class CreatePaymentUseCase {
		constructor(
			private readonly repository: PaymentRepository
		) {}

		async execute(dto: CreatePaymentDto): Promise<PaymentPrimitives> {
			const payment = Payment.create(dto);
			await this.repository.save(payment);
			return payment.toPrimitives();
		}
	}
	```
{% endraw %}
- El caso de uso construye el repositorio con mÃ©todos abstractos.
- Devuelve objetos compuestos Ãºnicamente por primitivos.
- Cada caso de uso orquesta la lÃ³gica entre dominio e infraestructura.

---

## Infraestructura (Infra Layer)
- Compuesta por mÃ³dulos, controladores y servicios inyectables.
- **DTOs** para transporte de datos HTTP:
	- `payment_http-dto.ts`
- Ejemplo bÃ¡sico:
	{% raw %}
```ts
	@Controller('payments')
	export class PaymentController {
		constructor(private readonly createPayment: CreatePaymentUseCase) {}

		@Post()
		async create(@Body() dto: CreatePaymentDto) {
			return this.createPayment.execute(dto);
		}
	}
	```
{% endraw %}
- **Capa agnÃ³stica de la base de datos**.
- **Carpeta shared:** cÃ³digo y utilidades comunes.
- ConfiguraciÃ³n mediante `@Module()` con `providers`.
- ImplementaciÃ³n de repositorios concretos que cumplen las interfaces del dominio.

### Pendientes / TODOs
- [ ] Endpoint de creaciÃ³n y listado de pagos.
- [ ] Injectable personalizado para casos de uso.
- [ ] VerificaciÃ³n de endpoints en Postman.
- [ ] Manejo de excepciones HTTP (`NotFoundException`, `BadRequestException`, etc.)
- [ ] SeparaciÃ³n entre **DTOs de capa HTTP** y **DTOs de aplicaciÃ³n**.
- [ ] Repositorio lanza excepciÃ³n si no existe el pago.

---

# NestJS â€“ Avanzado y Ecosistema
`$= dv.current().file.tags.join(" ")`

- NestJS
- [Backend](/uncategorized/backend/)
- [typescript](/software%20engineering/typescript/)

---

## Core avanzado y ejecuciÃ³n interna
- NestJS estÃ¡ construido sobre un **mÃ³dulo de inyecciÃ³n de dependencias (IoC Container)**.
	- Permite gestionar el **ciclo de vida** de instancias y sus dependencias.
	- Usa **reflexiÃ³n** (metadata) y el decorador `@Injectable()` para registrar providers.
- **MÃ³dulos dinÃ¡micos**
	- Permiten registrar dependencias de forma condicional o configurable.
	- Ejemplo: `ConfigModule.forRoot({ isGlobal: true })`
	- Ãštiles para configurar autenticaciÃ³n, conexiÃ³n a DB o servicios externos.
- **Scopes de providers**
	- `Scope.DEFAULT` â†’ singleton.
	- `Scope.REQUEST` â†’ nueva instancia por request.
	- `Scope.TRANSIENT` â†’ nueva instancia por cada inyecciÃ³n.

---

## InyecciÃ³n de dependencias avanzada
- **Custom Providers:**
	- Se puede inyectar usando `useClass`, `useExisting`, `useValue`, `useFactory`.
	- Ejemplo:
		{% raw %}
```ts
		@Module({
			providers: [
				{
					provide: 'PAYMENT_REPOSITORY',
					useClass: PostgresPaymentRepository,
				},
			],
		})
		```
{% endraw %}
- **Circular dependencies:** 
	- Resolver con `forwardRef(() => ServiceA)` cuando dos mÃ³dulos dependen entre sÃ­.
- **Value providers:** Ãºtil para constantes globales o tokens de configuraciÃ³n.

---

## Middleware, Guards, Pipes e Interceptors
### Middleware
- Ejecutan antes de llegar a los controladores.
- Implementan `NestMiddleware` y se aplican con `app.use()` o en el mÃ³dulo.
	{% raw %}
```ts
	app.use(loggerMiddleware);
	```
{% endraw %}

### Guards
- Controlan acceso y autorizaciÃ³n.
- Retornan `true` o `false` segÃºn permisos o roles.
	{% raw %}
```ts
	@UseGuards(AuthGuard)
	@Get('profile')
	getProfile() {}
	```
{% endraw %}

### Pipes
- Validan y transforman los datos entrantes.
	- `ValidationPipe`, `ParseIntPipe`, o pipes personalizados.
	- Se aplican globalmente: 
		{% raw %}
```ts
		app.useGlobalPipes(new ValidationPipe({ whitelist: true }));
		```
{% endraw %}

### Interceptors
- Modifican las respuestas, loguean o miden tiempos.
	- Ejemplo: LoggingInterceptor, TransformInterceptor.
	{% raw %}
```ts
	@UseInterceptors(LoggingInterceptor)
	@Get()
	findAll() {}
	```
{% endraw %}

---

## Microservicios y comunicaciÃ³n distribuida
- NestJS permite crear **microservicios nativos** mediante el mÃ³dulo `@nestjs/microservices`.
- Soporta distintos **transportes**:
	- `TCP`, `Redis`, `MQTT`, `NATS`, `Kafka`, `gRPC`.
- Ejemplo de microservicio con **Redis transport**:
	{% raw %}
```ts
	const app = await NestFactory.createMicroservice(AppModule, {
		transport: Transport.REDIS,
		options: { url: 'redis://localhost:6379' },
	});
	app.listen();
	```
{% endraw %}
- Uso de `@MessagePattern()` en lugar de `@Controller()` para procesar eventos.
- IntegraciÃ³n natural con patrones **CQRS** y **Event Sourcing**.

---

## CQRS y Event Sourcing
- **CQRS (Command Query Responsibility Segregation)** separa operaciones de lectura y escritura.
- Compatible con `@nestjs/cqrs`.
	- **Commands:** ejecutan acciones que cambian estado.
	- **Queries:** obtienen datos sin mutarlos.
	- **Events:** notifican cambios.
- Ejemplo:
	{% raw %}
```ts
	export class CreatePaymentCommand {
		constructor(public readonly dto: CreatePaymentDto) {}
	}
	```
{% endraw %}
	{% raw %}
```ts
	@CommandHandler(CreatePaymentCommand)
	export class CreatePaymentHandler {
		constructor(private readonly repo: PaymentRepository) {}

		async execute(command: CreatePaymentCommand) {
			const payment = Payment.create(command.dto);
			await this.repo.save(payment);
		}
	}
	```
{% endraw %}
- El patrÃ³n **Event Sourcing** registra los eventos del dominio en lugar del estado final, ideal para auditorÃ­a y resiliencia.

---

## GraphQL en NestJS
- Soporte nativo mediante `@nestjs/graphql`.
- Basado en `apollo-server` o `Mercurius` (para Fastify).
- Tipado automÃ¡tico a partir de DTOs con decoradores:
	{% raw %}
```ts
	@Resolver(() => User)
	export class UserResolver {
		constructor(private userService: UserService) {}

		@Query(() => [User])
		async users() {
			return this.userService.findAll();
		}
	}
	```
{% endraw %}
- Modos:
	- **Code First:** esquemas generados desde clases TypeScript.
	- **Schema First:** esquemas definidos en archivos `.graphql`.

---

## WebSockets y Gateway en tiempo real
- Basado en `@WebSocketGateway` y `@SubscribeMessage`.
- Compatible con `socket.io` y `ws`.
	{% raw %}
```ts
	@WebSocketGateway()
	export class ChatGateway {
		@SubscribeMessage('message')
		handleMessage(client: Socket, payload: string): void {
			client.broadcast.emit('message', payload);
		}
	}
	```
{% endraw %}
- Ideal para chats, notificaciones, juegos o sistemas colaborativos.

---

## Testing en NestJS
- IntegraciÃ³n directa con **Jest**.
- Tipos de tests:
	- **Unit tests** â†’ testean servicios o lÃ³gica de negocio aislada.
	- **e2e tests** â†’ prueban mÃ³dulos completos usando `@nestjs/testing`.
- Ejemplo de test unitario:
	{% raw %}
```ts
	describe('PaymentsService', () => {
		let service: PaymentsService;

		beforeEach(async () => {
			const module = await Test.createTestingModule({
				providers: [PaymentsService],
			}).compile();
			service = module.get<PaymentsService>(PaymentsService);
		});

		it('should create a payment', () => {
			expect(service.create({ id: '1', amount: 10 })).toBeDefined();
		});
	});
	```
{% endraw %}
- Integrar **coverage reports**, **mocking de repositorios**, y **TestContainers** para bases de datos reales en CI/CD.

---

## OptimizaciÃ³n y despliegue
- **CompilaciÃ³n:** usar SWC o esbuild para tiempos de build menores.
- **MonitorizaciÃ³n:** integrar con Prometheus o OpenTelemetry.
- **Despliegue:**
	- [Kubernetes](/virtualizacion/kubernetes/) con `Helm` o `kustomize`.
	- Escalabilidad horizontal con microservicios y gateways.
	- Integrar pipelines CI/CD para lint, test y build automÃ¡ticos.

---

## Ecosistema y extensiones Ãºtiles
- **NestJS CLI Plugins:**
	- `@nestjs/config` â†’ variables de entorno.
	- `@nestjs/swagger` â†’ documentaciÃ³n automÃ¡tica.
	- `@nestjs/passport` â†’ autenticaciÃ³n JWT, OAuth.
	- `@nestjs/terminus` â†’ health checks.
	- `@nestjs/schedule` â†’ cron jobs.
- **Integraciones recomendadas:**
	- Prisma o TypeORM (ORMs)
	- Redis (cache, pub/sub)
	- [RabbitMQ](/backend/rabbitmq/) o Kafka (mensajerÃ­a)
	- [OpenTelemetry](/monitoreo/opentelemetry/) (monitorizaciÃ³n)
- **Plantillas de referencia:**
	- [nestjs-prisma-starter](https://github.com/notiz-dev/nestjs-prisma-starter)
	- [nestjs-boilerplate](https://github.com/samchon/nestia)

---

## Buenas prÃ¡cticas y principios
- Mantener cada **mÃ³dulo con alta cohesiÃ³n y bajo acoplamiento**.
- Evitar lÃ³gica de negocio en controladores.
- Usar **DTOs** para validar toda entrada externa.
- Desacoplar infraestructura (ORMs, HTTP) del dominio.
- AÃ±adir **decoradores personalizados** para validaciones o logging.
- Modularizar segÃºn **bounded contexts** (DDD).
- Monitorizar tiempos con **Interceptors** y logs estructurados.
- Mantener configuraciÃ³n centralizada con `ConfigService`.

---

## Relacionado
- Arquitectura Hexagonal
- CQRS y Event Sourcing
- Microservicios
- Backend Testing
- [GraphQL](/backend/graphql/)
- [Kubernetes](/virtualizacion/kubernetes/)
 
# NestJS â€“ Arquitectura Aplicada con Patrones Avanzados
`$= dv.current().file.tags.join(" ")`

- NestJS
- Arquitectura Hexagonal
- CQRS y Event Sourcing
- DDD
- Backend Patterns

---

## Enfoque General
Esta arquitectura integra **principios de DDD, CQRS y Event Sourcing** sobre un stack moderno con **Prisma**, **Swagger**, **Auth modular**, y **observabilidad distribuida**.  
El objetivo es mantener **alta escalabilidad, trazabilidad y mantenibilidad** en sistemas complejos o de misiÃ³n crÃ­tica.

---

## 1. Estructura Modular
### Capas Principales
- **Domain:** entidades, value objects, agregados y eventos del dominio.  
- **Application:** casos de uso (commands, queries, handlers).  
- **Infrastructure:** persistencia, adaptadores externos, Prisma, colas, APIs.  
- **Interface:** controladores, resolvers, DTOs, validaciones y Swagger.

### Ejemplo de estructura:
{% raw %}
```

src/
â”œâ”€â”€ domain/
â”‚	â”œâ”€â”€ user.entity.ts
â”‚	â”œâ”€â”€ events/
â”‚	â””â”€â”€ value-objects/
â”œâ”€â”€ application/
â”‚	â”œâ”€â”€ commands/
â”‚	â”œâ”€â”€ queries/
â”‚	â”œâ”€â”€ handlers/
â”‚	â””â”€â”€ services/
â”œâ”€â”€ infrastructure/
â”‚	â”œâ”€â”€ prisma/
â”‚	â”œâ”€â”€ repositories/
â”‚	â””â”€â”€ adapters/
â””â”€â”€ interface/
â”œâ”€â”€ controllers/
â”œâ”€â”€ graphql/
â””â”€â”€ dto/

```
{% endraw %}`

---

## 2. IntegraciÃ³n de CQRS + Event Sourcing
- Se utiliza `@nestjs/cqrs` para separar lectura/escritura y capturar eventos.
- **CommandHandlers** ejecutan acciones de negocio.
- **EventHandlers** persisten o publican eventos.
- **EventStore** centraliza los eventos (por ejemplo, con PostgreSQL o Kafka).

### Ejemplo de Command + Event
{% raw %}
```ts
export class CreateUserCommand {
	constructor(public readonly dto: CreateUserDto) {}
}

@CommandHandler(CreateUserCommand)
export class CreateUserHandler implements ICommandHandler<CreateUserCommand> {
	constructor(
		private readonly repo: UserRepository,
		private readonly eventBus: EventBus
	) {}

	async execute(command: CreateUserCommand) {
		const user = User.create(command.dto);
		await this.repo.save(user);
		this.eventBus.publish(new UserCreatedEvent(user.id));
	}
}
```
{% endraw %}`

### Event Handler

{% raw %}
```ts
@EventsHandler(UserCreatedEvent)
export class UserCreatedHandler implements IEventHandler<UserCreatedEvent> {
	handle(event: UserCreatedEvent) {
		console.log('User created:', event.userId);
	}
}
```
{% endraw %}

---

## 3. Persistencia con Prisma

* Prisma se usa como capa de **infraestructura**, desacoplada del dominio.
* Los **repositorios** implementan interfaces de dominio (`IUserRepository`) para facilitar testeo y mocks.

{% raw %}
```ts
@Injectable()
export class PrismaUserRepository implements IUserRepository {
	constructor(private prisma: PrismaService) {}

	async save(user: User): Promise<void> {
		await this.prisma.user.create({ data: user.toPrimitives() });
	}

	async findById(id: string): Promise<User | null> {
		const data = await this.prisma.user.findUnique({ where: { id } });
		return data ? User.fromPrimitives(data) : null;
	}
}
```
{% endraw %}

---

## 4. DocumentaciÃ³n con Swagger

* Integrar desde `main.ts`:

  {% raw %}
```ts
  const config = new DocumentBuilder()
  	.setTitle('Advanced API')
  	.setDescription('API with CQRS + Prisma + Auth + Observability')
  	.setVersion('1.0')
  	.addBearerAuth()
  	.build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api/docs', app, document);
  ```
{% endraw %}

* Genera documentaciÃ³n interactiva y permite probar endpoints autenticados.
* Combinar con decoradores `@ApiTags`, `@ApiBearerAuth`, `@ApiResponse`.

---

## 5. AutenticaciÃ³n y AutorizaciÃ³n Avanzadas

* Uso de **JWT + Passport** para autenticaciÃ³n modular.
* `AuthModule` define estrategias (`JwtStrategy`, `LocalStrategy`).
* **Guards** controlan acceso segÃºn roles o claims:

  {% raw %}
```ts
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Get('me')
  @ApiBearerAuth()
  getProfile(@Request() req) {
  	return req.user;
  }
  ```
{% endraw %}

* Integrar **RBAC (Role-Based Access Control)** o **ABAC (Attribute-Based Access Control)** mediante decorators personalizados.

---

## 6. Observabilidad, Logging y Tracing

* IntegraciÃ³n con [OpenTelemetry](/monitoreo/opentelemetry/) y Prometheus.
* Cada request puede generar un trace distribuido con `traceId`.
* ConfiguraciÃ³n tÃ­pica:

  {% raw %}
```ts
  import { OpenTelemetryModule } from 'nestjs-otel';

  @Module({
  	imports: [OpenTelemetryModule.forRoot()],
  })
  export class ObservabilityModule {}
  ```
{% endraw %}

* MÃ©tricas expuestas en `/metrics` para Prometheus.
* Logging estructurado con `nestjs-pino` o `winston`:

  {% raw %}
```ts
  app.useLogger(app.get(Logger));
  ```
{% endraw %}

---

## 7. Patrones Compuestos

### Saga + EventBus + Repository

* **Saga** coordina varios pasos distribuidos.

  * Escucha eventos y dispara comandos segÃºn el flujo.

  {% raw %}
```ts
  @Saga()
  export class PaymentSaga {
  	userCreated = (events$: Observable<UserCreatedEvent>) =>
  		events$.pipe(
  			map(event => new InitializePaymentCommand(event.userId))
  		);
  }
  ```
{% endraw %}

### Factory + Strategy dentro del dominio

* **Factory** crea entidades o agregados coherentes.
* **Strategy** aplica diferentes polÃ­ticas de negocio (p.e. cÃ¡lculo de comisiones).

  {% raw %}
```ts
  export interface PaymentStrategy {
  	calculate(amount: number): number;
  }
  ```
{% endraw %}

  {% raw %}
```ts
  export class PremiumPaymentStrategy implements PaymentStrategy {
  	calculate(amount: number) {
  		return amount * 0.9;
  	}
  }
  ```
{% endraw %}

---

## 8. Testing de Arquitectura Completa

* Unit testing con `jest.mock()` para repositorios.
* Integration testing con `Test.createTestingModule`.
* **e2e testing** simulando el flujo CQRS completo con `supertest`.

Ejemplo e2e:

{% raw %}
```ts
describe('User lifecycle (e2e)', () => {
	let app: INestApplication;

	beforeAll(async () => {
		const moduleFixture = await Test.createTestingModule({
			imports: [AppModule],
		}).compile();

		app = moduleFixture.createNestApplication();
		await app.init();
	});

	it('/POST user', async () => {
		return request(app.getHttpServer())
			.post('/users')
			.send({ name: 'Alice', email: 'alice@mail.com' })
			.expect(201);
	});
});
```
{% endraw %}

---

## 9. CI/CD y despliegue

* **Lint + Test + Build + Deploy** en pipelines automÃ¡ticos.
* Versionado semÃ¡ntico y publicaciÃ³n con `nx release` o `semantic-release`.
* IntegraciÃ³n con Docker y [Kubernetes](/virtualizacion/kubernetes/).
* Variables seguras gestionadas por Vault o `AWS Secrets Manager`.
* Despliegue multi-entorno (dev/staging/prod) con configuraciÃ³n por mÃ³dulo dinÃ¡mico.

---

## 10. Beneficios y conclusiones

* Escalabilidad horizontal gracias a **CQRS + Microservicios**.
* Trazabilidad completa mediante **Event Sourcing + Observabilidad**.
* Consistencia y testabilidad por **repositorios tipados e interfaces claras**.
* Adaptable a cualquier dominio con mÃ­nima fricciÃ³n tÃ©cnica.

---

## Relacionado

* NestJS â€“ Avanzado y Ecosistema
* Arquitectura Hexagonal
* CQRS y Event Sourcing
* DDD
* Observabilidad
* Auth y Seguridad Backend

# NestJS â€“ Caso PrÃ¡ctico Completo: User + Payment Service
`$= dv.current().file.tags.join(" ")`

- NestJS
- CQRS y Event Sourcing
- Arquitectura Hexagonal
- Prisma
- Auth y Seguridad Backend
- Observabilidad
- DDD

---

## ğŸŒ VisiÃ³n General del Microservicio

Este ejemplo muestra un **microservicio realista** que maneja **usuarios y pagos**.  
Combina:
- **CQRS** (Command/Query separation)
- **Prisma** (persistencia desacoplada)
- **EventBus** (propagaciÃ³n de eventos)
- **JWT Auth** (seguridad modular)
- **Observabilidad distribuida**

El objetivo es ilustrar cÃ³mo aplicar **arquitectura hexagonal + patrones DDD** de forma **mantenible y escalable**.

---

## ğŸ§© Estructura de Carpetas

{% raw %}
```

src/
â”œâ”€â”€ domain/
â”‚	â”œâ”€â”€ user/
â”‚	â”‚	â”œâ”€â”€ user.entity.ts
â”‚	â”‚	â””â”€â”€ events/
â”‚	â”œâ”€â”€ payment/
â”‚	â”‚	â”œâ”€â”€ payment.entity.ts
â”‚	â”‚	â””â”€â”€ events/
â”‚	â””â”€â”€ shared/
â”‚		â””â”€â”€ value-objects/
â”‚
â”œâ”€â”€ application/
â”‚	â”œâ”€â”€ user/
â”‚	â”‚	â”œâ”€â”€ commands/
â”‚	â”‚	â”œâ”€â”€ queries/
â”‚	â”‚	â””â”€â”€ handlers/
â”‚	â”œâ”€â”€ payment/
â”‚	â”‚	â”œâ”€â”€ commands/
â”‚	â”‚	â”œâ”€â”€ queries/
â”‚	â”‚	â””â”€â”€ handlers/
â”‚	â””â”€â”€ common/
â”‚		â””â”€â”€ interfaces/
â”‚
â”œâ”€â”€ infrastructure/
â”‚	â”œâ”€â”€ prisma/
â”‚	â”‚	â””â”€â”€ prisma.service.ts
â”‚	â”œâ”€â”€ repositories/
â”‚	â”‚	â”œâ”€â”€ user.repository.ts
â”‚	â”‚	â””â”€â”€ payment.repository.ts
â”‚	â””â”€â”€ event-bus/
â”‚		â””â”€â”€ event.module.ts
â”‚
â””â”€â”€ interface/
â”œâ”€â”€ controllers/
â”‚	â”œâ”€â”€ user.controller.ts
â”‚	â””â”€â”€ payment.controller.ts
â”œâ”€â”€ dto/
â””â”€â”€ auth/
â”œâ”€â”€ jwt.strategy.ts
â””â”€â”€ auth.guard.ts

```
{% endraw %}`

---

## ğŸ§  Dominio

### Entidad User
{% raw %}
```ts
export class User {
	constructor(
		private readonly id: string,
		private readonly email: string,
		private readonly balance: number = 0
	) {}

	static create(email: string): User {
		const id = crypto.randomUUID();
		return new User(id, email, 0);
	}

	increaseBalance(amount: number): User {
		return new User(this.id, this.email, this.balance + amount);
	}

	toPrimitives() {
		return { id: this.id, email: this.email, balance: this.balance };
	}
}
```
{% endraw %}`

### Entidad Payment

{% raw %}
```ts
export class Payment {
	constructor(
		private readonly id: string,
		private readonly userId: string,
		private readonly amount: number,
		private readonly timestamp: Date
	) {}

	static create(userId: string, amount: number): Payment {
		return new Payment(crypto.randomUUID(), userId, amount, new Date());
	}

	toPrimitives() {
		return {
			id: this.id,
			userId: this.userId,
			amount: this.amount,
			timestamp: this.timestamp,
		};
	}
}
```
{% endraw %}

---

## âš™ï¸ AplicaciÃ³n (CQRS)

### Command: CreatePaymentCommand

{% raw %}
```ts
export class CreatePaymentCommand {
	constructor(
		public readonly userId: string,
		public readonly amount: number
	) {}
}
```
{% endraw %}

### CommandHandler

{% raw %}
```ts
@CommandHandler(CreatePaymentCommand)
export class CreatePaymentHandler implements ICommandHandler<CreatePaymentCommand> {
	constructor(
		private readonly paymentRepo: PaymentRepository,
		private readonly userRepo: UserRepository,
		private readonly eventBus: EventBus
	) {}

	async execute(command: CreatePaymentCommand): Promise<void> {
		const user = await this.userRepo.findById(command.userId);
		if (!user) throw new Error('User not found');

		const payment = Payment.create(user.id, command.amount);
		await this.paymentRepo.save(payment);

		const updated = user.increaseBalance(command.amount);
		await this.userRepo.save(updated);

		this.eventBus.publish(new PaymentCreatedEvent(payment.id, user.id));
	}
}
```
{% endraw %}

### Event

{% raw %}
```ts
export class PaymentCreatedEvent {
	constructor(
		public readonly paymentId: string,
		public readonly userId: string
	) {}
}
```
{% endraw %}

---

## ğŸ§± Infraestructura

### Prisma Repository (implementa interfaces)

{% raw %}
```ts
@Injectable()
export class PrismaUserRepository implements UserRepository {
	constructor(private prisma: PrismaService) {}

	async findById(id: string): Promise<User | null> {
		const data = await this.prisma.user.findUnique({ where: { id } });
		return data ? new User(data.id, data.email, data.balance) : null;
	}

	async save(user: User): Promise<void> {
		await this.prisma.user.upsert({
			where: { id: user.toPrimitives().id },
			create: user.toPrimitives(),
			update: user.toPrimitives(),
		});
	}
}
```
{% endraw %}

### EventBus (in-memory o Kafka)

{% raw %}
```ts
@Module({
	imports: [CqrsModule],
	providers: [],
	exports: [CqrsModule],
})
export class EventBusModule {}
```
{% endraw %}

---

## ğŸ”’ AutenticaciÃ³n (JWT)

{% raw %}
```ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
	constructor() {
		super({
			jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
			ignoreExpiration: false,
			secretOrKey: process.env.JWT_SECRET,
		});
	}

	async validate(payload: any) {
		return { userId: payload.sub, email: payload.email };
	}
}

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```
{% endraw %}

---

## ğŸŒ Interfaz (HTTP Layer)

### Controlador de Users

{% raw %}
```ts
@ApiTags('users')
@Controller('users')
export class UserController {
	constructor(private readonly userRepo: UserRepository) {}

	@Post()
	async create(@Body() dto: { email: string }) {
		const user = User.create(dto.email);
		await this.userRepo.save(user);
		return user.toPrimitives();
	}

	@Get(':id')
	async getById(@Param('id') id: string) {
		const user = await this.userRepo.findById(id);
		return user ? user.toPrimitives() : { error: 'Not found' };
	}
}
```
{% endraw %}

### Controlador de Payments

{% raw %}
```ts
@ApiTags('payments')
@Controller('payments')
@UseGuards(JwtAuthGuard)
export class PaymentController {
	constructor(private commandBus: CommandBus) {}

	@Post()
	async createPayment(@Body() dto: { userId: string; amount: number }) {
		await this.commandBus.execute(new CreatePaymentCommand(dto.userId, dto.amount));
		return { message: 'Payment processed' };
	}
}
```
{% endraw %}

---

## ğŸ“Š Observabilidad

IntegraciÃ³n con [OpenTelemetry](/monitoreo/opentelemetry/):

{% raw %}
```ts
@Module({
	imports: [
		OpenTelemetryModule.forRoot({
			metrics: { hostMetrics: true, apiMetrics: { enable: true } },
		}),
	],
})
export class ObservabilityModule {}
```
{% endraw %}

* Logs con `nestjs-pino`:

  {% raw %}
```ts
  app.useLogger(app.get(Logger));
  ```
{% endraw %}
* Endpoint `/metrics` para Prometheus.

---

## ğŸ§ª Testing de Flujo Completo

### Prueba e2e del ciclo User â†’ Payment

{% raw %}
```ts
describe('User + Payment flow (e2e)', () => {
	let app: INestApplication;

	beforeAll(async () => {
		const moduleRef = await Test.createTestingModule({
			imports: [AppModule],
		}).compile();

		app = moduleRef.createNestApplication();
		await app.init();
	});

	it('should create a user and process payment', async () => {
		const user = await request(app.getHttpServer())
			.post('/users')
			.send({ email: 'test@mail.com' })
			.expect(201);

		await request(app.getHttpServer())
			.post('/payments')
			.send({ userId: user.body.id, amount: 100 })
			.set('Authorization', `Bearer ${process.env.JWT}`)
			.expect(201);
	});
});
```
{% endraw %}

---

## ğŸš€ Beneficios del Caso

* **Dominio agnÃ³stico** de la infraestructura.
* **SeparaciÃ³n clara CQRS:** Commands â†’ cambios, Queries â†’ lectura.
* **Escalabilidad horizontal:** microservicios desacoplados.
* **EventBus extensible:** posible integraciÃ³n con Kafka/NATS.
* **Testing y trazabilidad completas.**

---

## ğŸ“š Referencias Relacionadas

* NestJS â€“ Arquitectura Aplicada con Patrones Avanzados
* CQRS y Event Sourcing
* Arquitectura Hexagonal
* Auth y Seguridad Backend
* Observabilidad
* Prisma
* DDD



# Omnivore NestJS
{% raw %}
```base
type: list
name: "Notas con #nestjs en Omnivore"
order:
  - property: date_saved
    direction: desc
columns:
  - file.name
  - date_saved
filters:
  and:
    - file.inFolder("Omnivore")
    - file.hasTag("nestjs", "Nestjs")
views:
  - type: table
    name: Table
    sort:
      - property: file.mtime
        direction: DESC
```
{% endraw %}`


