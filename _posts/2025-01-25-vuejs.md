---
date: 2025-01-25 05:06
title: vuejs
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: Frontend
tags:
  - vuejs
  - JS
  - frontend
---
# vuejs

- [Frontend](/frontend/frontend/)
- [vite](/automatizacion%20y%20build/vite/)
- app para citas con vue
- composition api

## docs
- [Introduction | Vue.js](https://vuejs.org/guide/introduction.html)
- Vue.js-introduction.html
- DeepSeek-django-vs-vue
## conceptos
- **Templates**
	- Sistema declarativo para estructurar la UI.
	- Permite interpolaci√≥n, directivas y binding reactivo.
	- Soporta sintaxis extendida con `v-if`, `v-for`, `v-bind`, `v-model`.
- **Routing**
	- Manejo de navegaci√≥n con Vue Router.
	- Soporta rutas din√°micas, lazy loading, nested routes.
	- Integraci√≥n con history API y transici√≥n entre vistas.
- **Components**
	- Unidad principal de reutilizaci√≥n y encapsulaci√≥n.
	- Comunicaci√≥n entre componentes:
		- Props ‚Üí flujo descendente
		- Emits ‚Üí flujo ascendente
		- Provide/Inject ‚Üí comunicaci√≥n profunda
	- Componentes funcionales, slots y scoped slots.
- **State Management (Pinia vs Vuex)**
	- De Vuex a Pinia, la gesti√≥n de estados definitiva para Vue-
	- Getting Started  Pinia-getting-started.html
	- Introduction  Pinia-introduction.html
	- Pinia vs Vuex Gu√≠a Comparativa ¬øCu√°l es Mejor-pinia-vs-vuex-cual-es-mejor

	- **Pinia**
		- API moderna basada en Composition API.
		- Tipado autom√°tico con TypeScript.
		- Soporte para devtools avanzado.
		- Mutaciones no obligatorias; sintaxis m√°s simple.

	- **Vuex**
		- M√°s verboso, basado en opciones.
		- Enfocado en un patr√≥n m√°s predecible con Mutations/Actions.
		- A√∫n √∫til en apps legacy.

	- **Composition API**
		- Unificaci√≥n l√≥gica y reusabilidad mejorada.
		- Hooks internos (`computed`, `ref`, `reactive`, `watch`).
		- Mejora la escalabilidad de proyectos grandes.
- **Build**
	- [Automatizacion y Build](/automatizacion%20y%20build/automatizacion-y-build/)
	- Bundlers recomendados:
		- Vite (el est√°ndar actual por velocidad y DX).
		- Webpack solo para proyectos legacy.
	- Soporte para HMR y tree-shaking nativo.
- **Virtual DOM**
	- Optimizaci√≥n del render mediante un DOM virtual.
	- Comparaci√≥n eficiente entre estados previos y nuevos.
	- Menor coste en operaciones de UI complejas.
- **Reactividad**
	- Basada en proxies.
	- `ref`, `reactive`, `computed`, `watch`, `effectScope`.
	- Sistema eficiente para detectar dependencias y actualizar vistas.
- **Directivas**
	- `v-if`, `v-for`, `v-bind`, `v-on`, `v-show`, `v-model`.
	- Directivas personalizadas para comportamiento espec√≠fico.
- **Framework progresivo**
	- Aprende-gradualmente: desde peque√±os widgets hasta grandes SPAs.
	- Integraci√≥n f√°cil con proyectos existentes.
- **Usar create en vez de CLI tool**
	- Recomendado usar: ``npm create vue@latest``
	- CLI tradicional (`vue-cli`) est√° deprecado.
	- `create-vue` integra Vite por defecto.
# vuejs ‚Äî conceptos avanzados 
## arquitectura del framework
- **Runtime + Compiler**
	- Vue ofrece compilaci√≥n en tiempo de construcci√≥n y tambi√©n en el navegador.
	- El compilador transforma templates en funciones render altamente optimizadas.
	- El runtime gestiona el re-render reactivo.

- **Options API vs Composition API**
	- Options API sigue siendo v√°lida para proyectos peque√±os o legacy.
	- Composition API es el est√°ndar moderno:
		- Mayor reutilizaci√≥n l√≥gica.
		- Mejor organizaci√≥n interna.
		- Tipado m√°s robusto con TypeScript.

## ecosistema oficial
- **Vue Router**
	- Protecci√≥n de rutas (guards).
	- Transiciones entre vistas.
	- Rutas anidadas, rutas hijas din√°micas, alias y redirecciones.

- **Pinia (state)**
	- Stores m√°s peque√±os y modulables.
	- Plugins para persistencia, undo/redo, logger.
	- Integraci√≥n con SSR.

- **Vite**
	- Dev server ultra r√°pido.
	- Soporte nativo para TypeScript, JSX y HMR.
	- Configuraci√≥n sencilla con `vite.config.js`.

## server-side rendering (SSR)
- **Nuxt.js**
	- Meta-framework basado en Vue.
	- SSR, SSG, routing autom√°tico.
	- APIs server-side integradas (Nitro).
	- Perfecto para SEO, apps complejas o contenido din√°mico.

- **Hydration**
	- Proceso donde el cliente toma el HTML generado por el servidor y lo hace interactivo.
	- Vue soporta hydration parcial y optimizada.

## performance y optimizaci√≥n
- **Lazy Loading**
	- Dividir el bundle en partes y cargar vistas bajo demanda.
	- Mejora inicial de rendimiento en apps grandes.

- **Memoizaci√≥n con `computed`**
	- C√°lculo cach√© dependiente de estado reactivo.
	- Evita re-render innecesario.

- **Suspense**
	- Permite mostrar estados de carga declarativos.
	- Integraci√≥n natural con componentes async.

- **Teleport**
	- Renderiza contenido fuera del √°rbol del componente.
	- Ideal para modales, overlays y tooltips.

## patrones avanzados
- **Render Functions & JSX**
	- Control granular sobre el DOM virtual.
	- √ötil para bibliotecas UI o componentes altamente din√°micos.

- **Custom Composables**
	- Encapsulaci√≥n de l√≥gica compleja en funciones reutilizables:
		- useFetch
		- useForm
		- useDarkMode

- **Provide / Inject avanzado**
	- Flujo de datos profundo en √°rbol de componentes.
	- Ideal para temas, i18n, stores simples.

- **Plugins**
	- A√±aden funcionalidades globales a la app.
	- Ejemplos: trackers, gestores de errores, formateadores.

## testing
- **Vitest**
	- Reemplazo moderno a Jest.
	- Integraci√≥n natural con Vite + Vue.

- **Vue Test Utils**
	- Testing unitario de componentes.
	- Renderizado aislado, mocks y simulaci√≥n de eventos.

## tooling y productividad
- **TypeScript**
	- Soporte nativo en SFC (`<script setup lang="ts">`).
	- Tipos para props, emits y stores Pinia.

- **Devtools**
	- Inspecci√≥n del estado, componentes, rutas y stores.
	- Time-travel debugging.

- **SFC `<script setup>`**
	- Sintaxis m√°s compacta.
	- Eliminaci√≥n de boilerplate.
	- Importaciones autom√°ticas (con unplugin-auto-import).

## integraciones comunes
- **UI frameworks**
	- Element Plus
	- Vuetify
	- Naive UI
	- Quasar

- **Internacionalizaci√≥n**
	- Vue I18n con lazy loading de idiomas.
	- Soporte para fallback, plurales y formatos de tiempo/moneda.

- **Animaciones**
	- `Transition` y `TransitionGroup`.
	- Integraci√≥n fluida con GSAP o Motion One.

## ejemplos de c√≥digo

### ejemplo ‚Äî componente b√°sico
{% raw %}
```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
const increment = () => count.value++
</script>

<template>
<button @click="increment">Clicks: {{ count }}</button>
</template>
```
{% endraw %}`

### ejemplo ‚Äî store pinia

{% raw %}
```js
import { defineStore } from 'pinia'

export const useCounter = defineStore('counter', {
state: () => ({ count: 0 }),
actions: {
	inc() { this.count++ }
}
})
```
{% endraw %}

### ejemplo ‚Äî composable

{% raw %}
```js
import { ref, onMounted } from 'vue'

export function useFetch(url) {
const data = ref(null)
const loading = ref(true)

onMounted(async () => {
	const res = await fetch(url)
	data.value = await res.json()
	loading.value = false
})

return { data, loading }
}
```
{% endraw %}

## recursos recomendados

- Documentaci√≥n oficial: [Vue.js Guide](https://vuejs.org/guide/introduction.html)
- Router: https://router.vuejs.org
- Pinia: https://pinia.vuejs.org
- Vite: https://vitejs.dev
- Nuxt: https://nuxt.com

# vuejs 2025 ‚Äî estado actual, novedades y buenas pr√°cticas

## visi√≥n general y contexto

- Vue.js sigue siendo un framework progresivo centrado en la capa ‚Äúview‚Äù.
- Vue 3 es el est√°ndar desde hace a√±os, con todo el ecosistema alineado: Router, Pinia, Vite, Devtools.
- El enfoque modular sigue siendo clave: eliges solo lo que necesitas.

## principales cambios y mejoras recientes (2024‚Äì2025)

- **Rendimiento (Core + Vite)**
	- Parser de templates m√°s r√°pido.
	- Optimizaciones en el sistema de reactividad y efectos.
	- Vite es la herramienta de build por defecto:
		- Arranque inmediato.
		- HMR sin retrasos.
		- Tree-shaking y bundles optimizados.

- **DX modernizada**
	- Pinia reemplaza definitivamente a Vuex.
	- DevTools con mejor inspecci√≥n, timeline, profiling y an√°lisis de rendimiento.
	- Mejor integraci√≥n con TypeScript.

- **Ecosistema**
	- VitePress estable como SSG moderno.
	- Nuxt (3.x ‚Üí 4.x) como meta-framework consolidado para SSR/SSG.

## buenas pr√°cticas recomendadas en 2025

- Usa **Composition API + `<script setup>` + TypeScript** para mayor claridad y escalabilidad.
- Usa **Pinia** para estado global.
- Usa **Vite** para cualquier proyecto Vue moderno.
- Para SSR/SSG/SEO, usa **Nuxt**.
- Evita librer√≠as o plugins que sigan anclados en Vue 2.

## estado del ecosistema 2025

- Compatibilidad con Vue 2 es m√≠nima: la mayor√≠a de librer√≠as ya no la soportan.
- Pinia 3 consolida su orientaci√≥n √∫nicamente a Vue 3.
- Ecosistema m√°s uniforme en torno a:
	- TypeScript
	- Composition API
	- ESM
	- Vite

## tendencias 2025

- Mayor adopci√≥n de Vitest como est√°ndar de testing.
- Crecimiento de meta-frameworks centrados en ‚Äúfrontend + server + SSG/SSR‚Äù.
- Expansi√≥n de herramientas de DX: auto-imports, inspecci√≥n en tiempo real, visualizadores de dependencias.

## recursos oficiales y actualizados (formato obsidian)

- [Documentaci√≥n oficial Vue.js](https://vuejs.org/guide/introduction.html)
- [Vue Router](https://router.vuejs.org)
- [Pinia ‚Äî State Management](https://pinia.vuejs.org)
- [Vite](https://vitejs.dev)
- [VitePress](https://vitepress.dev)
- [Nuxt](https://nuxt.com)
- [Blog oficial de Vue](https://blog.vuejs.org)
- [Blog de Nuxt](https://nuxt.com/blog)

# Vue.js ‚Äî Cheatsheet Completo (2025)

## setup b√°sico

### crear proyecto
{% raw %}
```bash
npm create vue@latest
```
{% endraw %}`

### estructura t√≠pica

{% raw %}
```html
/src
	/components
	/pages
	/composables
	/stores
	/router
	/assets
```
{% endraw %}

---

## single file components (SFC)

### script setup (recomendado)

{% raw %}
```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)
</script>
```
{% endraw %}

### template

{% raw %}
```vue
<template>
	<p>{{ count }}</p>
</template>
```
{% endraw %}

### estilos scoped

{% raw %}
```vue
<style scoped>
p { color: #42b883; }
</style>
```
{% endraw %}

---

## reactividad

### ref

{% raw %}
```js
const n = ref(0)
n.value++        // siempre .value
```
{% endraw %}

### reactive

{% raw %}
```js
const user = reactive({ name: 'Ana', age: 20 })
user.age++
```
{% endraw %}

### computed

{% raw %}
```js
const total = computed(() => price.value * qty.value)
```
{% endraw %}

### watch

{% raw %}
```js
watch(count, (newVal, oldVal) => {
	console.log(newVal)
})
```
{% endraw %}

### watchEffect

{% raw %}
```js
watchEffect(() => {
	console.log(user.age)
})
```
{% endraw %}

---

## props y comunicaci√≥n

### props

{% raw %}
```vue
<script setup>
defineProps({
	title: String,
	size: { type: Number, default: 20 }
})
</script>
```
{% endraw %}

### emits

{% raw %}
```vue
<script setup>
const emit = defineEmits(['save'])
emit('save', { id: 1 })
</script>
```
{% endraw %}

### slots

{% raw %}
```vue
<slot name="header" />
```
{% endraw %}

---

## directivas esenciales

- `v-if`, `v-else-if`, `v-else`
- `v-for="item in list"`
- `v-bind="props"` ‚Üí `:prop`
- `v-on="events"` ‚Üí `@click`
- `v-model` (form controls y componentes)
- `v-show` (toggle CSS display)
- `v-html` (‚ö†Ô∏è sanitizar)

---

## hooks del ciclo de vida

{% raw %}
```js
onMounted(() => {})
onUnmounted(() => {})
onUpdated(() => {})
onBeforeMount(() => {})
onBeforeUpdate(() => {})
onBeforeUnmount(() => {})
```
{% endraw %}

---

## router (Vue Router)

### definir rutas

{% raw %}
```js
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
	{ path: '/', component: Home },
	{ path: '/user/:id', component: User, props: true }
]

export const router = createRouter({
	history: createWebHistory(),
	routes
})
```
{% endraw %}

### navegaci√≥n

{% raw %}
```js
router.push('/dashboard')
router.push({ name: 'user', params: { id: 10 } })
```
{% endraw %}

### ruta actual

{% raw %}
```js
const route = useRoute()
console.log(route.params.id)
```
{% endraw %}

---

## pinia (state management)

### crear store

{% raw %}
```js
import { defineStore } from 'pinia'

export const useCounter = defineStore('counter', {
	state: () => ({ n: 0 }),
	actions: {
		inc() { this.n++ }
	}
})
```
{% endraw %}

### usar store

{% raw %}
```js
const counter = useCounter()
counter.inc()
```
{% endraw %}

---

## composables (Composition API)

### crear un composable

{% raw %}
```js
export function useFetch(url) {
	const data = ref(null)
	const loading = ref(true)

	onMounted(async () => {
		const res = await fetch(url)
		data.value = await res.json()
		loading.value = false
	})

	return { data, loading }
}
```
{% endraw %}

### uso

{% raw %}
```js
const { data, loading } = useFetch('/api/posts')
```
{% endraw %}

---

## patrones comunes

### debounced reactive watcher

{% raw %}
```js
import { watch } from 'vue'
import debounce from 'lodash.debounce'

watch(searchTerm, debounce(val => {
	console.log('Buscando:', val)
}, 300))
```
{% endraw %}

### two-way binding personalizado

{% raw %}
```js
defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])

function update(v) {
	emit('update:modelValue', v)
}
```
{% endraw %}

---

## optimizaci√≥n

### lazy loading de componentes

{% raw %}
```js
const Modal = defineAsyncComponent(() => import('./Modal.vue'))
```
{% endraw %}

### teleport

{% raw %}
```vue
<teleport to="#modals">
	<MyModal />
</teleport>
```
{% endraw %}

### Suspense (componentes async)

{% raw %}
```vue
<Suspense>
	<template #default>
		<AsyncComponent />
	</template>
	<template #fallback>
		Cargando...
	</template>
</Suspense>
```
{% endraw %}

---

## animaciones

### transici√≥n simple

{% raw %}
```vue
<transition name="fade">
	<p v-if="show">Hola</p>
</transition>

<style>
.fade-enter-active, .fade-leave-active { transition: opacity .3s; }
.fade-enter-from, .fade-leave-to { opacity: 0; }
</style>
```
{% endraw %}

---

## testing (Vitest)

{% raw %}
```js
import { mount } from '@vue/test-utils'
import { describe, it, expect } from 'vitest'
import Counter from './Counter.vue'

describe('Counter', () => {
	it('incrementa', () => {
		const wrapper = mount(Counter)
		wrapper.find('button').trigger('click')
		expect(wrapper.text()).toContain('1')
	})
})
```
{% endraw %}

---

## tips avanzados (2025)

- Usa `<script setup>` siempre que sea posible.
- Usa auto-imports (unplugin-auto-import, unplugin-vue-components).
- Evita librer√≠as no migradas a Vue 3.
- Usa Pinia en lugar de Vuex.
- Divide la l√≥gica en composables peque√±os y at√≥micos.
- Coloca l√≥gica compleja fuera del template (no en `v-if` largos).
- Para SSR/SSG usa Nuxt.
- Aprovecha las DevTools para perf y traceo de renders.
- Usa defineModel (cuando exista en tu versi√≥n) para simplificar v-models personalizados.

---

## recursos recomendados

- [Vue.js Docs](https://vuejs.org/guide/introduction.html)
- [Router](https://router.vuejs.org)
- [Pinia](https://pinia.vuejs.org)
- [Vite](https://vitejs.dev)
- [Nuxt](https://nuxt.com)
- [VitePress](https://vitepress.dev)

# Vue.js ‚Äî Cheatsheet avanzado (2025)  
*(Solo t√©cnicas, patrones y particularidades)

## patrones de reactividad avanzados

### getters reactivos sin computed
{% raw %}
```js
const state = reactive({ a: 1, b: 2 })
const sum = () => state.a + state.b
```
{% endraw %}`

### refs esquematizados (shallow)

{% raw %}
```js
const user = shallowRef({ name: 'Ana' })
user.value.name = 'Luis'   // no dispara reactividad
user.value = { name: 'Marta' } // s√≠ reacciona
```
{% endraw %}

### readonly + shallowReadonly

{% raw %}
```js
const config = readonly({ theme: 'dark' })
```
{% endraw %}

---

## t√©cnicas modernas con `<script setup>`

### definir props + emits con tipos

{% raw %}
```vue
<script setup lang="ts">
const props = defineProps<{ id: number; active?: boolean }>()
const emit = defineEmits<{ (e: 'toggle', v: boolean): void }>()
</script>
```
{% endraw %}

### inyecci√≥n de tipos a slots

{% raw %}
```vue
<script setup lang="ts">
interface Slots {
default: (props: { msg: string }) => any
}
const slots = defineSlots<Slots>()
</script>
```
{% endraw %}

---

## control de flujo y optimizaci√≥n del render

### `v-memo` ‚Äî evitar renders innecesarios

{% raw %}
```vue
<div v-memo="[user.id]">{{ user.name }}</div>
```
{% endraw %}

### `v-once` para contenido est√°tico

{% raw %}
```vue
<h1 v-once>{{ title }}</h1>
```
{% endraw %}

### fragmentos condicionales eficientes

{% raw %}
```vue
<template v-if="ok">
<A />
<B />
</template>
```
{% endraw %}

---

## t√©cnicas de routing avanzadas

### props din√°micos directamente desde la ruta

{% raw %}
```js
{
path: '/u/:id',
component: User,
props: route => ({ id: Number(route.params.id) })
}
```
{% endraw %}

### suspender navegaci√≥n hasta una promesa

{% raw %}
```js
router.beforeEach(async () => {
await fetch('/check-session')
})
```
{% endraw %}

### scroll inteligente

{% raw %}
```js
scrollBehavior(_, __, saved) {
return saved ?? { top: 0 }
}
```
{% endraw %}

---

## patrones profesionales con Pinia

### stores din√°micos por instancia

{% raw %}
```js
export const useScoped = (scope) =>
defineStore(`store-${scope}`, { state: () => ({ n: 0 }) })()
```
{% endraw %}

### hidratar store desde SSR / persistencia

{% raw %}
```js
const store = useUserStore()
store.$patch(JSON.parse(localStorage.user))
```
{% endraw %}

### interceptar acciones

{% raw %}
```js
store.$onAction(({ name, args, after }) => {
after(() => console.log(`${name} OK`, args))
})
```
{% endraw %}

---

## composables avanzados

### composable con abort controller

{% raw %}
```js
export function useAbortableFetch(url) {
const data = ref(null)
const controller = new AbortController()

const run = async () => {
	const res = await fetch(url, { signal: controller.signal })
	data.value = await res.json()
}

onUnmounted(() => controller.abort())

return { data, run }
}
```
{% endraw %}

### exposiciones selectivas

{% raw %}
```js
defineExpose({
refresh() { /* ‚Ä¶ */ }
})
```
{% endraw %}

### usar instancias globales dentro de composables

{% raw %}
```js
const router = useRouter()
const route = useRoute()
```
{% endraw %}

---

## particularidades del template

### `key` inteligente en listas derivadas

{% raw %}
```vue
<li v-for="item in list" :key="item.id ?? item.name">
```
{% endraw %}

### slots + fallbacks

{% raw %}
```vue
<slot name="footer">Default footer</slot>
```
{% endraw %}

### eventos nativos en componentes

{% raw %}
```vue
<MyInput @focus.native="onFocus"/>
```
{% endraw %}

---

## utilidades del runtime √∫tiles para pro apps

### `nextTick`

{% raw %}
```js
await nextTick()
// DOM ya actualizado
```
{% endraw %}

### definir componentes inline

{% raw %}
```vue
<component :is="dynamicComponent"/>
```
{% endraw %}

### reutilizar watchers de forma program√°tica

{% raw %}
```js
const stop = watch(source, handler)
// ‚Ä¶
stop()
```
{% endraw %}

---

## patrones recomendados de arquitectura 2025

- Organiza logic en **composables at√≥micos**, no en mega-composables.
- Separa **UI components** de **feature components**.
- Usa **auto-imports** para composables, stores y componentes.
- Evita usar `v-if` y `v-for` en el mismo nodo (divide el nodo).
- Para listas grandes usa **virtual scrollers** (Vue Virtual Scroll List, virtua).
- Prefiere **eventos espec√≠ficos** en vez de estados globales innecesarios.
- Usa **async components** para rutas pesadas.
- Para formularios complejos usa librer√≠as tipadas (FormKit, Vee-Validate).

---

## patrones avanzados de integrate con API

### gesti√≥n de cache manual reactiva

{% raw %}
```js
const cache = reactive(new Map())

async function fetchCached(key, fn) {
if (!cache.has(key)) cache.set(key, await fn())
return cache.get(key)
}
```
{% endraw %}

### manejar estados: idle / loading / success / error

{% raw %}
```js
const state = reactive({
status: 'idle', data: null, error: null
})

async function run() {
try {
	state.status = 'loading'
	const res = await fetch('/api')
	state.data = await res.json()
	state.status = 'success'
} catch (e) {
	state.status = 'error'
	state.error = e
}
}
```
{% endraw %}

---

## utilidades poco conocidas pero muy √∫tiles

### `defineOptions`

{% raw %}
```vue
<script setup>
defineOptions({
name: 'MyComp'
})
</script>
```
{% endraw %}

### `v-model` m√∫ltiple

{% raw %}
```vue
<MyComponent v-model:email="email" v-model:name="name" />
```
{% endraw %}

### `useAttrs` para pasar attrs rest a elementos ra√≠z

{% raw %}
```js
const attrs = useAttrs()
```
{% endraw %}

### `useSlots` para verificar presencia de slots

{% raw %}
```js
const slots = useSlots()
if (slots.header) { /* ‚Ä¶ */ }
```
{% endraw %}

---

## herramientas √∫tiles 2025

- Vetur ‚Üí **Vue Language Features (Volar)** (mejor TS + DX)
- unplugin-auto-import (composables autom√°ticos)
- unplugin-vue-components (componentes auto-registrados)
- VueUse (colecci√≥n enorme de composables de calidad)
- FormKit / VeeValidate para formularios robustos
- Vitest + Test Utils para testing

---

## enlaces √∫tiles

- [Documentaci√≥n oficial Vue.js](https://vuejs.org/guide/introduction.html)
- [VueUse](https://vueuse.org)
- [Volar ‚Äî Vue Language Features](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin)
- [VitePress](https://vitepress.dev)
- [Nuxt](https://nuxt.com)

# Vue.js ‚Äî Composition API


## Introducci√≥n
La **Composition API** es el modelo moderno de Vue.js para organizar l√≥gica reutilizable, mejorar escalabilidad y ofrecer mayor control sobre el ciclo de vida y la reactividad. Permite separar la l√≥gica por funcionalidades, no por opciones, evitando fragmentaci√≥n y facilitando testing.

## Fundamentos Esenciales

### Setup()
El punto de entrada para usar Composition API. Dentro de `setup()` defines estado reactivo, computed, watchers, lifecycle hooks y retornas las propiedades/m√©todos que expondr√°s al template.

#### Ejemplo b√°sico
{% raw %}
```js
import { ref } from 'vue'

export default {
	setup() {
		const count = ref(0)
		const inc = () => count.value++

		return { count, inc }
	}
}
```
{% endraw %}`

---

## Reactividad

### ref()

Crea un valor reactivo **primitivo o no primitivo** con `.value`. Ideal para valores simples.

{% raw %}
```js
const nombre = ref('Edu')
nombre.value = 'Carlos'
```
{% endraw %}

### reactive()

Convierte un objeto entero en reactivo. √ötil para estados complejos.

{% raw %}
```js
const state = reactive({
	user: null,
	loading: false
})
```
{% endraw %}

### toRefs() y toRef()

Evitan perder reactividad cuando extraes propiedades de un objeto reactivo.

{% raw %}
```js
const { user, loading } = toRefs(state)
```
{% endraw %}

---

## Computed y Watchers

### computed()

Propiedades derivadas, con caching por defecto.

{% raw %}
```js
const fullName = computed(() => user.value.name + ' ' + user.value.surname)
```
{% endraw %}

### watch()

Observa cambios espec√≠ficos.

{% raw %}
```js
watch(() => state.user, (nuevo, viejo) => {
	console.log('cambio usuario', nuevo)
})
```
{% endraw %}

### watchEffect()

Ejecuta autom√°ticamente cuando cualquier dependencia es usada dentro del callback.

{% raw %}
```js
watchEffect(() => {
	console.log(state.loading)
})
```
{% endraw %}

---

## Lifecycle Hooks

Versi√≥n Composition API de los hooks del Options API.

* `onMounted()`
* `onUnmounted()`
* `onUpdated()`
* `onBeforeMount()`
* `onBeforeUpdate()`
* `onBeforeUnmount()`

{% raw %}
```js
onMounted(() => {
	console.log('Montado!')
})
```
{% endraw %}

---

## Dependencias e Inyecci√≥n (provide / inject)

Permiten compartir estado entre componentes sin pasar props manualmente.

{% raw %}
```js
// padre
provide('theme', 'dark')

// hijo
const theme = inject('theme')
```
{% endraw %}

---

## Reutilizaci√≥n de L√≥gica ‚Äî Composables

Los **composables** son funciones que encapsulan l√≥gica reutilizable usando Composition API.

### Reglas:

* Deben comenzar con `useX`
* Devuelven estado reactivo + funciones
* Pueden usar cualquier API de Composition

#### Ejemplo:

{% raw %}
```js
// useFetch.js
export function useFetch(url) {
	const data = ref(null)
	const loading = ref(true)

	onMounted(async () => {
		data.value = await fetch(url).then(r => r.json())
		loading.value = false
	})

	return { data, loading }
}
```
{% endraw %}

---

## Manejo de Tipos (TypeScript)

La Composition API fue dise√±ada para integrarse perfectamente con TS.

{% raw %}
```ts
const count = ref<number>(0)
const user = reactive<{ name: string; age: number }>({ name: '', age: 0 })
```
{% endraw %}

---

## Reglas especiales de la Composition API

### Reglas en `setup()`

* No usar `this`
* Debe ser **sincr√≥nica**
* Evitar operaciones pesadas (usar composables o efectos)

### Ventajas sobre Options API

* L√≥gica agrupada por caracter√≠sticas
* Mejor escalabilidad en equipos
* Testing m√°s simple
* Reutilizaci√≥n avanzada (no requiere mixins)

---

## Nuevas funcionalidades relevantes (2024‚Äì2025)

### script setup (sugerido como est√°ndar)

Hace el c√≥digo m√°s simple, menos boilerplate.

{% raw %}
```vue
<script setup>
const count = ref(0)
</script>

<template>
	<button @click="count++">{{ count }}</button>
</template>
```
{% endraw %}

### defineProps y defineEmits

Solo disponibles en `<script setup>`.

{% raw %}
```vue
<script setup>
const props = defineProps({ msg: String })
const emit = defineEmits(['update'])
</script>
```
{% endraw %}

### defineModel (Vue 3.4+)

Simplifica `v-model` personalizado.

{% raw %}
```vue
<script setup>
const model = defineModel()
</script>
```
{% endraw %}

---

## Integraci√≥n con Pinia

Pinia usa Composition API internamente, por lo que encaja de manera natural.

{% raw %}
```js
export const useUserStore = defineStore('user', () => {
	const user = ref(null)
	const setUser = (u) => user.value = u

	return { user, setUser }
})
```
{% endraw %}

---

## Buenas Pr√°cticas (Cheats)

* Usa **script setup** siempre que sea posible.
* Separa estados complejos en **composables reutilizables**.
* Usa **computed** para cualquier valor derivado.
* Usa `reactive()` para objetos, `ref()` para primitivos.
* Evita watchers innecesarios ‚Äî usar `computed` primero.
* Estructura composables por funcionalidades: `useAuth`, `useTheme`.
* No mezcles Options y Composition en el mismo archivo sin necesidad.
* Exporta solo lo m√≠nimo necesario desde composables.
* Composables nunca deben manipular DOM directamente.


