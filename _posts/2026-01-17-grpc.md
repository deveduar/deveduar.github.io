---
date: 2026-01-17 14:09
title: gRPC
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: framework
tags:
  - framework
  - backend
  - grpc
  - microservicios
  - Backend
---
# gRPC
`$= dv.current().file.tags.join(" ")`
## Relaci√≥n con otros conceptos
-	[Backend](/uncategorized/backend/)
-	[Sockets](/backend/sockets/)
-	[Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)

## Definici√≥n
gRPC es un framework de comunicaci√≥n **RPC (Remote Procedure Call)** de alto rendimiento desarrollado por Google. Permite que sistemas distribuidos se comuniquen como si estuvieran llamando a funciones locales, abstraiendo la complejidad de red, serializaci√≥n y transporte.

Se utiliza principalmente en arquitecturas de [microservicios](/backend/microservicios/) y sistemas backend modernos donde el rendimiento, la tipificaci√≥n fuerte y la compatibilidad entre lenguajes son cr√≠ticos.

## Caracter√≠sticas principales
-	Comunicaci√≥n basada en **HTTP/2**
-	Uso de **Protocol Buffers (Protobuf)** como formato de serializaci√≥n
-	Soporte nativo para m√∫ltiples lenguajes
-	Comunicaci√≥n **cliente-servidor** fuertemente tipada
-	Soporte para **streaming** bidireccional
-	Baja latencia y alto throughput


## Arquitectura
gRPC sigue un modelo cliente-servidor donde:
-	El **servidor** define un conjunto de servicios y m√©todos en un archivo `.proto`
-	El **cliente** consume estos servicios mediante c√≥digo generado autom√°ticamente

El contrato entre cliente y servidor est√° completamente definido por el archivo Protobuf, evitando ambig√ºedades y errores de integraci√≥n.

## Protocol Buffers (Protobuf)
Protobuf es el lenguaje de definici√≥n de interfaces (IDL) utilizado por gRPC.

Permite:
-	Definir mensajes estructurados
-	Definir servicios y m√©todos RPC
-	Generar c√≥digo autom√°ticamente para distintos lenguajes

Ventajas:
-	M√°s eficiente que JSON o XML
-	Tipado fuerte
-	Versionado expl√≠cito

## Tipos de llamadas gRPC
-	**Unary**
	-	Una petici√≥n ‚Üí una respuesta
-	**Server Streaming**
	-	Una petici√≥n ‚Üí m√∫ltiples respuestas
-	**Client Streaming**
	-	M√∫ltiples peticiones ‚Üí una respuesta
-	**Bidirectional Streaming**
	-	Flujo continuo en ambos sentidos

Estos modelos permiten casos avanzados como eventos en tiempo real, colas, chats o sincronizaci√≥n de estados.

## Transporte y rendimiento
gRPC se apoya en HTTP/2, lo que habilita:
-	Multiplexaci√≥n de m√∫ltiples streams en una sola conexi√≥n
-	Compresi√≥n de headers
-	Control de flujo
-	Conexiones persistentes

Esto lo hace m√°s eficiente que REST sobre HTTP/1.1 en escenarios de alta concurrencia.

## Casos de uso comunes
-	Microservicios internos
-	Comunicaci√≥n entre servicios backend
-	Sistemas distribuidos de baja latencia
-	APIs internas de alto rendimiento
-	Streaming de datos en tiempo real

## Comparaci√≥n con REST
-	gRPC
	-	Binario (Protobuf)
	-	HTTP/2
	-	Contratos estrictos
	-	Mejor rendimiento
-	REST
	-	Texto (JSON)
	-	HTTP/1.1 o HTTP/2
	-	Contratos impl√≠citos
	-	M√°s f√°cil de depurar manualmente

Ambos pueden coexistir: REST para APIs p√∫blicas y gRPC para comunicaci√≥n interna.

## Seguridad
gRPC soporta:
-	TLS de forma nativa
-	Autenticaci√≥n mediante tokens
-	Integraci√≥n con sistemas de identidad

Esto lo hace adecuado para entornos productivos y cloud.

## Herramientas y ecosistema
-	gRPC CLI
-	Protoc (compiler de Protobuf)
-	Integraci√≥n con Kubernetes
-	Soporte en service meshes como Istio

## Ventajas y desventajas
-	Ventajas
	-	Alto rendimiento
	-	Tipado fuerte
	-	Multilenguaje
	-	Streaming avanzado
-	Desventajas
	-	Menos amigable para humanos
	-	Mayor complejidad inicial
	-	No ideal para navegadores sin proxy

## Recursos
-	[gRPC Official](https://grpc.io)
-	[Protocol Buffers](https://protobuf.dev)

# Conceptos avanzados no cubiertos

## Versionado de APIs
gRPC gestiona el versionado principalmente a nivel de **Protocol Buffers**, no de endpoints como REST.

Buenas pr√°cticas:
-	A√±adir campos nuevos sin reutilizar identificadores num√©ricos
-	No eliminar campos existentes, solo marcarlos como deprecated
-	Versionar servicios completos (`UserServiceV2`)
-	Mantener compatibilidad hacia atr√°s (backward compatibility)

El versionado correcto es clave en sistemas distribuidos con m√∫ltiples clientes.

## Manejo de errores
gRPC utiliza un sistema de **status codes** estandarizado distinto a HTTP.

Incluye:
-	C√≥digos (`OK`, `INVALID_ARGUMENT`, `NOT_FOUND`, `UNAVAILABLE`, etc.)
-	Mensajes descriptivos
-	Metadata adicional (headers/trailers)

Esto permite una sem√°ntica de errores clara y consistente entre servicios.

## Deadlines y timeouts
Cada llamada gRPC puede incluir un **deadline**:
-	Tiempo m√°ximo permitido para completar la llamada
-	Propagaci√≥n autom√°tica entre servicios
-	Evita llamadas colgadas y cascadas de fallos

Es un concepto fundamental en arquitecturas resilientes.

## Interceptors
Los **interceptors** permiten ejecutar l√≥gica transversal antes o despu√©s de una llamada RPC.

Casos comunes:
-	Logging
-	Autenticaci√≥n y autorizaci√≥n
-	M√©tricas
-	Tracing distribuido
-	Retry logic

Funcionan de forma similar a middlewares en frameworks web.

## Load Balancing
gRPC soporta balanceo de carga a nivel de cliente.

Estrategias comunes:
-	Round-robin
-	Pick-first
-	Integraci√≥n con service discovery (DNS, Kubernetes)

El cliente es responsable de seleccionar el backend adecuado, reduciendo carga en proxies externos.

## Service Discovery
En entornos din√°micos:
-	gRPC se integra con DNS
-	Soporte nativo en [Kubernetes](/virtualizacion/kubernetes/)
-	Compatible con service meshes

Esto permite escalar servicios sin reconfigurar clientes manualmente.

## Observabilidad [monitoreo](/uncategorized/monitoreo/)
gRPC se integra con herramientas modernas de observabilidad.

Incluye:
-	M√©tricas (latencia, errores, throughput)
-	Tracing distribuido
-	Logs estructurados

Compatible con [OpenTelemetry](/monitoreo/opentelemetry/) y stacks de monitoreo cloud-native.

## Compresi√≥n
gRPC permite compresi√≥n de mensajes:
-	Reduce ancho de banda
-	Mejora rendimiento en redes lentas
-	Configuraci√≥n por llamada o global

√ötil en streaming y grandes vol√∫menes de datos.

## Autenticaci√≥n y autorizaci√≥n avanzada
Adem√°s de TLS, gRPC soporta:
-	Metadata headers para tokens
-	[OAuth](/autenticacion/oauth/) 2
-	[JWT](/autenticacion/jwt/)
-	mTLS (mutual TLS)

Frecuente en entornos zero-trust y microservicios internos.

## gRPC en navegadores
Limitaci√≥n clave:
-	Los navegadores no soportan gRPC nativo por restricciones de HTTP/2

Soluciones:
-	gRPC-Web
-	Proxies intermedios (Envoy)

Permite usar gRPC desde aplicaciones frontend modernas.

## Streaming avanzado
Detalles importantes:
-	Backpressure autom√°tico
-	Control de flujo por HTTP/2
-	Manejo de streams largos
-	Cancelaci√≥n de streams

Ideal para eventos en tiempo real y sincronizaci√≥n continua.

## Testing
Estrategias comunes:
-	Tests unitarios sobre servicios
-	Mocks generados desde `.proto`
-	Tests de contrato
-	Tests de integraci√≥n entre microservicios

El contrato Protobuf facilita pruebas consistentes.

## Seguridad en producci√≥n
Consideraciones adicionales:
-	Rotaci√≥n de certificados
-	Control de acceso por m√©todo
-	Auditor√≠a de llamadas
-	Limitaci√≥n de tasas (rate limiting)

Cr√≠tico en sistemas expuestos o multi-tenant.

## Antipatrones
-	Usar gRPC como REST
-	Exponer gRPC directamente a clientes p√∫blicos sin proxy
-	No definir deadlines
-	Versionar rompiendo compatibilidad
-	Usar mensajes demasiado gen√©ricos

## Cu√°ndo NO usar gRPC
-	APIs p√∫blicas simples
-	Integraciones con terceros sin soporte gRPC
-	Sistemas que requieren inspecci√≥n manual frecuente
-	Entornos con tooling limitado

## Relaci√≥n con arquitectura
-	[Backend](/uncategorized/backend/)
-	[Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)
-	[Sockets](/backend/sockets/)
-	Event-driven architectures
-	Microservicios
-	Service Mesh

## Temas relacionados para notas separadas
-	Protocol Buffers en profundidad
-	Service Mesh con gRPC
-	gRPC vs GraphQL
-	gRPC-Web
-	Observabilidad en microservicios

# gRPC ‚Äì Recursos Actualizados 2025‚Äì2026

## Documentaci√≥n y gu√≠as oficiales
-	**Documentaci√≥n oficial en gRPC.io** ‚Äì Referencia completa de conceptos, quickstarts por lenguaje, tutoriales y material de referencia actualizado constantemente por la comunidad oficial de gRPC.  
	[Documentaci√≥n gRPC](https://grpc.io/docs/)
-	**Guides de gRPC** ‚Äì Documentaci√≥n oficial orientada a casos de uso (autenticaci√≥n, cancelaci√≥n, compresi√≥n, debugging, salud del servidor, m√©tricas, deadlines, interceptores, control de flujo, etc.).  
	[Gu√≠as gRPC](https://grpc.io/docs/guides/)

## Eventos y comunidad
-	**gRPConf 2025 (26 Ago 2025)** ‚Äì Conferencia oficial de gRPC con charlas, talleres y networking para desarrolladores y empresas.  
	[gRPConf 2025](https://grpc.io/blog/grpconf-2025-announcement/)
-	**Comunidad de gRPC** ‚Äì Foros, grupos, reuniones online, YouTube e interacci√≥n comunitaria para mantenerse actualizado y resolver dudas t√©cnicas.  
	[Comunidad gRPC](https://grpc.io/community/)
-	**Mailing list grpc-io-announce** ‚Äì Lista para recibir directamente actualizaciones cr√≠ticas sobre seguridad, soporte de plataformas y noticias relevantes de gRPC.  
	[grpc-io-announce](https://grpc.io/blog/grpc-io-announce/)

## Cursos, entrenamientos y formaci√≥n
-	**Arquitectura de Microservicios con .NET 9 y gRPC (Udemy)** ‚Äì Curso actualizado 12/2025 sobre dise√±o e implementaci√≥n de microservicios gRPC con .NET 9.  
	[Curso Udemy .NET gRPC](https://www.udemy.com/course/microservices-net-grpc/)
-	**ASP.NET Core 8 en Arquitectura gRPC (Udemy / Net University)** ‚Äì Curso actualizado 03/2025 orientado a proyectos gRPC con ASP.NET Core 7/8 y conexi√≥n a bases de datos, streaming y m√°s.  
	[ASP.NET Core gRPC](https://www.udemy.com/course/aspnet-grpc/)
-	**Developing .NET services using gRPC (Info Support)** ‚Äì Formaci√≥n presencial/remota con fechas disponibles en 2026 para desarrollar servicios gRPC en .NET.  
	[Info Support gRPC](https://training.infosupport.com/en/courses/GRPCDEV/developing-net-services-using-grpc)
-	**Introduction to gRPC (Educative)** ‚Äì Curso interactivo que cubre fundamentos y ejemplos pr√°cticos de gRPC, Protobuf y RPCs aplicados en Java.  
	[Educative gRPC](https://www.educative.io/courses/introduction-to-grpc)
-	**Cursos de gRPC con Go bonificados (Imagina Formaci√≥n)** ‚Äì Formaci√≥n pr√°ctica orientada a Go y gRPC, con posibilidad de financiaci√≥n a trav√©s de FUNDAE.  
	[gRPC con Go](https://imaginaformacion.com/cursos/curso-grpc-con-go)

## Repositorios y herramientas
-	**Repositorio oficial de gRPC en GitHub (grpc/grpc)** ‚Äì C√≥digo fuente para m√∫ltiples lenguajes, ejemplos y gu√≠as de contribuci√≥n siempre actualizados.  
	[GitHub grpc/grpc](https://github.com/grpc/grpc)

## Tendencias y temas emergentes
-	**gRPC y AI** ‚Äì Art√≠culo oficial sobre integraci√≥n de LLMs para acelerar workflows de gRPC (por ejemplo conversi√≥n OpenAPI ‚Üí Protobuf asistida por IA).  
	[gRPC and AI](https://grpc.io/blog/grpc-and-ai/)
-	**Ecosistemas de lenguajes** ‚Äì Discusiones y estado del soporte gRPC en lenguajes como Rust (tonic, grpc-rust) y evoluci√≥n del tooling a finales de 2025.  
	[Estado gRPC en Rust](https://www.reddit.com/r/rust/comments/1pzkd63/are_we_official_grpc_yet/)

## Recursos comunitarios y adicionales
-	**Foros y discusi√≥n t√©cnica en Stack Overflow y Google Groups** ‚Äì Resoluci√≥n de problemas reales, patrones de implementaci√≥n y buenas pr√°cticas gRPC.  
	[Comunidad t√©cnica gRPC](https://grpc.io/community/)
-	**Checklist de producci√≥n gRPC (2025 Edition)** ‚Äì Gu√≠a pr√°ctica no oficial con pasos y recomendaciones para desplegar gRPC en producci√≥n.  
	[Checklist gRPC Producci√≥n](https://www.reddit.com/r/u_FlowerDue8900/comments/1lhf070)
-	**Herramientas de testing y exploraci√≥n de API** ‚Äì Herramientas como grpcui, grpcurl y clientes gr√°ficos para inspeccionar y probar APIs gRPC.  
	[Herramientas gRPC](https://www.reddit.com/r/golang/comments/1hry0cd/)
## gRPC ‚Äì Tools y recursos **open source en GitHub** (2025‚Äì2026)

### Herramientas CLI y utilidades
-	**[fullstorydev/grpcurl](https://github.com/fullstorydev/grpcurl)** ‚Äì CLI para interactuar con servidores gRPC (equivalente a `curl` para gRPC). Soporta reflection, TLS, autenticaci√≥n y streaming.
-	**[fullstorydev/grpcui](https://github.com/fullstorydev/grpcui)** ‚Äì Interfaz web interactiva para explorar y probar APIs gRPC (similar a Postman).
-	**[grpc-ecosystem/grpc-health-probe](https://github.com/grpc-ecosystem/grpc-health-probe)** ‚Äì CLI para health checks de servicios gRPC, ampliamente usado en Kubernetes.
-	**[grpc-ecosystem/grpcdebug](https://github.com/grpc-ecosystem/grpcdebug)** ‚Äì Herramienta de debugging gRPC (Channelz, health checks, xDS).
-	**[vearne/grpcreplay](https://github.com/vearne/grpcreplay)** ‚Äì Grabaci√≥n y reproducci√≥n de tr√°fico gRPC para testing, shadow traffic y an√°lisis.
-	**[bradleyjkemp/grpc-tools](https://github.com/bradleyjkemp/grpc-tools)** ‚Äì Colecci√≥n de herramientas para inspecci√≥n, replay, proxy y fixtures gRPC.

### Integraciones y extensiones √∫tiles
-	**[grpc-ecosystem/grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)** ‚Äì Genera un gateway HTTP/JSON desde servicios gRPC, permitiendo exponer APIs REST sin duplicar l√≥gica.
-	**[grpc-ecosystem/grpc-spring](https://github.com/grpc-ecosystem/grpc-spring)** ‚Äì Starter para integrar gRPC en aplicaciones **Spring Boot** con configuraci√≥n simplificada.

### Bibliotecas y runtimes gRPC
-	**[grpc/grpc](https://github.com/grpc/grpc)** ‚Äì Repositorio principal del framework gRPC con implementaciones core y bindings multilenguaje.
-	**[grpc/grpc-dotnet](https://github.com/grpc/grpc-dotnet)** ‚Äì Implementaci√≥n oficial de gRPC para .NET y ASP.NET Core.
-	**[hyperium/tonic](https://github.com/hyperium/tonic)** ‚Äì Implementaci√≥n gRPC idiom√°tica para **Rust**, basada en async/await y ampliamente adoptada.

### Ecosistema general
-	**[grpc-ecosystem](https://github.com/grpc-ecosystem)** ‚Äì Organizaci√≥n que centraliza proyectos open source relacionados con gRPC: middlewares, gateways, observabilidad, tooling y extensiones.
-	**Awesome gRPC** ‚Äì Listas curadas de herramientas, librer√≠as, ejemplos y recursos gRPC mantenidas por la comunidad (habitualmente dentro del ecosistema gRPC).

## Ideas de herramientas extra (comunidad)
> Pueden tener repositorios open source o prototipos activos
-	Clientes TUI / GUI como **Chiko** ‚Äì Cliente gRPC en terminal con interfaz interactiva.
-	Herramientas CLI como **grpcmd** ‚Äì CLI inspirada en HTTPie para consumir servicios gRPC.
-	Proyectos de testing automatizado, generaci√≥n de payloads y exploraci√≥n visual de contratos `.proto`.

## C√≥mo explorar m√°s proyectos
-	Buscar en GitHub por etiquetas: `grpc`, `grpc-tools`, `grpc-client`, `grpc-ui`, `grpc-ecosystem`
-	Explorar repositorios destacados dentro de **grpc-ecosystem**
-	Revisar listas *awesome* relacionadas con gRPC por lenguaje o caso de uso

# gRPC ‚Äì Gu√≠a de casos de uso e implementaci√≥n t√©cnica

## Microservicios internos
### Caso de uso
Comunicaci√≥n entre microservicios backend con alta frecuencia de llamadas, baja latencia y contratos estrictos.

### Implementaci√≥n t√©cnica
-	Definir contratos en `.proto` por dominio
-	Usar **Unary RPC** para operaciones CRUD
-	Configurar **deadlines obligatorios** en cada llamada
-	Activar **client-side load balancing**
-	Usar **mTLS** para seguridad entre servicios
-	Desplegar con Kubernetes + DNS o service mesh

### Buenas pr√°cticas
-	Un servicio gRPC por bounded context
-	Evitar mensajes gen√©ricos tipo `Any`
-	Versionar servicios, no m√©todos

---

## Comunicaci√≥n Backend ‚Üî Backend (polyglot)
### Caso de uso
Servicios escritos en distintos lenguajes (Go, Java, .NET, Rust) que deben comunicarse sin fricci√≥n.

### Implementaci√≥n t√©cnica
-	Protobuf como contrato √∫nico
-	Generaci√≥n autom√°tica de clientes/servidores
-	Repositorio central de `.proto`
-	CI validando compatibilidad backward
-	Interceptors para auth, logging y m√©tricas

### Ventaja clave
El contrato elimina ambig√ºedades entre equipos y lenguajes.

---

## Streaming de eventos en tiempo real
### Caso de uso
Notificaciones, feeds en tiempo real, sincronizaci√≥n de estados, eventos de dominio.

### Implementaci√≥n t√©cnica
-	Usar **Server Streaming** o **Bidirectional Streaming**
-	Manejar backpressure autom√°ticamente v√≠a HTTP/2
-	Cancelar streams cuando el cliente se desconecta
-	Definir mensajes peque√±os y frecuentes
-	Usar keepalive para conexiones largas

### Ejemplos
-	Chat interno
-	Actualizaci√≥n de dashboards
-	Procesamiento incremental de datos

---

## APIs p√∫blicas h√≠bridas (gRPC + REST)
### Caso de uso
Exponer APIs p√∫blicas REST mientras se mantiene gRPC internamente.

### Implementaci√≥n t√©cnica
-	gRPC como API principal
-	Usar **grpc-gateway** para generar REST
-	Mapear errores gRPC ‚Üí HTTP status codes
-	Documentar REST con OpenAPI generado
-	Mantener una sola l√≥gica de negocio

### Ventaja
Un backend, dos interfaces de consumo.

---

## Sistemas de alta performance
### Caso de uso
Servicios con alto throughput y bajo uso de CPU/memoria.

### Implementaci√≥n t√©cnica
-	Protobuf binario (evitar JSON)
-	Compresi√≥n selectiva (gzip)
-	Pooling de conexiones
-	Multiplexaci√≥n HTTP/2
-	Evitar reflection en producci√≥n si no es necesario

### Resultado
Mejor rendimiento que REST en escenarios intensivos.

---

## Arquitecturas Event-Driven
### Caso de uso
Publicaci√≥n y consumo de eventos entre servicios sin usar brokers tradicionales.

### Implementaci√≥n t√©cnica
-	Bidirectional streaming como canal de eventos
-	Mensajes de evento bien tipados
-	ACK expl√≠cito si es necesario
-	Retry y reconexi√≥n autom√°tica
-	Idempotencia en consumidores

### Nota
No reemplaza completamente a Kafka, pero es √∫til en flujos directos.

---

## gRPC en Kubernetes
### Caso de uso
Servicios gRPC desplegados y escalados din√°micamente.

### Implementaci√≥n t√©cnica
-	Kubernetes Services + DNS
-	Health checks gRPC (`grpc-health-probe`)
-	Readiness y liveness basados en gRPC
-	Client-side load balancing
-	Sidecars opcionales (Envoy)

### Observaci√≥n
El cliente gRPC debe conocer cambios de endpoints.

---

## gRPC con Service Mesh
### Caso de uso
Seguridad, observabilidad y control de tr√°fico sin tocar c√≥digo.

### Implementaci√≥n t√©cnica
-	Service mesh (Istio / Linkerd)
-	mTLS autom√°tico
-	Retries y circuit breaking a nivel mesh
-	Traffic shaping y canary releases
-	Observabilidad centralizada

### Ventaja
Menos l√≥gica cross-cutting en el c√≥digo.

---

## Frontend ‚Üí Backend (gRPC-Web)
### Caso de uso
Aplicaciones web modernas que consumen gRPC.

### Implementaci√≥n t√©cnica
-	Usar **gRPC-Web**
-	Proxy (Envoy) entre browser y backend
-	Unary y server streaming soportados
-	Auth v√≠a headers
-	Protobuf compartido con frontend

### Limitaci√≥n
No soporta bidirectional streaming completo.

---

## Testing y QA
### Caso de uso
Garantizar estabilidad de contratos y servicios.

### Implementaci√≥n t√©cnica
-	Tests unitarios con mocks generados
-	Tests de contrato sobre `.proto`
-	Tests de integraci√≥n entre servicios
-	grpcurl / grpcui para testing manual
-	Replay de tr√°fico en staging

---

## Observabilidad en producci√≥n
### Caso de uso
Monitorear latencia, errores y comportamiento del sistema.

### Implementaci√≥n t√©cnica
-	Interceptors para m√©tricas
-	Tracing distribuido (OpenTelemetry)
-	Logs estructurados por m√©todo RPC
-	M√©tricas por status code
-	Alertas por latency percentiles

---

## Seguridad enterprise
### Caso de uso
Entornos regulados o zero-trust.

### Implementaci√≥n t√©cnica
-	mTLS entre servicios
-	JWT u OAuth2 en metadata
-	Auth por m√©todo RPC
-	Rotaci√≥n de certificados
-	Auditor√≠a de llamadas

---

## Antipatrones de implementaci√≥n
-	Usar gRPC como REST
-	No definir deadlines
-	Mensajes demasiado grandes
-	Versionar rompiendo compatibilidad
-	Exponer gRPC directo a internet sin proxy

---

## Relaci√≥n con otras notas
-	[Backend](/uncategorized/backend/)
-	[Sockets](/backend/sockets/)
-	[Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)
-	Microservicios
-	Service Mesh
-	Event-Driven Architecture
# gRPC ‚Äì Cheatsheet con ejemplos de c√≥digo

## Definici√≥n de servicio (.proto)
{% raw %}
```proto
syntax = "proto3";

package user.v1;

service UserService {
	rpc GetUser(GetUserRequest) returns (User);
	rpc ListUsers(Empty) returns (stream User);
	rpc CreateUsers(stream CreateUserRequest) returns (CreateUsersResponse);
	rpc Chat(stream ChatMessage) returns (stream ChatMessage);
}

message GetUserRequest {
	string id = 1;
}

message CreateUserRequest {
	string name = 1;
}

message User {
	string id = 1;
	string name = 2;
}

message ChatMessage {
	string from = 1;
	string message = 2;
}

message CreateUsersResponse {
	int32 count = 1;
}

message Empty {}
```
{% endraw %}`

## Generaci√≥n de c√≥digo

### Protobuf compiler

{% raw %}
```bash
protoc \
	--proto_path=. \
	--go_out=. \
	--go-grpc_out=. \
	user.proto
```
{% endraw %}

---

## Servidor gRPC ‚Äì Go

{% raw %}
```go
type UserServer struct {
	pb.UnimplementedUserServiceServer
}

func (s *UserServer) GetUser(
	ctx context.Context,
	req *pb.GetUserRequest,
) (*pb.User, error) {
	return &pb.User{
		Id:   req.Id,
		Name: "Alice",
	}, nil
}

func main() {
	lis, _ := net.Listen("tcp", ":50051")
	s := grpc.NewServer()
	pb.RegisterUserServiceServer(s, &UserServer{})
	s.Serve(lis)
}
```
{% endraw %}

---

## Cliente gRPC ‚Äì Go

{% raw %}
```go
conn, _ := grpc.Dial(
	"localhost:50051",
	grpc.WithTransportCredentials(insecure.NewCredentials()),
)

client := pb.NewUserServiceClient(conn)

res, _ := client.GetUser(
	context.Background(),
	&pb.GetUserRequest{Id: "123"},
)
```
{% endraw %}

---

## Servidor gRPC ‚Äì .NET

{% raw %}
```csharp
public class UserService : UserService.UserServiceBase
{
	public override Task<User> GetUser(
		GetUserRequest request,
		ServerCallContext context)
	{
		return Task.FromResult(new User {
			Id = request.Id,
			Name = "Alice"
		});
	}
}
```
{% endraw %}

---

## Cliente gRPC ‚Äì .NET

{% raw %}
```csharp
var channel = GrpcChannel.ForAddress("https://localhost:5001");
var client = new UserService.UserServiceClient(channel);

var user = await client.GetUserAsync(
	new GetUserRequest { Id = "123" });
```
{% endraw %}

---

## Server Streaming ‚Äì Cliente Go

{% raw %}
```go
stream, _ := client.ListUsers(ctx, &pb.Empty{})

for {
	user, err := stream.Recv()
	if err == io.EOF {
		break
	}
	fmt.Println(user.Name)
}
```
{% endraw %}

---

## Client Streaming ‚Äì Servidor Go

{% raw %}
```go
func (s *UserServer) CreateUsers(
	stream pb.UserService_CreateUsersServer,
) error {
	count := 0
	for {
		_, err := stream.Recv()
		if err == io.EOF {
			return stream.SendAndClose(
				&pb.CreateUsersResponse{Count: int32(count)},
			)
		}
		count++
	}
}
```
{% endraw %}

---

## Bidirectional Streaming ‚Äì Go

{% raw %}
```go
func (s *UserServer) Chat(
	stream pb.UserService_ChatServer,
) error {
	for {
		msg, err := stream.Recv()
		if err != nil {
			return err
		}
		stream.Send(&pb.ChatMessage{
			From: "server",
			Message: msg.Message,
		})
	}
}
```
{% endraw %}

---

## Deadlines y timeouts

{% raw %}
```go
ctx, cancel := context.WithTimeout(
	context.Background(),
	time.Second,
)
defer cancel()

client.GetUser(ctx, req)
```
{% endraw %}

---

## Manejo de errores gRPC

{% raw %}
```go
return nil, status.Errorf(
	codes.NotFound,
	"user not found",
)
```
{% endraw %}

---

## Interceptor ‚Äì Go

{% raw %}
```go
func LoggingInterceptor(
	ctx context.Context,
	req any,
	info *grpc.UnaryServerInfo,
	handler grpc.UnaryHandler,
) (any, error) {
	log.Println(info.FullMethod)
	return handler(ctx, req)
}
```
{% endraw %}

---

## Seguridad ‚Äì mTLS

{% raw %}
```go
creds, _ := credentials.NewServerTLSFromFile(
	"cert.pem",
	"key.pem",
)

grpc.NewServer(
	grpc.Creds(creds),
)
```
{% endraw %}

---

## Health Check

{% raw %}
```proto
service Health {
	rpc Check(HealthCheckRequest)
		returns (HealthCheckResponse);
}
```
{% endraw %}

{% raw %}
```bash
grpc-health-probe -addr=:50051
```
{% endraw %}

---

## Testing r√°pido con grpcurl

{% raw %}
```bash
grpcurl -plaintext \
	-d '{"id":"123"}' \
	localhost:50051 user.v1.UserService/GetUser
```
{% endraw %}

---

## gRPC-Web (concepto)

- Backend gRPC normal
- Proxy Envoy
- Cliente JS generado desde `.proto`
- Unary + server streaming

---

## Convenciones r√°pidas

- Siempre usar deadlines
- Mensajes peque√±os
- Versionar servicios
- Auth v√≠a metadata
- Streaming para flujos largos

---

## Relaci√≥n con otras notas

- [Backend](/uncategorized/backend/)
- [Sockets](/backend/sockets/)
- [Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)

# gRPC ‚Äì Node.js y Spring Boot (uso real + ejemplos)

## ¬øSe puede usar gRPC con Node.js y Spring Boot?
S√≠. Ambos est√°n **soportados oficialmente**, se usan en producci√≥n y encajan muy bien en arquitecturas de microservicios.

-	Node.js
	-	Muy com√∫n para **BFF**, gateways y servicios I/O bound
	-	Soporte oficial v√≠a `@grpc/grpc-js`
-	Spring Boot (Java)
	-	Muy usado en **core backends enterprise**
	- Integraci√≥n madura con Spring Ecosystem

---

## Node.js + gRPC

## Stack habitual
-	Node.js 18+
-	`@grpc/grpc-js`
-	`@grpc/proto-loader`
-	Protobuf v3

## Instalaci√≥n
{% raw %}
```bash
npm install @grpc/grpc-js @grpc/proto-loader
```
{% endraw %}`

## Servidor gRPC ‚Äì Node.js

{% raw %}
```js
import grpc from "@grpc/grpc-js";
import protoLoader from "@grpc/proto-loader";

const packageDef = protoLoader.loadSync(
	"user.proto",
	{ keepCase: true }
);

const proto = grpc.loadPackageDefinition(packageDef);

function getUser(call, callback) {
	callback(null, {
		id: call.request.id,
		name: "Alice",
	});
}

const server = new grpc.Server();
server.addService(
	proto.user.v1.UserService.service,
	{ getUser }
);

server.bindAsync(
	"0.0.0.0:50051",
	grpc.ServerCredentials.createInsecure(),
	() => server.start()
);
```
{% endraw %}

## Cliente gRPC ‚Äì Node.js

{% raw %}
```js
const client = new proto.user.v1.UserService(
	"localhost:50051",
	grpc.credentials.createInsecure()
);

client.getUser({ id: "123" }, (err, res) => {
	console.log(res);
});
```
{% endraw %}

## Server Streaming ‚Äì Node.js

{% raw %}
```js
function listUsers(call) {
	call.write({ id: "1", name: "Alice" });
	call.write({ id: "2", name: "Bob" });
	call.end();
}
```
{% endraw %}

## Uso t√≠pico de Node.js con gRPC

- BFF (Backend for Frontend)
- API Gateway interno
- Servicios de agregaci√≥n
- Streaming de eventos hacia frontend (v√≠a gRPC-Web)

---

## Spring Boot + gRPC

## Stack habitual

- Java 17+
- Spring Boot 3.x
- `grpc-spring-boot-starter`
- Netty

## Dependencias (Gradle)

{% raw %}
```gradle
implementation "net.devh:grpc-server-spring-boot-starter:2.15.0.RELEASE"
implementation "net.devh:grpc-client-spring-boot-starter:2.15.0.RELEASE"
```
{% endraw %}

## Servidor gRPC ‚Äì Spring Boot

{% raw %}
```java
@GrpcService
public class UserServiceImpl
	extends UserServiceGrpc.UserServiceImplBase {

	@Override
	public void getUser(
		GetUserRequest request,
		StreamObserver<User> responseObserver
	) {
		User user = User.newBuilder()
			.setId(request.getId())
			.setName("Alice")
			.build();

		responseObserver.onNext(user);
		responseObserver.onCompleted();
	}
}
```
{% endraw %}

## Cliente gRPC ‚Äì Spring Boot

{% raw %}
```java
@GrpcClient("user-service")
private UserServiceGrpc.UserServiceBlockingStub client;

public User getUser(String id) {
	return client.getUser(
		GetUserRequest.newBuilder()
			.setId(id)
			.build()
	);
}
```
{% endraw %}

## Configuraci√≥n Spring

{% raw %}
```yaml
grpc:
	server:
		port: 50051
```
{% endraw %}

## Streaming ‚Äì Spring Boot

{% raw %}
```java
@Override
public void listUsers(
	Empty request,
	StreamObserver<User> responseObserver
) {
	responseObserver.onNext(user1);
	responseObserver.onNext(user2);
	responseObserver.onCompleted();
}
```
{% endraw %}

---

## Comparaci√≥n Node.js vs Spring Boot

- Node.js
    - Excelente para I/O
    - Menor consumo de recursos
    - M√°s simple para gateways
    - Menos tooling enterprise
- Spring Boot
    - Muy robusto
    - Excelente integraci√≥n con seguridad
    - Observabilidad madura
    - Ideal para dominios complejos

---

## Interoperabilidad real

Ejemplo com√∫n en producci√≥n:

- Frontend ‚Üí gRPC-Web ‚Üí Node.js BFF
- Node.js ‚Üí gRPC ‚Üí Spring Boot
- Spring Boot ‚Üí gRPC ‚Üí otros servicios Java / Go

Todos comparten **el mismo `.proto`**.

---

## Antipatrones espec√≠ficos

- Node.js
    - Bloquear el event loop
    - Usar gRPC para CPU-bound heavy tasks
- Spring Boot
    - Usar DTOs duplicados fuera de Protobuf
    - No manejar backpressure en streaming

---

## Casos reales donde encajan mejor

- Node.js
    - BFF
    - API Gateway
    - Realtime feeds
- Spring Boot
    - Core domain services
    - Sistemas financieros
    - Backends enterprise

---

## Relaci√≥n con otras notas

- [Backend](/uncategorized/backend/)
- [Sockets](/backend/sockets/)
- [Patrones de dise√±o](/computer%20science/patrones-de-dise-o/)
- Microservicios
- Service Mesh