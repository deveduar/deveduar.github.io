---
date: 2025-01-29 00:30
title: RabbitMQ
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: docker
tags:
  - docker
  - rabbitmq
  - microservicios
  - Backend
---
# RabbitMQ
`$= dv.current().file.tags.join(" ")`

- [Backend](/uncategorized/backend/)
- middleware
- [gestor de colas](/backend/gestor-de-colas/)
- [Stream Processing](/backend/stream-processing/)

## Contexto y conceptos clave
- **Stack t√≠pico**
	- Integraci√≥n frecuente con stacks como Node.js, Java, .NET, Python, PHP, WordPress.
	- Uso combinado con bases de datos, caches y APIs REST/GraphQL.
- **Protocolos**
	- AMQP 0-9-1 (principal)
	- MQTT, STOMP (v√≠a plugins)
	- HTTP API (gesti√≥n y monitoreo)
- **Arquitectura orientada a mensajes**
	- Productores (publishers)
	- Brokers
	- Consumidores (consumers)
- **Procesamiento as√≠ncrono**
	- Ejecuci√≥n de tareas en segundo plano
	- Desacoplamiento entre servicios
	- Mejora de resiliencia y escalabilidad
- **Casos de uso comunes**
	- Env√≠o de emails
	- Procesamiento de im√°genes o v√≠deos
	- Jobs programados
	- Integraciones entre microservicios
	- Workflows empresariales

## Fundamentos de RabbitMQ
- **Exchange**
	- Punto de entrada de los mensajes
	- Tipos: direct, fanout, topic, headers
- **Queue**
	- Buffer donde se almacenan los mensajes
	- FIFO por defecto
	- Persistentes o vol√°tiles
- **Binding**
	- Relaci√≥n entre exchange y cola
- **Routing Key**
	- Clave usada para enrutar mensajes
- **Acknowledgements (ACK/NACK)**
	- Confirmaci√≥n de consumo
	- Prevenci√≥n de p√©rdida de mensajes
- **Durabilidad**
	- Exchanges y colas durables
	- Mensajes persistentes
- **Prefetch**
	- Control de backpressure
	- L√≠mite de mensajes no confirmados por consumidor

## Patrones de mensajer√≠a
- **Work Queues**
	- Distribuci√≥n de tareas entre m√∫ltiples workers
- **Publish / Subscribe**
	- Difusi√≥n de mensajes a m√∫ltiples consumidores
- **Routing**
	- Enrutamiento selectivo por claves
- **Topics**
	- Enrutamiento flexible con patrones
- **Request / Reply**
	- Comunicaci√≥n s√≠ncrona sobre infraestructura as√≠ncrona
- **Delayed Messaging**
	- Programaci√≥n de mensajes en el tiempo (plugins)

## Gesti√≥n de errores y resiliencia
- **Retries**
	- Reintentos autom√°ticos
	- Backoff exponencial
- **Dead Letter Exchange (DLX)**
	- Mensajes no procesables
	- Auditor√≠a y reprocesado
- **TTL**
	- Tiempo de vida de mensajes o colas
- **Idempotencia**
	- Prevenci√≥n de procesamiento duplicado
- **Circuit Breaker**
	- Protecci√≥n de consumidores saturados

## Observabilidad y operaci√≥n
- **Management Plugin**
	- UI web
	- M√©tricas y estado de colas
- **Monitoring**
	- Integraci√≥n con Prometheus y Grafana
- **Logs**
	- Eventos de conexi√≥n
	- Errores de enrutamiento
- **Control de recursos**
	- Uso de memoria
	- Disk alarms
	- Flow control

## Instalaci√≥n en Docker
- [hub.docker.com/_/rabbitmq](https://hub.docker.com/_/rabbitmq) [Docker](/software%20engineering/docker/)
- [hub.docker.com/r/bitnami/rabbitmq](https://hub.docker.com/r/bitnami/rabbitmq)
- Simplifying RabbitMQ Setup with Docker A Step-by-Step Guide-simplifying-rabbitmq-setup-with-docker-a-step-by-step-guide-9698dc9ea4ff
- [How to use RabbitMQ with Docker and Docker Compose; a beginner‚Äôs guide](https://geshan.com.np/blog/2024/05/rabbitmq-docker/)

## Docker Compose (ejemplo)
{% raw %}
```yaml
version: "3.8"
services:
	rabbitmq:
		image: rabbitmq:3-management
		ports:
			- "5672:5672"
			- "15672:15672"
		environment:
			RABBITMQ_DEFAULT_USER: user
			RABBITMQ_DEFAULT_PASS: password
```
{% endraw %}`

## Ejemplos en Git

- [youtube/docker/rabbitmq at master ¬∑ achetronic/youtube ¬∑ GitHub](https://github.com/achetronic/youtube/tree/master/docker/rabbitmq)
    

## RabbitMQ en Kubernetes

- Instalaci√≥n en cluster de [Kubernetes](/virtualizacion/kubernetes/)
- [youtube/kubernetes/rabbitmq-cluster at master ¬∑ achetronic/youtube ¬∑ GitHub](https://github.com/achetronic/youtube/tree/master/kubernetes/rabbitmq-cluster)
- StatefulSets
- Persistent Volumes
- Clustering y mirroring
- High Availability (HA)

## Integraci√≥n con Node.js

- Integrating RabbitMQ with Node.js Building Real-time Applications-integrating-rabbitmq-with-node-js-building-real-time-applications-fa94135bada3
- [RabbitMQ hello world](https://www.rabbitmq.com/tutorials/tutorial-one-javascript)
- RabbitMQ tutorial - Hello World! RabbitMQ-tutorial-one-javascript

## Ejemplo Node.js Producer

{% raw %}
```js
const amqp = require("amqplib");

(async () => {
	const conn = await amqp.connect("amqp://localhost");
	const ch = await conn.createChannel();
	const queue = "tasks";

	await ch.assertQueue(queue, { durable: true });
	ch.sendToQueue(queue, Buffer.from("Mensaje"), { persistent: true });

	setTimeout(() => conn.close(), 500);
})();
```
{% endraw %}

## Ejemplo Node.js Consumer

{% raw %}
```js
const amqp = require("amqplib");

(async () => {
	const conn = await amqp.connect("amqp://localhost");
	const ch = await conn.createChannel();
	const queue = "tasks";

	await ch.assertQueue(queue, { durable: true });
	ch.prefetch(1);

	ch.consume(queue, msg => {
		console.log(msg.content.toString());
		ch.ack(msg);
	});
})();
```
{% endraw %}

## Plugins

- [Community Plugins | RabbitMQ](https://www.rabbitmq.com/community-plugins)
- **Delayed Message Exchange**
- **Shovel**
- **Federation**
- **MQTT**
- **STOMP**
    

## RabbitMQ vs [Apache Kafka](/backend/apache-kafka/)

- **Modelo**
    - RabbitMQ: broker tradicional con colas
    - Kafka: log distribuido
- **Casos de uso**
    - RabbitMQ: tareas, workflows, comandos
    - Kafka: eventos, streaming, big data
- **Persistencia**
    - RabbitMQ: memoria + disco
    - Kafka: disco como base
- **Reintentos**
    - RabbitMQ: DLQ y TTL
    - Kafka: relectura de offsets
- **Orden**
    - RabbitMQ: por cola
    - Kafka: por partici√≥n
        
- **Escalabilidad**
    - RabbitMQ: vertical + clustering
    - Kafka: horizontal nativo
- **Principios SOLID**
    - Una cola por caso de uso
    - Consumidores especializados

# Fundamentos y arquitectura de RabbitMQ

## Qu√© es RabbitMQ
- Broker de mensajer√≠a orientado a colas
- Implementa principalmente AMQP 0-9-1
- Componente clave en arquitecturas [Backend](/uncategorized/backend/) y middleware
- Facilita comunicaci√≥n as√≠ncrona y desacoplada entre sistemas

## Principios fundamentales
- **Desacoplamiento**
	- Productores y consumidores no se conocen
	- Independencia de despliegue y escalado
- **Asincron√≠a**
	- Procesamiento en segundo plano
	- Reducci√≥n de latencia en flujos cr√≠ticos
- **Fiabilidad**
	- ACK/NACK
	- Persistencia opcional de mensajes
- **Escalabilidad**
	- M√∫ltiples consumidores por cola
	- Clustering del broker

## Componentes principales
- **Producer**
	- Publica mensajes
	- No env√≠a directamente a colas
- **Exchange**
	- Punto de entrada de mensajes
	- Decide a qu√© colas se enrutan
- **Queue**
	- Almac√©n FIFO de mensajes
	- Consumida por uno o varios consumidores
- **Consumer**
	- Procesa mensajes
	- Controla confirmaciones
- **Binding**
	- Relaci√≥n exchange ‚Üî queue
- **Routing Key**
	- Clave usada por el exchange para decidir el enrutamiento

## Tipos de Exchange
- **Direct**
	- Enrutamiento exacto por routing key
	- Casos comando ‚Üí acci√≥n concreta
- **Fanout**
	- Difusi√≥n a todas las colas enlazadas
	- Eventos y notificaciones
- **Topic**
	- Patrones con comodines
	- Eventos jer√°rquicos y flexibles
- **Headers**
	- Enrutamiento por metadatos
	- Menos com√∫n, m√°s costoso

## Flujo interno del mensaje
- Publicaci√≥n del mensaje en un exchange
- Evaluaci√≥n de bindings
- Enrutamiento a una o varias colas
- Almacenamiento (memoria o disco)
- Entrega a consumidores disponibles
- Confirmaci√≥n o reencolado

## Modelo de entrega
- **Push**
	- RabbitMQ empuja mensajes al consumidor
- **Prefetch**
	- L√≠mite de mensajes no confirmados
	- Control de backpressure
- **Round-robin**
	- Distribuci√≥n entre consumidores activos

## Durabilidad y persistencia
- **Exchange durable**
	- Sobrevive a reinicios
- **Queue durable**
	- Mantiene definici√≥n tras restart
- **Mensaje persistente**
	- Se escribe en disco
- **Garant√≠a**
	- Durable + persistente + ACK

## Gesti√≥n de errores
- **ACK**
	- Mensaje procesado correctamente
- **NACK / Reject**
	- Error de procesamiento
- **Requeue**
	- Mensaje vuelve a la cola
- **Dead Letter Exchange (DLX)**
	- Mensajes fallidos
	- Auditor√≠a y reprocesado
- **TTL**
	- Expiraci√≥n de mensajes o colas

## Arquitectura del broker
- **Erlang VM**
	- Concurrencia masiva
	- Tolerancia a fallos
- **Nodos**
	- Cada instancia RabbitMQ es un nodo
- **Cl√∫ster**
	- Conjunto de nodos coordinados
	- Metadatos compartidos
- **Colas**
	- Locales o replicadas
- **Mirrored / Quorum Queues**
	- Alta disponibilidad
	- Consistencia fuerte

## Clustering y alta disponibilidad
- **Clustering**
	- Escala lectura/escritura
	- No balancea colas autom√°ticamente
- **Quorum Queues**
	- Basadas en Raft
	- Recomendadas para producci√≥n
- **Failover**
	- Reasignaci√≥n autom√°tica de l√≠deres
- **Trade-offs**
	- Consistencia vs latencia

## Gesti√≥n de recursos
- **Memoria**
	- Prioritaria para rendimiento
- **Disco**
	- Persistencia y seguridad
- **Flow Control**
	- Pausa productores si el broker se satura
- **Alarms**
	- Memory alarm
	- Disk alarm

## Seguridad
- **Autenticaci√≥n**
	- Usuario/contrase√±a
	- Certificados TLS
- **Autorizaci√≥n**
	- Permisos por vhost
- **Virtual Hosts**
	- Aislamiento l√≥gico
	- Multitenancy
- **TLS**
	- Comunicaci√≥n cifrada

## Observabilidad y operaci√≥n
- **Management Plugin**
	- UI web
	- Estado de exchanges y colas
- **M√©tricas**
	- Throughput
	- Backlog
	- Consumers activos
- **Logs**
	- Conexiones
	- Errores de enrutamiento

## Patrones arquitect√≥nicos comunes
- **Task Queue**
	- Procesamiento paralelo
- **Event-driven**
	- Productores de eventos
	- M√∫ltiples consumidores
- **CQRS**
	- Comandos v√≠a colas
	- Eventos v√≠a fanout/topic
- **Saga**
	- Orquestaci√≥n as√≠ncrona
	- Compensaciones

## L√≠mites conceptuales
- No es streaming de eventos
- No es base de datos
- No reemplaza un log distribuido
- Ideal para workflows, comandos y tareas

## Relaci√≥n con otros sistemas
- Integraci√≥n frecuente con [Apache Kafka](/backend/apache-kafka/)
- Complemento de APIs s√≠ncronas
- Backbone de microservicios orientados a mensajes

# RabbitMQ: casos de uso, roadmap y ejemplos pr√°cticos

## Casos de uso habituales
- **Procesamiento de tareas as√≠ncronas**
	- Env√≠o de emails
	- Generaci√≥n de informes
	- Procesamiento de im√°genes y v√≠deos
- **Arquitectura basada en eventos**
	- Publicaci√≥n de eventos de dominio
	- Integraci√≥n entre microservicios
- **Workflows empresariales**
	- Orquestaci√≥n de pasos
	- Manejo de estados intermedios
- **Desacoplamiento de sistemas legacy**
	- Integraci√≥n con ERP, CRM, WordPress
- **Picos de carga**
	- Absorci√≥n de tr√°fico
	- Rate limiting indirecto
- **Comunicaci√≥n inter-servicios**
	- Sustituto de llamadas s√≠ncronas fr√°giles
- **IoT y mensajer√≠a ligera**
	- MQTT v√≠a plugins
- **Batch y jobs programados**
	- Ejecuci√≥n diferida
	- Reintentos controlados

## Casos de uso por patr√≥n
- **Task Queue**
	- Colas por tipo de trabajo
	- Workers especializados
- **Publish / Subscribe**
	- Notificaciones
	- Auditor√≠a
- **Routing**
	- Procesamiento condicional
- **Topic-based events**
	- Eventos jer√°rquicos
	- Dominios complejos
- **Request / Reply**
	- RPC as√≠ncrono
	- Respuestas temporales

## Roadmap de adopci√≥n recomendado
- **Fase 1 ‚Äì Fundamentos**
	- Conceptos AMQP
	- Exchanges y colas
	- ACK y prefetch
- **Fase 2 ‚Äì Producci√≥n b√°sica**
	- Colas durables
	- Mensajes persistentes
	- Monitoring b√°sico
- **Fase 3 ‚Äì Resiliencia**
	- Dead Letter Queues
	- TTL
	- Reintentos
- **Fase 4 ‚Äì Escalabilidad**
	- M√∫ltiples consumidores
	- Prefetch tuning
	- Clustering
- **Fase 5 ‚Äì Alta disponibilidad**
	- Quorum Queues
	- Failover
	- Backups
- **Fase 6 ‚Äì Observabilidad avanzada**
	- M√©tricas
	- Alertas
	- Trazabilidad
- **Fase 7 ‚Äì Integraci√≥n avanzada**
	- Shovel / Federation
	- Integraci√≥n con [Apache Kafka](/backend/apache-kafka/)
	- Mensajer√≠a h√≠brida

## Buenas pr√°cticas de dise√±o
- Una cola por caso de uso
- Consumidores idempotentes
- No compartir colas entre dominios
- Prefetch bajo por defecto
- Evitar colas gigantes
- Separar eventos de comandos
- Usar DLQ siempre

## Ejemplo Docker Compose
{% raw %}
```yaml
version: "3.8"
services:
	rabbitmq:
		image: rabbitmq:3-management
		container_name: rabbitmq
		ports:
			- "5672:5672"
			- "15672:15672"
		environment:
			RABBITMQ_DEFAULT_USER: admin
			RABBITMQ_DEFAULT_PASS: admin
		volumes:
			- rabbitmq_data:/var/lib/rabbitmq

volumes:
	rabbitmq_data:
```
{% endraw %}`

## Ejemplo Exchange + Queue + DLQ (AMQP)

{% raw %}
```js
const amqp = require("amqplib");

(async () => {
	const conn = await amqp.connect("amqp://localhost");
	const ch = await conn.createChannel();

	const exchange = "orders";
	const queue = "orders.created";
	const dlx = "orders.dlx";
	const dlq = "orders.created.dlq";

	await ch.assertExchange(exchange, "topic", { durable: true });
	await ch.assertExchange(dlx, "direct", { durable: true });

	await ch.assertQueue(dlq, { durable: true });
	await ch.bindQueue(dlq, dlx, "orders.created");

	await ch.assertQueue(queue, {
		durable: true,
		deadLetterExchange: dlx,
		deadLetterRoutingKey: "orders.created"
	});

	await ch.bindQueue(queue, exchange, "orders.created");
})();
```
{% endraw %}

## Ejemplo Producer (Node.js)

{% raw %}
```js
const amqp = require("amqplib");

(async () => {
	const conn = await amqp.connect("amqp://localhost");
	const ch = await conn.createChannel();

	const exchange = "orders";
	const routingKey = "orders.created";

	const message = {
		id: 123,
		total: 99.99,
		date: new Date()
	};

	await ch.assertExchange(exchange, "topic", { durable: true });
	ch.publish(
		exchange,
		routingKey,
		Buffer.from(JSON.stringify(message)),
		{ persistent: true }
	);

	setTimeout(() => conn.close(), 500);
})();
```
{% endraw %}

## Ejemplo Consumer con ACK y reintentos

{% raw %}
```js
const amqp = require("amqplib");

(async () => {
	const conn = await amqp.connect("amqp://localhost");
	const ch = await conn.createChannel();
	const queue = "orders.created";

	await ch.assertQueue(queue, { durable: true });
	ch.prefetch(1);

	ch.consume(queue, msg => {
		try {
			const data = JSON.parse(msg.content.toString());
			console.log("Procesando", data);
			ch.ack(msg);
		} catch (err) {
			ch.nack(msg, false, false);
		}
	});
})();
```
{% endraw %}

## Ejemplo cola con TTL y delay

{% raw %}
```js
await ch.assertQueue("orders.retry", {
	durable: true,
	messageTtl: 30000,
	deadLetterExchange: "orders",
	deadLetterRoutingKey: "orders.created"
});
```
{% endraw %}

## Ejemplo configuraci√≥n de Quorum Queue

{% raw %}
```js
await ch.assertQueue("orders.quorum", {
	durable: true,
	arguments: {
		"x-queue-type": "quorum"
	}
});
```
{% endraw %}

## Ejemplo Virtual Host y permisos

{% raw %}
```bash
rabbitmqctl add_vhost /payments
rabbitmqctl add_user payments_user secret
rabbitmqctl set_permissions -p /payments payments_user ".*" ".*" ".*"
```
{% endraw %}

## Ejemplo plugin Delayed Message Exchange

{% raw %}
```bash
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
```
{% endraw %}

## Casos reales de arquitectura

- **E-commerce**
    - Pedido creado ‚Üí cola
    - Pago, stock, email como consumidores independientes
- **Finanzas**
    - Procesamiento de transacciones
    - Auditor√≠a y conciliaci√≥n
        
- **SaaS**
    - Webhooks
    - Jobs de mantenimiento
        
- **Data pipelines**
    - Ingesta de datos
    - Preprocesamiento previo a Kafka

## Anti-patrones comunes

- Usar RabbitMQ como base de datos
- Una sola cola para todo
- Sin DLQ
- Prefetch infinito
- Consumidores con l√≥gica pesada
- Mensajes gigantes

## Relaci√≥n con otros sistemas

- Complemento de APIs REST
- Alternativa ligera a [Apache Kafka](/backend/apache-kafka/) para workflows
- Backbone de arquitecturas orientadas a mensajes

# Glosario de conceptos de RabbitMQ

## Protocolo y est√°ndares
- **AMQP (Advanced Message Queuing Protocol)**
	- Protocolo de mensajer√≠a est√°ndar usado por RabbitMQ.
	- Define exchanges, colas, bindings y confirmaciones.
- **AMQP 0-9-1**
	- Versi√≥n m√°s usada en producci√≥n.
	- Optimizada para brokers tradicionales de colas.
- **STOMP**
	- Protocolo simple de mensajer√≠a soportado v√≠a plugin.
	- Usado por clientes ligeros.
- **MQTT**
	- Protocolo orientado a IoT.
	- Integrable mediante plugin.

## Componentes principales
- **Broker**
	- Servidor que recibe, enruta y entrega mensajes.
- **Producer (Publisher)**
	- Aplicaci√≥n que env√≠a mensajes al broker.
- **Consumer**
	- Aplicaci√≥n que recibe y procesa mensajes.
- **Exchange**
	- Punto de entrada de mensajes.
	- Decide a qu√© colas se enruta un mensaje.
- **Queue**
	- Estructura FIFO donde se almacenan los mensajes.
- **Binding**
	- Relaci√≥n entre un exchange y una cola.
- **Routing Key**
	- Clave usada para el enrutamiento de mensajes.
- **Virtual Host (vhost)**
	- Espacio l√≥gico aislado dentro del broker.
	- Permite multitenancy.

## Tipos de exchange
- **Direct Exchange**
	- Enruta mensajes por coincidencia exacta de routing key.
- **Fanout Exchange**
	- Env√≠a mensajes a todas las colas enlazadas.
- **Topic Exchange**
	- Usa patrones con comodines (`*`, `#`) para enrutar.
- **Headers Exchange**
	- Enruta por cabeceras del mensaje en lugar de routing keys.

## Confirmaciones y fiabilidad
- **ACK (Acknowledgement)**
	- Confirmaci√≥n de que un mensaje fue procesado correctamente.
- **NACK**
	- Rechazo de un mensaje indicando fallo.
- **Reject**
	- Rechazo expl√≠cito sin reencolar.
- **Requeue**
	- Acci√≥n de devolver el mensaje a la cola.
- **Publisher Confirms**
	- Confirmaci√≥n de que el broker recibi√≥ el mensaje.

## Persistencia y durabilidad
- **Durable Exchange**
	- Exchange que sobrevive a reinicios del broker.
- **Durable Queue**
	- Cola persistente tras reinicios.
- **Persistent Message**
	- Mensaje escrito en disco.
- **Transient Message**
	- Mensaje solo en memoria.
- **At-least-once delivery**
	- Garant√≠a de entrega m√≠nima, puede haber duplicados.

## Gesti√≥n de errores
- **DLX (Dead Letter Exchange)**
	- Exchange que recibe mensajes fallidos.
- **DLQ (Dead Letter Queue)**
	- Cola asociada a un DLX.
	- Usada para auditor√≠a y reprocesado.
- **Retry Queue**
	- Cola intermedia usada para reintentos.
- **Backoff**
	- Retraso progresivo entre reintentos.
- **Poison Message**
	- Mensaje que siempre falla al procesarse.

## Control de flujo y rendimiento
- **Prefetch**
	- L√≠mite de mensajes no confirmados por consumidor.
- **Backpressure**
	- Mecanismo para evitar saturaci√≥n de consumidores.
- **Flow Control**
	- Pausa autom√°tica de productores cuando el broker se satura.
- **Throughput**
	- Cantidad de mensajes procesados por unidad de tiempo.
- **Latency**
	- Tiempo entre publicaci√≥n y consumo del mensaje.

## TTL y expiraci√≥n
- **TTL (Time To Live)**
	- Tiempo m√°ximo de vida de un mensaje o cola.
- **Expired Message**
	- Mensaje eliminado por superar su TTL.
- **Delayed Message**
	- Mensaje entregado tras un tiempo definido (plugin).

## Arquitectura y escalabilidad
- **Node**
	- Instancia individual de RabbitMQ.
- **Cluster**
	- Conjunto de nodos RabbitMQ coordinados.
- **Mirrored Queue**
	- Cola replicada entre nodos (legacy).
- **Quorum Queue**
	- Cola basada en Raft.
	- Alta disponibilidad y consistencia fuerte.
- **Leader**
	- Nodo principal de una quorum queue.
- **Follower**
	- Nodo replicado que sigue al l√≠der.

## Seguridad
- **TLS**
	- Cifrado de comunicaciones.
- **Authentication**
	- Validaci√≥n de identidad de usuarios.
- **Authorization**
	- Permisos sobre exchanges, colas y vhosts.
- **Permissions**
	- Reglas de lectura, escritura y configuraci√≥n.

## Plugins
- **Management Plugin**
	- Interfaz web de administraci√≥n.
- **Delayed Message Exchange Plugin**
	- Permite mensajes diferidos.
- **Shovel**
	- Copia mensajes entre brokers.
- **Federation**
	- Distribuye mensajes entre clusters.
- **MQTT Plugin**
	- Soporte para dispositivos IoT.

## Patrones de mensajer√≠a
- **Work Queue**
	- Distribuci√≥n de tareas entre workers.
- **Publish / Subscribe**
	- Difusi√≥n de eventos a m√∫ltiples consumidores.
- **Routing Pattern**
	- Enrutamiento selectivo por clave.
- **Topic Pattern**
	- Enrutamiento flexible por jerarqu√≠a.
- **Request / Reply**
	- Comunicaci√≥n tipo RPC as√≠ncrona.
- **Event-driven Architecture**
	- Sistemas reaccionan a eventos publicados.

## Conceptos avanzados
- **Idempotencia**
	- Capacidad de procesar mensajes duplicados sin efectos secundarios.
- **Exactly-once (conceptual)**
	- Objetivo l√≥gico, no garantizado nativamente.
- **Message Ordering**
	- Garant√≠a de orden dentro de una cola.
- **Schema Evolution**
	- Cambios de formato de mensajes sin romper consumidores.
- **Contract-first Messaging**
	- Definici√≥n previa del contrato del mensaje.
