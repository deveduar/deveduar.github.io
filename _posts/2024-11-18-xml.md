---
date: 2024-11-18 19:27
title: XML
tags:
  - xnl
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Databases
public_note: "true"
category: Databases
---
# XML
`$= dv.current().file.tags.join(" ")`

## Bases de Datos XML
- [Databases](/uncategorized/databases/)
- Almacenamiento de documentos XML nativo
- Consultas mediante XQuery y XPath
- Bases de datos como eXist-db, BaseX
- Ventajas para datos semi-estructurados

## Consulta y Transformaci√≥n XML
### XSLT (Extensible Stylesheet Language Transformations)
- **Lenguaje para transformar documentos XML**
- Convierte XML a otros formatos (HTML, PDF, texto)
- Utiliza plantillas (templates) para procesar nodos
- [Transformaci√≥n XSLT y probador en l√≠nea](https://magictool.ai/tool/xslt-transformation/es/)
- [XSLT | MDN](https://developer.mozilla.org/es/docs/Web/XSLT)

#### Caracter√≠sticas XSLT
- Procesamiento basado en reglas
- Transformaci√≥n de estructura y contenido
- Soporte para condicionales y bucles
- M√∫ltiples documentos de salida

### XQuery
- **Lenguaje de consulta para documentos XML**
- Similar a SQL pero para datos XML
- Consultas complejas sobre colecciones XML
- [xquery](https://www.javatpoint.com/xquery-first-example)

### XPath
- **Lenguaje para navegar y seleccionar nodos XML**
- Expresiones para localizar elementos
- Usado en XSLT y XQuery
- [XPath, XQuery, and XSLT Function Reference](https://www.w3schools.com/xml/xsl_functions.asp)

## Conceptos Fundamentales XML

### [XML](/databases/xml/) (eXtensible Markup Language)
- **Lenguaje de marcado extensible**
- Almacenamiento e intercambio de datos
- Estructura jer√°rquica y auto-descriptiva
- Sintaxis estricta con etiquetas de apertura y cierre

#### Aplicaciones XML
- **multi step form, con xhtml**
- Configuraciones y preferencias
- Intercambio de datos entre sistemas
- Documentaci√≥n t√©cnica
- Feeds RSS y Atom

### XHTML (EXtensible HyperText Markup Language)
- **Reformulaci√≥n de HTML como aplicaci√≥n XML**
- Sintaxis m√°s estricta que HTML
- Compatible con analizadores XML
- [XHTML - MDN](https://developer.mozilla.org/es/docs/Glossary/XHTML)

#### Caracter√≠sticas XHTML
- Todas las etiquetas deben cerrarse
- Anidamiento correcto requerido
- Atributos entre comillas
- Elementos en min√∫sculas

## Tecnolog√≠as Relacionadas

### Esquemas y Validaci√≥n
- DTD (Document Type Definition)
- XML Schema (XSD)
- RELAX NG

### Procesamiento XML
- SAX (Simple API for XML)
- DOM (Document Object Model)
- StAX (Streaming API for XML)

### Formatos Basados en XML
- SVG (gr√°ficos vectoriales)
- MathML (f√≥rmulas matem√°ticas)
- Office Open XML (documentos Office)


# XSD (XML Schema Definition)

### ¬øQu√© es XSD?

- **Lenguaje basado en XML para definir la estructura y restricciones de documentos XML**
- Alternativa m√°s potente y expresiva que DTD
- Permite validar tanto la **estructura** como el **contenido** de un XML
- Los esquemas XSD son tambi√©n documentos XML

### ¬øPara qu√© sirve XSD?

- Garantizar que un documento XML cumple una estructura esperada
- Definir reglas de negocio a nivel de datos
- Facilitar interoperabilidad entre sistemas
- Detectar errores de forma temprana (validaci√≥n)

### Componentes Principales de XSD

#### Elementos (`xs:element`)

- Definen las etiquetas permitidas en el XML
- Pueden ser simples o complejos
- Permiten establecer cardinalidad (`minOccurs`, `maxOccurs`)

{% raw %}
```xml
<xs:element name="nombre" type="xs:string"/>
```
{% endraw %}

#### Tipos de Datos Simples

- `xs:string`
- `xs:integer`
- `xs:decimal`
- `xs:boolean`
- `xs:date`, `xs:dateTime`
- `xs:float`, `xs:double`

#### Tipos Complejos (`xs:complexType`)

- Definen elementos que contienen otros elementos o atributos
- Pueden tener secuencias, elecciones o todos

{% raw %}
```xml
<xs:complexType name="persona">
  <xs:sequence>
    <xs:element name="nombre" type="xs:string"/>
    <xs:element name="edad" type="xs:integer"/>
  </xs:sequence>
</xs:complexType>
```
{% endraw %}

### Modelos de Contenido

#### `xs:sequence`
- Los elementos deben aparecer en el orden definido

#### `xs:choice`
- Solo uno de los elementos puede aparecer

#### `xs:all`
- Todos los elementos pueden aparecer en cualquier orden (una sola vez)

### Atributos (`xs:attribute`)

- Definen atributos dentro de elementos
- Pueden ser obligatorios u opcionales

{% raw %}
```xml
<xs:attribute name="id" type="xs:ID" use="required"/>
```
{% endraw %}

### Restricciones y Validaciones

#### Restricciones de Valor (`xs:restriction`)
- Limitar valores posibles
- Definir rangos, longitudes o patrones

{% raw %}
```xml
<xs:simpleType name="codigoPostal">
  <xs:restriction base="xs:string">
    <xs:pattern value="[0-9]{5}"/>
  </xs:restriction>
</xs:simpleType>
```
{% endraw %}

#### Enumeraciones

- Lista cerrada de valores permitidos

{% raw %}
```xml
<xs:enumeration value="activo"/>
<xs:enumeration value="inactivo"/>
```
{% endraw %}

### Namespaces en XSD

- Evitan colisiones de nombres
- Uso de prefijos (`xs` normalmente)

{% raw %}
```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
```
{% endraw %}

### Asociaci√≥n XML con XSD

- Mediante atributos en el documento XML

{% raw %}
```xml
<root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="schema.xsd">
```
{% endraw %}

### Ventajas de XSD frente a DTD

- Tipos de datos avanzados
- Es extensible
- Basado en XML
- Mejor control de validaciones
- Soporte de namespaces
    

### Casos de Uso Comunes

- Validaci√≥n de XML en servicios web (SOAP)
- Definici√≥n de contratos de datos
- Integraci√≥n entre sistemas heterog√©neos
- Documentaci√≥n formal de estructuras XML

### Herramientas Relacionadas

- Validadores XSD online
- Soporte en IDEs (IntelliJ, VS Code, Eclipse)
- Librer√≠as de validaci√≥n en Java, Python, .NET

### Relaci√≥n con otras Tecnolog√≠as XML

- XSD + XML ‚Üí Validaci√≥n
- XSD + XPath ‚Üí Navegaci√≥n estructural
- XSD + XSLT ‚Üí Transformaciones seguras
- XSD + XQuery ‚Üí Consultas con tipado fuerte

# Procesamiento XML

El **procesamiento XML** hace referencia a las distintas formas de **leer, recorrer, modificar y generar documentos XML** mediante APIs y modelos de programaci√≥n. La elecci√≥n del m√©todo depende del tama√±o del documento, el rendimiento requerido y el tipo de operaci√≥n a realizar.

---

### Modelos de Procesamiento XML

Existen **tres enfoques principales**:

* Basado en eventos (SAX)
* Basado en √°rbol (DOM)
* Basado en streaming controlado (StAX)

---

## SAX (Simple API for XML)

### ¬øQu√© es SAX?

* **API basada en eventos** para procesar XML
* El parser lee el documento **secuencialmente** y lanza eventos
* No carga el XML completo en memoria

### Funcionamiento

* El parser detecta eventos como:

  * Inicio de documento
  * Inicio de elemento
  * Texto
  * Fin de elemento
* El programador implementa *handlers* para responder a esos eventos

### Caracter√≠sticas

* Muy eficiente en memoria
* Lectura r√°pida
* No permite navegaci√≥n hacia atr√°s
* El XML es de solo lectura

### Ventajas

* Ideal para **XML muy grandes**
* Bajo consumo de memoria
* Alto rendimiento

### Desventajas

* C√≥digo m√°s complejo
* Dif√≠cil de mantener
* No se puede modificar el documento directamente

### Casos de Uso

* Procesamiento de logs en XML
* Importaci√≥n masiva de datos
* Validaci√≥n de grandes documentos

---

## DOM (Document Object Model)

### ¬øQu√© es DOM?

* **Modelo basado en √°rbol**
* El XML completo se carga en memoria
* Cada nodo es un objeto manipulable

### Funcionamiento

* El documento XML se convierte en un √°rbol
* Permite acceso libre a cualquier nodo
* Soporta lectura, modificaci√≥n y escritura

### Caracter√≠sticas

* Acceso aleatorio a nodos
* Navegaci√≥n bidireccional
* F√°cil integraci√≥n con XPath

### Ventajas

* API intuitiva
* F√°cil de entender y depurar
* Ideal para transformaciones y ediciones

### Desventajas

* Alto consumo de memoria
* No recomendable para documentos grandes

### Casos de Uso

* Editores XML
* Transformaciones con XSLT
* Configuraciones peque√±as y medianas

---

## StAX (Streaming API for XML)

### ¬øQu√© es StAX?

* **API de streaming controlada por el programador**
* Modelo *pull* (el programa pide los eventos)
* Alternativa moderna a SAX

### Funcionamiento

* El desarrollador controla el avance del parser
* Se procesan eventos uno a uno
* Permite mayor flexibilidad que SAX

### Caracter√≠sticas

* Streaming bidireccional
* Bajo consumo de memoria
* M√°s control del flujo

### Ventajas

* C√≥digo m√°s legible que SAX
* Eficiente y flexible
* Permite escritura de XML

### Desventajas

* M√°s compleja que DOM
* Menos intuitiva para principiantes

### Casos de Uso

* Procesamiento incremental
* Servicios web
* Aplicaciones de alto rendimiento

---

## Comparativa SAX vs DOM vs StAX

| Caracter√≠stica   | SAX            | DOM   | StAX             |
| ---------------- | -------------- | ----- | ---------------- |
| Modelo           | Eventos (push) | √Årbol | Streaming (pull) |
| Memoria          | Muy baja       | Alta  | Baja             |
| Modificaci√≥n XML | ‚ùå              | ‚úÖ     | ‚úÖ                |
| Facilidad de uso | Baja           | Alta  | Media            |
| Rendimiento      | Muy alto       | Medio | Alto             |

---

## Relaci√≥n con Otras Tecnolog√≠as XML

* **SAX / StAX + XSD** ‚Üí Validaci√≥n en streaming
* **DOM + XPath** ‚Üí Navegaci√≥n sencilla
* **DOM + XSLT** ‚Üí Transformaciones estructurales
* **StAX + Servicios Web** ‚Üí Procesamiento eficiente

---

## ¬øCu√°l elegir?

* **SAX** ‚Üí XML muy grande y solo lectura
* **DOM** ‚Üí XML peque√±o/mediano con modificaciones
* **StAX** ‚Üí Streaming eficiente con control total

---

## Resumen

* SAX: r√°pido y ligero, pero complejo
* DOM: sencillo y potente, pero consume memoria
* StAX: equilibrio entre control y eficiencia
## Procesamiento XML: Ejemplos de C√≥digo y Casos de Uso

Esta nota muestra **ejemplos pr√°cticos de c√≥digo** y **casos reales** para los tres principales modelos de procesamiento XML: **SAX, DOM y StAX**. Los ejemplos est√°n pensados para entender *cu√°ndo* y *c√≥mo* usar cada uno.

---

## SAX (Simple API for XML)

### Caso de Uso

* Lectura de **XML muy grandes**
* Importaci√≥n masiva de datos
* Procesamiento secuencial sin necesidad de modificar el documento

Ejemplo t√≠pico: leer un archivo XML de millones de registros y extraer ciertos valores.

### Ejemplo SAX (Java)

{% raw %}
```java
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;

public class MiSAXHandler extends DefaultHandler {

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        if (qName.equals("persona")) {
            System.out.println("Inicio de persona, id: " + attributes.getValue("id"));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) {
        String texto = new String(ch, start, length).trim();
        if (!texto.isEmpty()) {
            System.out.println("Texto: " + texto);
        }
    }
}
```
{% endraw %}

### Ventajas en la pr√°ctica

* Muy r√°pido
* Consumo m√≠nimo de memoria

### Limitaci√≥n clave

* No se puede volver atr√°s ni modificar el XML

---

## DOM (Document Object Model)

### Caso de Uso

* XML **peque√±o o mediano**
* Necesidad de **leer, modificar y guardar** el documento
* Navegaci√≥n compleja entre nodos

Ejemplo t√≠pico: editar un archivo de configuraci√≥n XML.

### Ejemplo DOM (Java)

{% raw %}
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document doc = builder.parse("personas.xml");

NodeList personas = doc.getElementsByTagName("persona");

for (int i = 0; i < personas.getLength(); i++) {
    Element persona = (Element) personas.item(i);
    String nombre = persona.getElementsByTagName("nombre").item(0).getTextContent();
    System.out.println(nombre);
}
```
{% endraw %}

### Modificaci√≥n del XML

{% raw %}
```java
persona.getElementsByTagName("nombre").item(0).setTextContent("Nuevo Nombre");
```
{% endraw %}

### Ventajas en la pr√°ctica

* Muy intuitivo
* F√°cil de combinar con XPath y XSLT

### Desventaja clave

* Alto consumo de memoria

---

## StAX (Streaming API for XML)

### Caso de Uso

* Procesamiento eficiente
* Streaming con **control total del flujo**
* Servicios web y sistemas de alto rendimiento

Ejemplo t√≠pico: leer XML progresivamente y generar otro XML.

### Ejemplo StAX (Java)

{% raw %}
```java
XMLInputFactory factory = XMLInputFactory.newInstance();
XMLEventReader reader = factory.createXMLEventReader(new FileInputStream("personas.xml"));

while (reader.hasNext()) {
    XMLEvent event = reader.nextEvent();

    if (event.isStartElement()) {
        StartElement start = event.asStartElement();
        if (start.getName().getLocalPart().equals("persona")) {
            System.out.println("Persona encontrada");
        }
    }
}
```
{% endraw %}

### Escritura XML con StAX

{% raw %}
```java
XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
XMLStreamWriter writer = outputFactory.createXMLStreamWriter(System.out);

writer.writeStartDocument();
writer.writeStartElement("persona");
writer.writeAttribute("id", "1");
writer.writeStartElement("nombre");
writer.writeCharacters("Ana");
writer.writeEndElement();
writer.writeEndElement();
writer.writeEndDocument();
```
{% endraw %}

### Ventajas en la pr√°ctica

* M√°s flexible que SAX
* Menor consumo que DOM

### Desventaja clave

* M√°s compleja que DOM

---

## Comparativa con Casos Reales

| Escenario                        | API Recomendada |
| -------------------------------- | --------------- |
| XML gigante solo lectura         | SAX             |
| Editar configuraci√≥n XML         | DOM             |
| Servicio web de alto rendimiento | StAX            |
| Transformaciones complejas       | DOM + XSLT      |
| Procesamiento incremental        | StAX            |

---

## Elecci√≥n R√°pida (Examen)

* **SAX** ‚Üí r√°pido, ligero, solo lectura
* **DOM** ‚Üí f√°cil, modificable, consume memoria
* **StAX** ‚Üí equilibrio entre control y rendimiento

---

## Conclusi√≥n

No existe un m√©todo mejor que otro:

* SAX prioriza **rendimiento**
* DOM prioriza **simplicidad**
* StAX prioriza **control y eficiencia**

La elecci√≥n depende del tama√±o del XML y del tipo de operaci√≥n requerida.


# Consulta y Transformaci√≥n XML: Ejemplos de C√≥digo y Casos de Uso

Esta nota desarrolla **XSLT, XQuery y XPath** con ejemplos pr√°cticos de c√≥digo y escenarios reales de uso. Estas tecnolog√≠as permiten **consultar, filtrar y transformar documentos XML** de forma declarativa.

---

## XPath

### ¬øPara qu√© se usa XPath?

* Seleccionar nodos dentro de un documento XML
* Filtrar informaci√≥n espec√≠fica
* Base para XSLT y XQuery

### Caso de Uso

* Extraer datos concretos sin recorrer manualmente el XML
* Selecci√≥n de nodos en validaciones, transformaciones y consultas

### XML de Ejemplo

{% raw %}
```xml
<personas>
  <persona id="1">
    <nombre>Ana</nombre>
    <edad>30</edad>
  </persona>
  <persona id="2">
    <nombre>Carlos</nombre>
    <edad>25</edad>
  </persona>
</personas>
```
{% endraw %}

### Ejemplos XPath

{% raw %}
```xpath
/personas/persona            // Todas las personas
//persona[@id='1']            // Persona con id=1
//persona[nombre='Ana']       // Persona llamada Ana
//persona/edad/text()         // Edades
//persona[edad>26]            // Personas mayores de 26
```
{% endraw %}

### Ventaja clave

* Sintaxis concisa y potente

---

## XSLT (Extensible Stylesheet Language Transformations)

### Caso de Uso

* Convertir XML a **HTML, texto o PDF**
* Cambiar la estructura del documento
* Generar informes y vistas

Ejemplo t√≠pico: mostrar datos XML como una tabla HTML.

### XML de Entrada

{% raw %}
```xml
<personas>
  <persona>
    <nombre>Ana</nombre>
    <edad>30</edad>
  </persona>
  <persona>
    <nombre>Carlos</nombre>
    <edad>25</edad>
  </persona>
</personas>
```
{% endraw %}

### XSLT ‚Üí HTML

{% raw %}
```xml
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:template match="/">
    <html>
      <body>
        <h2>Lista de Personas</h2>
        <table border="1">
          <tr><th>Nombre</th><th>Edad</th></tr>
          <xsl:for-each select="personas/persona">
            <tr>
              <td><xsl:value-of select="nombre"/></td>
              <td><xsl:value-of select="edad"/></td>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
```
{% endraw %}

### Caracter√≠sticas mostradas

* Templates
* XPath embebido
* Bucles (`xsl:for-each`)

### Casos de Uso Reales

* Generaci√≥n de informes
* Vistas web desde XML
* Transformaciones en backend

---

## XQuery

### ¬øPara qu√© se usa XQuery?

* Consultar colecciones de documentos XML
* Filtrar, ordenar y construir nuevos XML
* Muy usado en **bases de datos XML** (eXist-db, BaseX)

### Caso de Uso

* Consultas complejas similares a SQL
* Integraci√≥n con bases de datos XML

### Ejemplo XQuery

{% raw %}
```xquery
for $p in /personas/persona
where $p/edad > 26
order by $p/nombre
return <persona>{ $p/nombre }</persona>
```
{% endraw %}

### Resultado

{% raw %}
```xml
<persona>
  <nombre>Ana</nombre>
</persona>
```
{% endraw %}

### Construcci√≥n de XML

{% raw %}
```xquery
<resultado>
{
  for $p in /personas/persona
  return <nombre>{data($p/nombre)}</nombre>
}
</resultado>
```
{% endraw %}

### Ventaja clave

* Muy expresivo para consultas complejas

---

## Comparativa Pr√°ctica

| Tecnolog√≠a | Uso Principal     | Ejemplo Real      |
| ---------- | ----------------- | ----------------- |
| XPath      | Seleccionar nodos | Filtrado de datos |
| XSLT       | Transformar XML   | XML ‚Üí HTML        |
| XQuery     | Consultar XML     | Base de datos XML |

---

## Uso Combinado

* **XPath** ‚Üí Selecci√≥n
* **XSLT** ‚Üí Transformaci√≥n
* **XQuery** ‚Üí Consulta avanzada

Ejemplo t√≠pico:

* XPath selecciona nodos
* XSLT transforma resultados
* XQuery consulta grandes colecciones

---

## Elecci√≥n R√°pida (Examen)

* XPath ‚Üí localizar nodos
* XSLT ‚Üí transformar documentos
* XQuery ‚Üí consultar datos XML

---

## Conclusi√≥n

Estas tres tecnolog√≠as forman el n√∫cleo del **procesamiento declarativo XML**:

* XPath es la base
* XSLT transforma
* XQuery consulta y construye

Juntas permiten explotar al m√°ximo documentos y bases de datos XML.

# Recursos y Herramientas XML (Estado 2025‚Äì2026)

Nota de referencia con **herramientas, editores, procesadores y recursos online** para trabajar con **XML, XSD, XPath, XSLT y XQuery**, actualizada al estado del ecosistema en **2026**.

---

## üõ†Ô∏è Editores e IDEs XML

### **Oxygen XML Editor**

* IDE profesional multiplataforma (Windows, macOS, Linux)
* Soporte completo para XML, XSD, RELAX NG, Schematron
* XSLT, XPath y XQuery con depuraci√≥n
* Muy usado en documentaci√≥n t√©cnica y entornos acad√©micos

üîó [https://www.oxygenxml.com/](https://www.oxygenxml.com/)

---

### **Altova XMLSpy**

* IDE avanzado para XML, JSON y servicios web
* Excelente soporte visual para XSD y validaci√≥n
* Depurador XPath / XSLT integrado
* Integraci√≥n con RaptorXML

üîó [https://www.altova.com/xmlspy-xml-editor](https://www.altova.com/xmlspy-xml-editor)

---

### **Liquid XML Studio**

* IDE XML centrado en entorno Windows (.NET)
* Validaci√≥n XML/XSD y dise√±o visual
* Orientado a flujos empresariales

üîó [https://www.liquid-technologies.com/xml-editor](https://www.liquid-technologies.com/xml-editor)

---

### **Visual Studio Code (VS Code)**

* Editor ligero con extensiones XML
* Buen soporte para XSD, XPath y validaci√≥n
* Ideal para proyectos mixtos (XML + c√≥digo)

üîó [https://code.visualstudio.com/](https://code.visualstudio.com/)

---

## ‚öôÔ∏è Procesadores XSLT / XQuery / XPath

### **Saxon**

* Procesador de referencia para XSLT, XPath y XQuery
* Soporte hasta XSLT 3.0 y XPath 3.1
* Versiones HE (open-source), PE y EE
* Muy usado en producci√≥n

üîó [https://www.saxonica.com/](https://www.saxonica.com/)

---

### **RaptorXML**

* Motor de validaci√≥n y transformaci√≥n de alto rendimiento
* Soporte XML, XSD, XSLT, XQuery
* Usado en pipelines y CI/CD

üîó [https://www.altova.com/raptorxml](https://www.altova.com/raptorxml)

---

## üß™ Validaci√≥n Avanzada

### **Schematron**

* Lenguaje de validaci√≥n basado en reglas
* Complementa XSD para reglas de negocio complejas
* Implementado normalmente v√≠a XSLT

üîó [https://schematron.com/](https://schematron.com/)

---

### **RELAX NG**

* Lenguaje alternativo a XSD
* Sintaxis m√°s simple y expresiva
* Muy usado en documentaci√≥n t√©cnica

üîó [https://relaxng.org/](https://relaxng.org/)

---

## üóÑÔ∏è Bases de Datos XML Nativas

### **eXist-db**

* Base de datos XML nativa
* Soporte completo de XQuery y XPath
* Ideal para colecciones XML grandes

üîó [https://exist-db.org/](https://exist-db.org/)

---

### **BaseX**

* Base de datos XML ligera y r√°pida
* Muy usada en entornos acad√©micos
* Excelente soporte XQuery

üîó [https://basex.org/](https://basex.org/)

---

## üåê Herramientas Online y Testing

### **MagicTool ‚Äì XSLT Online**

* Transformaci√≥n XSLT directamente en el navegador
* Ideal para pruebas r√°pidas

üîó [https://magictool.ai/tool/xslt-transformation/es/](https://magictool.ai/tool/xslt-transformation/es/)

---

### **W3Schools ‚Äì XPath / XSLT / XQuery**

* Referencias y ejemplos pr√°cticos
* Entorno de pruebas interactivo

üîó [https://www.w3schools.com/xml/](https://www.w3schools.com/xml/)

---

### **MDN Web Docs ‚Äì XML & XSLT**

* Documentaci√≥n t√©cnica clara y actualizada
* Enfoque web

üîó [https://developer.mozilla.org/es/docs/Web/XML](https://developer.mozilla.org/es/docs/Web/XML)
üîó [https://developer.mozilla.org/es/docs/Web/XSLT](https://developer.mozilla.org/es/docs/Web/XSLT)

---

## üìö Documentaci√≥n Oficial y Est√°ndares

### **W3C ‚Äì XML Technologies**

* Especificaciones oficiales
* XSD, XPath, XSLT, XQuery

üîó [https://www.w3.org/XML/](https://www.w3.org/XML/)

---

## üìà Estado del Ecosistema XML en 2026

* XML sigue siendo **clave en sistemas empresariales, documentaci√≥n y publishing**
* XSLT 3.0 y XPath 3.1 son est√°ndares consolidados
* XML convive con JSON, pero es superior para datos **fuertemente estructurados**
* Bases de datos XML siguen vigentes en nichos espec√≠ficos

---

## üß† Recomendaci√≥n R√°pida

| Necesidad           | Herramienta         |
| ------------------- | ------------------- |
| IDE profesional     | Oxygen XML / XMLSpy |
| Transformaciones    | Saxon               |
| Validaci√≥n avanzada | Schematron          |
| DB XML              | BaseX / eXist-db    |
| Pruebas r√°pidas     | MagicTool           |

---

## üìå Nota Final

Este stack sigue siendo **muy relevante en 2026** para:

* Integraci√≥n de sistemas
* Publicaci√≥n t√©cnica
* Flujos ETL
* Servicios empresariales

XML no est√° obsoleto: est√° **especializado**.

# XML ‚Äì Casos de Uso e Implementaci√≥n

Esta nota resume **casos de uso reales de XML** y muestra **c√≥mo se implementan** usando las tecnolog√≠as vistas: **XSD, XPath, XSLT, XQuery y APIs de procesamiento (DOM / SAX / StAX)**.

---

## 1Ô∏è‚É£ Intercambio de Datos entre Sistemas

### Caso de Uso

* Comunicaci√≥n entre sistemas heterog√©neos
* Integraci√≥n entre aplicaciones empresariales
* Contratos de datos estables

Ejemplo t√≠pico: intercambio de pedidos entre empresas.

### Implementaci√≥n

* **XML** ‚Üí formato de datos
* **XSD** ‚Üí contrato y validaci√≥n
* **DOM / SAX** ‚Üí lectura desde backend

{% raw %}
```xml
<pedido id="P1">
  <cliente>Ana</cliente>
  <total>120.50</total>
</pedido>
```
{% endraw %}

{% raw %}
```xml
<xs:element name="pedido">
  <xs:complexType>
    <xs:sequence>
      <xs:element name="cliente" type="xs:string"/>
      <xs:element name="total" type="xs:decimal"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:string" use="required"/>
  </xs:complexType>
</xs:element>
```
{% endraw %}

---

## 2Ô∏è‚É£ Validaci√≥n de Datos y Reglas de Negocio

### Caso de Uso

* Asegurar integridad de datos
* Detectar errores antes del procesamiento

### Implementaci√≥n

* **XSD** ‚Üí estructura y tipos
* **Schematron** ‚Üí reglas de negocio

Ejemplo de regla:

* Si el total es mayor de 1000, debe existir un descuento

---

## 3Ô∏è‚É£ Generaci√≥n de Informes y Vistas Web

### Caso de Uso

* Mostrar XML como HTML
* Generar informes autom√°ticamente

### Implementaci√≥n

* **XSLT** para transformar XML ‚Üí HTML
* **XPath** para seleccionar datos

{% raw %}
```xml
<xsl:for-each select="personas/persona">
  <p><xsl:value-of select="nombre"/></p>
</xsl:for-each>
```
{% endraw %}

Usado en:

* Publicaci√≥n t√©cnica
* Dashboards est√°ticos

---

## 4Ô∏è‚É£ Consulta de Grandes Colecciones XML

### Caso de Uso

* Repositorios documentales
* Bases de datos XML nativas

### Implementaci√≥n

* **XQuery** + **BaseX / eXist-db**

{% raw %}
```xquery
for $p in /personas/persona
where $p/edad > 30
return $p/nombre
```
{% endraw %}

Ventaja:

* Consultas complejas tipo SQL

---

## 5Ô∏è‚É£ Procesamiento de XML Muy Grandes

### Caso de Uso

* Logs
* Exportaciones masivas
* Big XML

### Implementaci√≥n

* **SAX** o **StAX** (streaming)

{% raw %}
```java
if (event.isStartElement()) {
  if (event.asStartElement().getName().getLocalPart().equals("registro")) {
    // procesar registro
  }
}
```
{% endraw %}

Beneficio:

* Bajo consumo de memoria

---

## 6Ô∏è‚É£ Configuraci√≥n de Aplicaciones

### Caso de Uso

* Archivos de configuraci√≥n
* Preferencias de usuario

### Implementaci√≥n

* **DOM** para lectura y modificaci√≥n
* **XPath** para acceso r√°pido

Ejemplo:

{% raw %}
```xpath
/config/puerto
```
{% endraw %}

---

## 7Ô∏è‚É£ Servicios Web y APIs (SOAP)

### Caso de Uso

* Comunicaci√≥n estructurada
* Contratos estrictos

### Implementaci√≥n

* **XML + XSD** ‚Üí contrato
* **XPath** ‚Üí extracci√≥n
* **StAX** ‚Üí rendimiento

Usado en:

* Sistemas legacy
* Integraciones bancarias

---

## 8Ô∏è‚É£ Documentaci√≥n T√©cnica y Publishing

### Caso de Uso

* Manuales
* Normativas
* Libros t√©cnicos

### Implementaci√≥n

* **XML** como fuente √∫nica
* **XSLT** ‚Üí HTML / PDF

Ejemplo:

* DocBook + XSLT

---

## üîÅ Flujo de Implementaci√≥n T√≠pico

1. Definir estructura ‚Üí **XSD**
2. Validar XML
3. Consultar datos ‚Üí **XPath / XQuery**
4. Transformar salida ‚Üí **XSLT**
5. Procesar en backend ‚Üí **DOM / SAX / StAX**

---

## üß† Elecci√≥n R√°pida (Examen)

| Necesidad          | Tecnolog√≠a |
| ------------------ | ---------- |
| Validar estructura | XSD        |
| Reglas complejas   | Schematron |
| Transformar XML    | XSLT       |
| Consultar XML      | XQuery     |
| XML grande         | SAX / StAX |
| Editar XML         | DOM        |

---

## ‚úÖ Conclusi√≥n

XML sigue siendo una **tecnolog√≠a clave** cuando se necesita:

* Estructura estricta
* Validaci√≥n fuerte
* Transformaciones complejas

Cada tecnolog√≠a cumple un rol concreto dentro del ecosistema XML.
