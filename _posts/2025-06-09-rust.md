---
date: 2025-06-09 16:46
title: Rust
tags:
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
public_note: "true"
category: rust
categories:
  - rust
  - hide-embedded-header1
  - Desarrollo multiplataforma
---
# Rust
``$= dv.current().file.tags.join(" ")``

## Visi√≥n general
Rust es un lenguaje de programaci√≥n de sistemas enfocado en **seguridad de memoria**, **concurrencia sin data races** y **alto rendimiento**, sin necesidad de garbage collector. Es ampliamente usado en sistemas, backend, herramientas CLI, WebAssembly, embebidos y software cr√≠tico.

## Caracter√≠sticas clave
- **Seguridad de memoria en tiempo de compilaci√≥n**
	- Sistema de ownership, borrowing y lifetimes que previene null pointers, use-after-free y data races.
- **Alto rendimiento**
	- Compilaci√≥n a c√≥digo nativo con rendimiento comparable a C/C++.
- **Concurrencia segura**
	- El modelo de tipos evita condiciones de carrera en tiempo de compilaci√≥n.
- **Tooling moderno**
	- Gestor de paquetes, compilaci√≥n y testing integrados mediante Cargo.
- **Ecosistema activo**
	- Amplia colecci√≥n de crates para backend, CLI, crypto, WASM, embedded y m√°s.

## Casos de uso habituales
- **Sistemas y bajo nivel**
	- Sistemas operativos, drivers, runtimes, motores de bases de datos.
- **Backend y servicios**
	- APIs de alto rendimiento, microservicios, sistemas distribuidos.
- **CLI y tooling**
	- Herramientas r√°pidas, seguras y portables.
- **WebAssembly**
	- L√≥gica de alto rendimiento ejecut√°ndose en navegador o runtimes WASM.
- **Embedded**
	- Firmware seguro para microcontroladores sin sistema operativo.

## Documentaci√≥n oficial
- **The Rust Programming Language (Book)**
	- Gu√≠a oficial completa desde fundamentos hasta conceptos avanzados.
- **Referencia del lenguaje**
	- Especificaci√≥n formal de sintaxis y sem√°ntica.
- **Rustonomicon**
	- Uso avanzado y seguro de `unsafe`.

## Instalaci√≥n
- **Instalaci√≥n general**
	- Installation - The Rust Programming Language-ch01-01-installation.html
- **Instalaci√≥n en Windows**
	- Windows - The rustup book-windows.html

## Toolchain y herramientas
- **rustup**
	- Gestor de versiones y toolchains de Rust.
- **cargo**
	- Compilaci√≥n, gesti√≥n de dependencias, testing y benchmarking.
- **rustfmt**
	- Formateo autom√°tico de c√≥digo seg√∫n est√°ndares oficiales.
- **clippy**
	- Linter avanzado con recomendaciones de buenas pr√°cticas.
- **rust-analyzer**
	- Soporte IDE: autocompletado, refactorizaci√≥n y an√°lisis est√°tico.

## Conceptos fundamentales
- **Ownership**
	- Cada valor tiene un √∫nico due√±o responsable de su liberaci√≥n.
- **Borrowing**
	- Pr√©stamos inmutables o mutables con reglas estrictas.
- **Lifetimes**
	- Anotaciones que describen cu√°nto tiempo viven las referencias.
- **Traits**
	- Interfaces para definir comportamiento compartido.
- **Enums y pattern matching**
	- Modelado de estados complejos y control de flujo expresivo.
- **Option y Result**
	- Manejo expl√≠cito de valores opcionales y errores.

## Gesti√≥n de dependencias
- **crates.io**
	- Registro oficial de librer√≠as.
- **Cargo.toml**
	- Definici√≥n de dependencias, features y perfiles de compilaci√≥n.
- **Workspaces**
	- Organizaci√≥n de proyectos grandes con m√∫ltiples crates.

## Testing y calidad
- **Tests unitarios**
	- Integrados en el propio lenguaje.
- **Tests de integraci√≥n**
	- Ejecutados desde el directorio `tests/`.
- **Benchmarks**
	- Medici√≥n de rendimiento con herramientas est√°ndar.
- **Auditor√≠a de dependencias**
	- An√°lisis de seguridad en crates externos.

## Seguridad y `unsafe`
- **C√≥digo seguro por defecto**
	- La mayor√≠a del c√≥digo no requiere `unsafe`.
- **Bloques `unsafe`**
	- Acceso controlado a operaciones de bajo nivel.
- **Buenas pr√°cticas**
	- Encapsular `unsafe` y exponer APIs seguras.

## Ecosistema y comunidad
- **Rust Foundation**
	- Gobernanza y sostenibilidad del lenguaje.
- **RFCs**
	- Propuestas abiertas para evoluci√≥n del lenguaje.
- **Comunidades**
	- Foros, Discord, Reddit y eventos como RustConf.

## Integraci√≥n con otros lenguajes
- **FFI**
	- Interoperabilidad con C y otros lenguajes.
- **Bindings**
	- Uso de Rust como librer√≠a desde otros entornos.
- **WASM**
	- Integraci√≥n con JavaScript y runtimes web.

## Rendimiento y optimizaci√≥n
- **Zero-cost abstractions**
	- Abstracciones sin penalizaci√≥n en runtime.
- **Perfilado**
	- Identificaci√≥n de cuellos de botella.
- **Control de memoria**
	- Asignadores personalizados y estructuras eficientes.
# Rust


## Modelo de tipos avanzado
- **Tipos algebraicos**
	- Uso extensivo de `struct`, `enum` y combinaciones para modelar dominios complejos de forma segura.
- **Tipos gen√©ricos**
	- Parametrizaci√≥n de tipos con comprobaciones en tiempo de compilaci√≥n.
- **Associated types**
	- Definici√≥n de tipos dependientes dentro de traits para APIs m√°s expresivas.
- **Const generics**
	- Par√°metros constantes en tipos (por ejemplo tama√±os de arrays) verificados en compilaci√≥n.
- **PhantomData**
	- Tipos fantasma para expresar relaciones sin coste en runtime.

## Manejo avanzado de errores
- **Propagaci√≥n con `?`**
	- Simplificaci√≥n del flujo de errores sin perder contexto.
- **Errores personalizados**
	- Definici√≥n de enums de error ricos y tipados.
- **Contexto de error**
	- A√±adir informaci√≥n sem√°ntica sin romper la cadena de errores.
- **No panicking APIs**
	- Dise√±o de librer√≠as que evitan `panic!` en favor de `Result`.

## Macros
- **Macros declarativas (`macro_rules!`)**
	- Metaprogramaci√≥n basada en patrones.
- **Macros procedimentales**
	- Derive macros para generaci√≥n autom√°tica de c√≥digo.
	- Attribute macros para modificar comportamiento.
- **Casos de uso**
	- Reducci√≥n de boilerplate, DSLs y validaciones en compilaci√≥n.

## Asincron√≠a y concurrencia avanzada
- **Modelo async/await**
	- Futures evaluados de forma perezosa.
- **Executors**
	- Separaci√≥n entre definici√≥n y ejecuci√≥n de tareas async.
- **Send y Sync**
	- Garant√≠as de seguridad entre hilos a nivel de tipos.
- **Canales**
	- Comunicaci√≥n segura entre threads y tareas async.
- **Lock-free programming**
	- Estructuras concurrentes sin bloqueos cuando es necesario.

## Gesti√≥n de memoria avanzada
- **Smart pointers**
	- `Box`, `Rc`, `Arc`, `RefCell` y combinaciones.
- **Interior mutability**
	- Mutabilidad controlada respetando el modelo de ownership.
- **Asignadores personalizados**
	- Control fino del heap para casos espec√≠ficos.
- **Stack vs Heap**
	- Decisiones expl√≠citas de almacenamiento y coste.

## Arquitectura de proyectos
- **Crates binarios y librer√≠as**
	- Separaci√≥n clara entre ejecutables y APIs reutilizables.
- **M√≥dulos**
	- Organizaci√≥n jer√°rquica del c√≥digo.
- **Features flags**
	- Compilaci√≥n condicional para reducir dependencias y tama√±o.
- **Public API design**
	- Estabilidad, semver y compatibilidad hacia atr√°s.

## Cross-compilation y plataformas
- **Targets**
	- Soporte para m√∫ltiples arquitecturas y sistemas operativos.
- **No-std**
	- Desarrollo sin librer√≠a est√°ndar para entornos restringidos.
- **Embedded HAL**
	- Abstracciones comunes para hardware embebido.
- **Linking**
	- Integraci√≥n con toolchains externos.

## Web y redes
- **HTTP y networking**
	- Clientes y servidores de alto rendimiento.
- **Async IO**
	- Entrada/salida no bloqueante eficiente.
- **Web frameworks**
	- Arquitecturas basadas en middleware y routing tipado.
- **Seguridad en red**
	- TLS, manejo seguro de credenciales y criptograf√≠a.

## WebAssembly (WASM)
- **Compilaci√≥n a WASM**
	- Targets espec√≠ficos para navegador y servidores.
- **Interop con JavaScript**
	- Llamadas bidireccionales seguras.
- **Optimizaci√≥n de tama√±o**
	- Eliminaci√≥n de c√≥digo muerto y perfiles de compilaci√≥n.
- **Casos de uso**
	- Frontend pesado, plugins y extensiones sandboxed.

## Observabilidad y diagn√≥stico
- **Logging estructurado**
	- Logs tipados y contextualizados.
- **Tracing**
	- Instrumentaci√≥n para sistemas distribuidos.
- **Debugging**
	- Herramientas y s√≠mbolos de depuraci√≥n.
- **Crash analysis**
	- Backtraces y dumps controlados.

## Seguridad avanzada
- **Criptograf√≠a**
	- Implementaciones seguras y revisadas.
- **Auditor√≠as**
	- Revisi√≥n autom√°tica de dependencias vulnerables.
- **Memory safety guarantees**
	- Comparativa con lenguajes no seguros.
- **Supply chain**
	- Control de versiones y verificaci√≥n de integridad.

## Estabilidad y evoluci√≥n del lenguaje
- **Edition system**
	- Evoluci√≥n sin romper c√≥digo existente.
- **SemVer**
	- Reglas estrictas de versionado.
- **Nightly vs Stable**
	- Uso consciente de features experimentales.
- **RFC process**
	- C√≥mo se introducen nuevas caracter√≠sticas.

## Rendimiento extremo
- **Inlining y monomorfizaci√≥n**
	- Especializaci√≥n del c√≥digo gen√©rico.
- **Profile-guided optimization**
	- Optimizaci√≥n basada en datos reales.
- **SIMD**
	- Uso de instrucciones vectoriales.
- **Zero-allocation patterns**
	- Dise√±o de APIs sin asignaciones din√°micas.

## Comparativas y posicionamiento
- **Rust vs C/C++**
	- Seguridad frente a control manual.
- **Rust vs Go**
	- Control de memoria vs simplicidad.
- **Rust vs Java**
	- Performance nativa y footprint.
- **Rust como lenguaje estrat√©gico**
	- Uso en infraestructura cr√≠tica y largo plazo.

# Recursos Rust (2025-2026)

## Documentaci√≥n oficial y gu√≠as
- **The Rust Programming Language (Rust Book)** ‚Äì Gu√≠a oficial completa desde conceptos b√°sicos hasta avanzados; versi√≥n alineada con Rust estable y `edition = "2024"`.
	- [Libro oficial de Rust](https://doc.rust-lang.org/stable/book/)
- **Documentaci√≥n central de Rust** ‚Äì √çndices de sintaxis, gu√≠a de Cargo, referencia de la librer√≠a est√°ndar, errores del compilador y notas de lanzamiento.
	- [Documentaci√≥n oficial de Rust](https://www.rust-lang.org/learn)
	- [Referencia del lenguaje](https://doc.rust-lang.org/reference/)
	- [Librer√≠a est√°ndar](https://doc.rust-lang.org/std/)
- **Ruta de Aprendizaje para Rust (ES)** ‚Äì Hoja de ruta interactiva mantenida por la comunidad hispanohablante.
	- [Rust Roadmap en Espa√±ol](https://roadmap.rustlang-es.org/)

## Cursos y formaci√≥n actualizados
- **Rust Fundamentals and Ecosystem (Udemy)** ‚Äì Curso actualizado en 2025 que cubre fundamentos, tooling y ecosistema.
	- [Curso Rust Fundamentals and Ecosystem](https://www.udemy.com/course/rust-programming-language-z/)
- **El Curso Completo de Programaci√≥n Rust 2025 (Udemy en espa√±ol)** ‚Äì Curso desde nivel inicial hasta avanzado con proyectos.
	- [Curso completo de Rust en espa√±ol](https://www.udemy.com/course/rust-curso/)

## Recursos gratuitos para aprender Rust
- **14 Free Resources to Master Rust** ‚Äì Colecci√≥n curada de recursos gratuitos que incluye libro oficial, ejemplos y ejercicios pr√°cticos.
	- [14 recursos gratuitos para aprender Rust](https://www.rustcodeweb.com/2025/03/free-resources-to-master-rust-programming.html)
- **Rust by Example** ‚Äì Aprendizaje basado en ejemplos ejecutables.
	- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- **Rustlings** ‚Äì Ejercicios interactivos para practicar Rust desde la l√≠nea de comandos.
	- [Repositorio Rustlings](https://github.com/rust-lang/rustlings)
- **Awesome Rust** ‚Äì Lista curada de librer√≠as, herramientas y recursos del ecosistema.
	- [Awesome Rust en GitHub](https://github.com/rust-unofficial/awesome-rust)

## Comunidades y newsletters
- **Rust Lang en Espa√±ol** ‚Äì Comunidad hispanohablante con recursos, art√≠culos y eventos.
	- [Rust en Espa√±ol](https://rustlang-es.org/)
- **This Week in Rust** ‚Äì Newsletter semanal con noticias, lanzamientos y eventos del ecosistema.
	- [This Week in Rust](https://this-week-in-rust.org/)
- **The Embedded Rustacean** ‚Äì Newsletter especializada en Rust embedded y `no_std`.
	- [The Embedded Rustacean](https://www.theembeddedrustacean.com/)

## Eventos y conferencias relevantes
- **RustConf** ‚Äì Conferencia principal del ecosistema Rust.
	- [RustConf](https://rustconf.com/)
- **RustWeek / RustNation / Tokio RustConf** ‚Äì Eventos regionales e internacionales centrados en Rust.
	- [RustWeek](https://rustweek.org/)
- **Meetups de Rust** ‚Äì Encuentros locales y virtuales organizados por la comunidad.
	- [Rust Meetups](https://www.meetup.com/topics/rust/)

## Ecosistema y herramientas productivas
- **Tokio** ‚Äì Runtime async de referencia para Rust.
	- [Tokio](https://tokio.rs/)
- **async-std** ‚Äì Alternativa async basada en la librer√≠a est√°ndar.
	- [async-std](https://async.rs/)
- **docs.rs** ‚Äì Documentaci√≥n generada autom√°ticamente para crates publicados.
	- [docs.rs](https://docs.rs/)
- **rust-analyzer** ‚Äì Soporte IDE avanzado para Rust.
	- [rust-analyzer](https://rust-analyzer.github.io/)
- **Cargo** ‚Äì Gestor de paquetes, builds y testing.
	- [Cargo Book](https://doc.rust-lang.org/cargo/)

## Avances del ecosistema Rust (estado 2025)
- **Rust Foundation ‚Äì Technology Report 2025** ‚Äì Informe sobre seguridad del supply chain, tooling y adopci√≥n industrial.
	- [Rust Foundation Technology Report](https://rustfoundation.org/)
- **Adopci√≥n industrial**
	- Uso creciente en sistemas operativos, cloud, blockchain, navegadores y software cr√≠tico.
- **Ediciones y estabilidad**
	- Consolidaci√≥n del sistema de ediciones y evoluci√≥n sin rupturas del lenguaje.

## Otras fuentes √∫tiles
- **Blogs t√©cnicos**
	- [Inside Rust Blog](https://blog.rust-lang.org/inside-rust/)
	- [Rust Blog Oficial](https://blog.rust-lang.org/)
- **Foros y discusi√≥n**
	- [Rust Users Forum](https://users.rust-lang.org/)
	- [Reddit r/rust](https://www.reddit.com/r/rust/)

## Quick Links √ötiles (para Obsidian)
- [The Rust Programming Language](https://doc.rust-lang.org/stable/book/)
- [Documentaci√≥n oficial de Rust](https://www.rust-lang.org/learn)
- [Awesome Rust](https://github.com/rust-unofficial/awesome-rust)
- [This Week in Rust](https://this-week-in-rust.org/)
# Gu√≠a Fundamental y Temario Rust (2025-2026)

## Temario base ‚Äî Libro oficial *(The Rust Programming Language)*
**Fuente oficial del aprendizaje estructurado de Rust.**
1. Introducci√≥n a Rust: ¬øqu√© es Rust y por qu√© usarlo?
2. Instalaci√≥n de Rust y configuraci√≥n del entorno.
3. Primeros pasos: ‚ÄúHello, World!‚Äù y estructura de un programa.
4. Conceptos de Ownership (propiedad), Borrowing (pr√©stamos) y Lifetimes (tiempos de vida).
5. Variables y mutabilidad.
6. Tipos de datos y anotaciones de tipos.
7. Funciones, par√°metros y retornos.
8. Control de flujo: `if`, `loop`, `while`, `for`.
9. Manejo de errores con `Result` y `Option`.
10. Colecciones: `Vec`, `String`, `HashMap`.
11. Structs y Enums.
12. Pattern matching con `match`.
13. Traits y gen√©ricos.
14. M√≥dulos y paquetes con Cargo.
15. Clases de proyecto y ejecuci√≥n con Cargo.
16. Tests, benchmarks y documentaci√≥n.
17. C√≥digo seguro y uso de `unsafe`.
18. Concurrencia y programaci√≥n asincr√≥nica.
- [The Rust Programming Language ‚Äì Libro oficial](https://doc.rust-lang.org/stable/book/)

## Temario complementario de curso pr√°ctico *(estilo Udemy / gu√≠a aplicada)*
1. Instalaci√≥n de Rust y configuraci√≥n de IDE (VSCode, plugins).
2. Comandos b√°sicos de Cargo y rustup.
3. Primer proyecto: estructura de carpetas y compilaci√≥n.
4. Variables, mutabilidad y shadowing.
5. Tipos de datos: escalares, compuestos y literales.
6. Entrada y salida de datos.
7. Control de flujo y bucles.
8. Funciones, closures e iteradores.
9. Propiedad, referencias y borrowing.
10. Manejo de errores con `panic!`, `Result` y combinadores.
11. Structs, `impl` y m√©todos asociados.
12. Enums y pattern matching avanzado.
13. Traits, gen√©ricos y bounds.
14. Vectores, strings y colecciones est√°ndar.
15. M√≥dulos, crates y dependencias externas.
16. Lectura y escritura de archivos (I/O).
17. Concurrencia b√°sica y `async/await`.
18. Proyecto pr√°ctico final integrador (CLI o aplicaci√≥n simple).
- [Curso completo de Rust en espa√±ol (Udemy)](https://www.udemy.com/course/rust-curso/)

## Temario alternativo pr√°ctico *(seg√∫n syllabus de curso gen√©rico)*
1. ¬øQu√© es Rust? Historia y ventajas.
2. Preparaci√≥n del entorno: rustup, cargo, rust-analyzer.
3. Conceptos fundamentales: variables, tipos y expresiones.
4. Propiedad y pr√©stamo profundo.
5. Smart pointers (`Box`, `Rc`, `Arc`).
6. Gesti√≥n de errores: `Result`, `unwrap`, propagaci√≥n con `?`.
7. Manejo de memoria autom√°tico y borrow checker.
8. M√©todos, funciones, closures e iteradores.
9. Concurrencia segura con hilos y async.
10. Testing, debugging, linting (`clippy`) y formateo (`rustfmt`).
11. Cargo avanzado: workspaces y features.
12. Integraci√≥n con C (FFI).
13. Desarrollo de aplicaciones de red o servicios.
14. Performance y optimizaci√≥n.
- [Comprehensive Rust (Google)](https://google.github.io/comprehensive-rust/es/index.html)

## Contenidos sugeridos adicionales *(complementarios a 2025)*
- Uso de Rust en WebAssembly (WASM): compilaci√≥n y modelos de integraci√≥n.
- Crates y frameworks relevantes: Tokio (async), Actix / Dioxus (web y GUI).
- Buenas pr√°cticas de dise√±o de APIs en Rust.
- Benchmarking y profiling con herramientas modernas.
- Desarrollo seguro y auditor√≠a de dependencias.
- Rust Embedded y `no_std` para sistemas sin librer√≠a est√°ndar.
- [Rust Guide](https://rust.guide/)

## Temario breve para principiantes *(curso gratuito, enfoque progresivo)*
1. Variables y tipos de datos (`int`, `float`, `bool`, `char`).
2. Control de flujo: `if`, bucles.
3. Ownership, Borrowing y Lifetimes.
4. Structs, enums, m√©todos y pattern matching.
5. Colecciones b√°sicas (`Vec`, `String`, `HashMap`).
6. Manejo de errores (`panic`, `Result`).
7. Traits, gen√©ricos, closures e iteradores.
8. Avanzado: smart pointers y concurrencia.

## Recursos estructurados en la web (para estudiar cada bloque)
- **Rust oficial (Book)** ‚Äî gu√≠a completa, gratuita y siempre actualizada.
	- [Libro oficial de Rust](https://doc.rust-lang.org/stable/book/)
- **Rust by Example** ‚Äî aprendizaje basado en ejemplos ejecutables.
	- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- **Rustlings** ‚Äî ejercicios interactivos para practicar sintaxis y conceptos.
	- [Rustlings en GitHub](https://github.com/rust-lang/rustlings)
- **Comprehensive Rust (Google)** ‚Äî curso intensivo y estructurado.
	- [Comprehensive Rust](https://google.github.io/comprehensive-rust/es/index.html)
- **Rust Guide** ‚Äî tutoriales tem√°ticos y listas de conceptos.
	- [Rust Guide](https://rust.guide/)
# Gu√≠a Fundamental de Rust con Ejemplos de C√≥digo (2025-2026)

## Instalaci√≥n y primer programa

### Hello World
{% raw %}
```rust
fn main() {
	println!("Hello, world!");
}
```
{% endraw %}`

## Variables y mutabilidad

### Variables inmutables y mutables

{% raw %}
```rust
fn main() {
	let x = 10;
	let mut y = 20;

	y += 5;

	println!("x = {}, y = {}", x, y);
}
```
{% endraw %}

### Shadowing

{% raw %}
```rust
fn main() {
	let x = 5;
	let x = x + 1;
	let x = x * 2;

	println!("x = {}", x);
}
```
{% endraw %}

## Tipos de datos

### Tipos escalares y compuestos

{% raw %}
```rust
fn main() {
	let entero: i32 = 42;
	let flotante: f64 = 3.14;
	let booleano: bool = true;
	let caracter: char = 'R';

	let tupla: (i32, f64, char) = (1, 2.5, 'a');
	let array: [i32; 3] = [1, 2, 3];

	println!("{:?} {:?}", tupla, array);
}
```
{% endraw %}

## Control de flujo

### Condicionales y bucles

{% raw %}
```rust
fn main() {
	let n = 5;

	if n > 0 {
		println!("positivo");
	} else {
		println!("no positivo");
	}

	for i in 0..n {
		println!("i = {}", i);
	}
}
```
{% endraw %}

## Funciones

### Funciones con retorno

{% raw %}
```rust
fn suma(a: i32, b: i32) -> i32 {
	a + b
}

fn main() {
	let r = suma(2, 3);
	println!("resultado = {}", r);
}
```
{% endraw %}

## Ownership y Borrowing

### Movimiento de ownership

{% raw %}
```rust
fn main() {
	let s1 = String::from("rust");
	let s2 = s1;

	// println!("{}", s1); // error: ownership movido
	println!("{}", s2);
}
```
{% endraw %}

### Referencias y pr√©stamos

{% raw %}
```rust
fn longitud(s: &String) -> usize {
	s.len()
}

fn main() {
	let texto = String::from("hola");
	let len = longitud(&texto);

	println!("{} tiene longitud {}", texto, len);
}
```
{% endraw %}

## Structs

### Definici√≥n y uso de structs

{% raw %}
```rust
struct Usuario {
	nombre: String,
	edad: u8,
}

fn main() {
	let user = Usuario {
		nombre: String::from("Ana"),
		edad: 30,
	};

	println!("{} tiene {} a√±os", user.nombre, user.edad);
}
```
{% endraw %}

## Enums y pattern matching

### Enum con match

{% raw %}
```rust
enum Estado {
	Activo,
	Inactivo,
}

fn estado_a_texto(e: Estado) -> &'static str {
	match e {
		Estado::Activo => "activo",
		Estado::Inactivo => "inactivo",
	}
}

fn main() {
	let e = Estado::Activo;
	println!("{}", estado_a_texto(e));
}
```
{% endraw %}

## Option y Result

### Uso de Option

{% raw %}
```rust
fn dividir(a: i32, b: i32) -> Option<i32> {
	if b == 0 {
		None
	} else {
		Some(a / b)
	}
}

fn main() {
	match dividir(10, 2) {
		Some(v) => println!("resultado {}", v),
		None => println!("no se puede dividir"),
	}
}
```
{% endraw %}

### Manejo de errores con Result

{% raw %}
```rust
fn dividir(a: i32, b: i32) -> Result<i32, String> {
	if b == 0 {
		Err(String::from("divisi√≥n por cero"))
	} else {
		Ok(a / b)
	}
}

fn main() {
	match dividir(10, 0) {
		Ok(v) => println!("resultado {}", v),
		Err(e) => println!("error: {}", e),
	}
}
```
{% endraw %}

## Colecciones

### Vectores

{% raw %}
```rust
fn main() {
	let mut numeros = Vec::new();
	numeros.push(1);
	numeros.push(2);

	for n in &numeros {
		println!("{}", n);
	}
}
```
{% endraw %}

### HashMap

{% raw %}
```rust
use std::collections::HashMap;

fn main() {
	let mut edades = HashMap::new();
	edades.insert("Ana", 30);
	edades.insert("Luis", 25);

	for (nombre, edad) in edades {
		println!("{}: {}", nombre, edad);
	}
}
```
{% endraw %}

## Traits

### Definici√≥n e implementaci√≥n

{% raw %}
```rust
trait Describible {
	fn describir(&self) -> String;
}

struct Producto {
	nombre: String,
	precio: f64,
}

impl Describible for Producto {
	fn describir(&self) -> String {
		format!("{} cuesta {}", self.nombre, self.precio)
	}
}

fn main() {
	let p = Producto {
		nombre: String::from("Libro"),
		precio: 9.99,
	};

	println!("{}", p.describir());
}
```
{% endraw %}

## Concurrencia b√°sica

### Hilos (threads)

{% raw %}
```rust
use std::thread;

fn main() {
	let handle = thread::spawn(|| {
		for i in 1..5 {
			println!("hilo: {}", i);
		}
	});

	handle.join().unwrap();
}
```
{% endraw %}

## Programaci√≥n asincr√≥nica

### async / await con Tokio

{% raw %}
```rust
#[tokio::main]
async fn main() {
	let resultado = tarea_async().await;
	println!("{}", resultado);
}

async fn tarea_async() -> i32 {
	42
}
```
{% endraw %}

## Testing

### Test unitario b√°sico

{% raw %}
```rust
fn suma(a: i32, b: i32) -> i32 {
	a + b
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_suma() {
		assert_eq!(suma(2, 3), 5);
	}
}
```
{% endraw %}

## Uso de unsafe (caso m√≠nimo)

### Bloque unsafe controlado

{% raw %}
```rust
fn main() {
	let mut x = 5;
	let r = &mut x as *mut i32;

	unsafe {
		*r += 1;
	}

	println!("{}", x);
}
```
{% endraw %}

# Gu√≠a Avanzada de Rust con Ejemplos de C√≥digo (2025-2026)

## Lifetimes expl√≠citos

### Funci√≥n con lifetimes anotados
{% raw %}
```rust
fn mayor<'a>(a: &'a str, b: &'a str) -> &'a str {
	if a.len() > b.len() {
		a
	} else {
		b
	}
}

fn main() {
	let x = String::from("rust");
	let y = String::from("lenguaje");
	println!("{}", mayor(&x, &y));
}
```
{% endraw %}`

## Traits avanzados

### Traits con m√©todos por defecto y bounds

{% raw %}
```rust
trait Resumen {
	fn resumen(&self) -> String {
		String::from("Sin resumen")
	}
}

trait Imprimible: Resumen {
	fn imprimir(&self) {
		println!("{}", self.resumen());
	}
}

struct Articulo {
	titulo: String,
}

impl Resumen for Articulo {
	fn resumen(&self) -> String {
		self.titulo.clone()
	}
}

impl Imprimible for Articulo {}

fn main() {
	let a = Articulo {
		titulo: String::from("Rust avanzado"),
	};

	a.imprimir();
}
```
{% endraw %}

## Gen√©ricos complejos

### Gen√©ricos con m√∫ltiples bounds

{% raw %}
```rust
use std::fmt::Display;

fn mostrar<T: Display + Clone>(valor: T) {
	let copia = valor.clone();
	println!("{}", copia);
}

fn main() {
	mostrar(42);
	mostrar(String::from("Rust"));
}
```
{% endraw %}

## Associated Types

### Uso de associated types en traits

{% raw %}
```rust
trait Contenedor {
	type Item;

	fn obtener(&self) -> Self::Item;
}

struct Caja(i32);

impl Contenedor for Caja {
	type Item = i32;

	fn obtener(&self) -> Self::Item {
		self.0
	}
}

fn main() {
	let c = Caja(10);
	println!("{}", c.obtener());
}
```
{% endraw %}

## Const Generics

### Tipos con tama√±o en tiempo de compilaci√≥n

{% raw %}
```rust
struct Buffer<const N: usize> {
	datos: [u8; N],
}

fn main() {
	let b: Buffer<8> = Buffer { datos: [0; 8] };
	println!("tama√±o = {}", b.datos.len());
}
```
{% endraw %}

## Smart pointers e interior mutability

### Rc y RefCell

{% raw %}
```rust
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
	let valor = Rc::new(RefCell::new(5));

	let a = Rc::clone(&valor);
	let b = Rc::clone(&valor);

	*a.borrow_mut() += 10;
	println!("{}", b.borrow());
}
```
{% endraw %}

## Manejo avanzado de errores

### Error personalizado con enum

{% raw %}
```rust
use std::fmt;

#[derive(Debug)]
enum ErrorApp {
	NoEncontrado,
	PermisoDenegado,
}

impl fmt::Display for ErrorApp {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			ErrorApp::NoEncontrado => write!(f, "recurso no encontrado"),
			ErrorApp::PermisoDenegado => write!(f, "permiso denegado"),
		}
	}
}

fn buscar(id: i32) -> Result<String, ErrorApp> {
	if id == 0 {
		Err(ErrorApp::NoEncontrado)
	} else {
		Ok(String::from("dato"))
	}
}
```
{% endraw %}

## Closures avanzados

### Captura por movimiento

{% raw %}
```rust
fn main() {
	let texto = String::from("hola");

	let closure = move || {
		println!("{}", texto);
	};

	closure();
}
```
{% endraw %}

## Iteradores personalizados

### Implementaci√≥n de Iterator

{% raw %}
```rust
struct Contador {
	actual: u32,
	max: u32,
}

impl Iterator for Contador {
	type Item = u32;

	fn next(&mut self) -> Option<Self::Item> {
		if self.actual < self.max {
			self.actual += 1;
			Some(self.actual)
		} else {
			None
		}
	}
}

fn main() {
	let c = Contador { actual: 0, max: 3 };

	for n in c {
		println!("{}", n);
	}
}
```
{% endraw %}

## Concurrencia avanzada

### Canales entre hilos

{% raw %}
```rust
use std::thread;
use std::sync::mpsc;

fn main() {
	let (tx, rx) = mpsc::channel();

	thread::spawn(move || {
		tx.send("mensaje").unwrap();
	});

	println!("{}", rx.recv().unwrap());
}
```
{% endraw %}

### Arc y Mutex

{% raw %}
```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
	let contador = Arc::new(Mutex::new(0));
	let mut handles = vec![];

	for _ in 0..5 {
		let c = Arc::clone(&contador);
		handles.push(thread::spawn(move || {
			let mut num = c.lock().unwrap();
			*num += 1;
		}));
	}

	for h in handles {
		h.join().unwrap();
	}

	println!("contador = {}", *contador.lock().unwrap());
}
```
{% endraw %}

## Async avanzado

### Futures concurrentes con Tokio

{% raw %}
```rust
use tokio::time::{sleep, Duration};

async fn tarea(id: u32) -> u32 {
	sleep(Duration::from_millis(100)).await;
	id
}

#[tokio::main]
async fn main() {
	let (a, b) = tokio::join!(tarea(1), tarea(2));
	println!("{} {}", a, b);
}
```
{% endraw %}

## Macros declarativas

### macro_rules!

{% raw %}
```rust
macro_rules! crear_vec {
	( $( $x:expr ),* ) => {
		{
			let mut v = Vec::new();
			$( v.push($x); )*
			v
		}
	};
}

fn main() {
	let v = crear_vec![1, 2, 3];
	println!("{:?}", v);
}
```
{% endraw %}

## Unsafe avanzado

### FFI m√≠nimo con C

{% raw %}
```rust
extern "C" {
	fn abs(input: i32) -> i32;
}

fn main() {
	unsafe {
		println!("{}", abs(-10));
	}
}
```
{% endraw %}

## no_std (concepto)

### Ejemplo b√°sico sin std

{% raw %}
```rust
#![no_std]

fn suma(a: i32, b: i32) -> i32 {
	a + b
}
```
{% endraw %}

## Optimizaci√≥n y control de rendimiento

### Evitar asignaciones

{% raw %}
```rust
fn sumar(slice: &[i32]) -> i32 {
	slice.iter().sum()
}

fn main() {
	let datos = [1, 2, 3, 4];
	println!("{}", sumar(&datos));
}
```
{% endraw %}

# Rust Cheatsheet (2025-2026)

## Estructura b√°sica

### Programa m√≠nimo
{% raw %}
```rust
fn main() {
	println!("Hello, Rust!");
}
```
{% endraw %}`

## Variables y constantes

### Variables

{% raw %}
```rust
let x = 5;          // inmutable
let mut y = 10;     // mutable
```
{% endraw %}

### Constantes

{% raw %}
```rust
const MAX: i32 = 100;
```
{% endraw %}

## Tipos de datos

### Escalares

{% raw %}
```rust
let a: i32 = 10;
let b: f64 = 3.14;
let c: bool = true;
let d: char = 'R';
```
{% endraw %}

### Compuestos

{% raw %}
```rust
let tupla: (i32, f64) = (1, 2.5);
let array: [i32; 3] = [1, 2, 3];
```
{% endraw %}

## Control de flujo

### Condicional

{% raw %}
```rust
if x > 0 {
	println!("positivo");
} else {
	println!("no positivo");
}
```
{% endraw %}

### Bucles

{% raw %}
```rust
for i in 0..3 {
	println!("{}", i);
}

while x > 0 {
	x -= 1;
}

loop {
	break;
}
```
{% endraw %}

## Funciones

### Definici√≥n

{% raw %}
```rust
fn suma(a: i32, b: i32) -> i32 {
	a + b
}
```
{% endraw %}

## Ownership y referencias

### Movimiento

{% raw %}
```rust
let s1 = String::from("hola");
let s2 = s1;
// s1 ya no es v√°lido
```
{% endraw %}

### Referencias

{% raw %}
```rust
fn len(s: &String) -> usize {
	s.len()
}
```
{% endraw %}

### Referencia mutable

{% raw %}
```rust
fn add(s: &mut String) {
	s.push_str("!");
}
```
{% endraw %}

## Structs

### Definici√≥n

{% raw %}
```rust
struct Usuario {
	nombre: String,
	edad: u8,
}
```
{% endraw %}

### Uso

{% raw %}
```rust
let u = Usuario {
	nombre: String::from("Ana"),
	edad: 30,
};
```
{% endraw %}

## Enums

### Enum simple

{% raw %}
```rust
enum Estado {
	Activo,
	Inactivo,
}
```
{% endraw %}

### Pattern matching

{% raw %}
```rust
match estado {
	Estado::Activo => println!("on"),
	Estado::Inactivo => println!("off"),
}
```
{% endraw %}

## Option y Result

### Option

{% raw %}
```rust
let x: Option<i32> = Some(5);

match x {
	Some(v) => println!("{}", v),
	None => println!("vac√≠o"),
}
```
{% endraw %}

### Result

{% raw %}
```rust
fn dividir(a: i32, b: i32) -> Result<i32, String> {
	if b == 0 {
		Err(String::from("error"))
	} else {
		Ok(a / b)
	}
}
```
{% endraw %}

### Operador ?

{% raw %}
```rust
fn leer() -> Result<i32, std::num::ParseIntError> {
	let n = "10".parse::<i32>()?;
	Ok(n)
}
```
{% endraw %}

## Colecciones

### Vector

{% raw %}
```rust
let mut v = Vec::new();
v.push(1);
```
{% endraw %}

### HashMap

{% raw %}
```rust
use std::collections::HashMap;

let mut m = HashMap::new();
m.insert("a", 1);
```
{% endraw %}

## Traits

### Definici√≥n

{% raw %}
```rust
trait Mostrar {
	fn mostrar(&self);
}
```
{% endraw %}

### Implementaci√≥n

{% raw %}
```rust
impl Mostrar for i32 {
	fn mostrar(&self) {
		println!("{}", self);
	}
}
```
{% endraw %}

## Gen√©ricos

### Funci√≥n gen√©rica

{% raw %}
```rust
fn mostrar<T: std::fmt::Display>(v: T) {
	println!("{}", v);
}
```
{% endraw %}

## Closures

### Closure simple

{% raw %}
```rust
let suma = |a, b| a + b;
```
{% endraw %}

### Move

{% raw %}
```rust
let s = String::from("hola");
let c = move || println!("{}", s);
```
{% endraw %}

## Iteradores

### Uso b√°sico

{% raw %}
```rust
let v = vec![1, 2, 3];
let r: Vec<_> = v.iter().map(|x| x * 2).collect();
```
{% endraw %}

## Smart pointers

### Box

{% raw %}
```rust
let b = Box::new(5);
```
{% endraw %}

### Rc

{% raw %}
```rust
use std::rc::Rc;
let a = Rc::new(1);
let b = Rc::clone(&a);
```
{% endraw %}

### Arc + Mutex

{% raw %}
```rust
use std::sync::{Arc, Mutex};

let c = Arc::new(Mutex::new(0));
```
{% endraw %}

## Concurrencia

### Threads

{% raw %}
```rust
use std::thread;

thread::spawn(|| {
	println!("hilo");
});
```
{% endraw %}

### Canales

{% raw %}
```rust
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();
tx.send(1).unwrap();
let v = rx.recv().unwrap();
```
{% endraw %}

## Async / Await

### Funci√≥n async

{% raw %}
```rust
async fn tarea() -> i32 {
	42
}
```
{% endraw %}

### Executor Tokio

{% raw %}
```rust
#[tokio::main]
async fn main() {
	let v = tarea().await;
	println!("{}", v);
}
```
{% endraw %}

## Testing

### Test unitario

{% raw %}
```rust
#[test]
fn suma_test() {
	assert_eq!(2 + 2, 4);
}
```
{% endraw %}

## Macros

### macro_rules!

{% raw %}
```rust
macro_rules! hola {
	() => {
		println!("hola");
	};
}
```
{% endraw %}

## Unsafe

### Bloque unsafe

{% raw %}
```rust
let mut x = 5;
let p = &mut x as *mut i32;

unsafe {
	*p += 1;
}
```
{% endraw %}

## Cargo

### Comandos comunes

{% raw %}
```bash
cargo new app
cargo build
cargo run
cargo test
cargo check
```
{% endraw %}

## Atributos √∫tiles

### Derive

{% raw %}
```rust
#[derive(Debug, Clone)]
struct Punto {
	x: i32,
	y: i32,
}
```
{% endraw %}

## no_std

### Desactivar std

{% raw %}
```rust
#![no_std]
```
{% endraw %}

# Glosario de Conceptos Rust
$= dv.current().file.tags.join(" ")

## Conceptos b√°sicos del lenguaje
- **Rust**
	- Lenguaje de programaci√≥n de sistemas enfocado en seguridad, rendimiento y concurrencia.
- **Compilaci√≥n**
	- Proceso mediante el cual el c√≥digo Rust se transforma en binario nativo.
- **Binario**
	- Programa ejecutable generado por el compilador.
- **Crate**
	- Unidad b√°sica de compilaci√≥n en Rust; puede ser una librer√≠a o un binario.
- **Package**
	- Conjunto de uno o m√°s crates gestionados por Cargo.

## Tooling y ecosistema
- **Cargo**
	- Gestor de dependencias, compilaci√≥n, testing y benchmarking.
- **rustup**
	- Herramienta para instalar y gestionar versiones de Rust y targets.
- **rustc**
	- Compilador oficial de Rust.
- **rustfmt**
	- Formateador autom√°tico de c√≥digo.
- **clippy**
	- Linter avanzado que detecta errores y malas pr√°cticas.
- **rust-analyzer**
	- Motor de an√°lisis para IDEs con autocompletado y refactorizaci√≥n.

## Sistema de tipos
- **Tipo**
	- Define qu√© valores puede tomar una variable y qu√© operaciones son v√°lidas.
- **Inferencia de tipos**
	- El compilador deduce tipos sin necesidad de anotarlos expl√≠citamente.
- **Tipos escalares**
	- Valores simples como enteros, flotantes, booleanos y caracteres.
- **Tipos compuestos**
	- Tipos formados por otros tipos, como tuplas, arrays y structs.
- **Gen√©ricos**
	- C√≥digo parametrizado por tipos.
- **Bounds**
	- Restricciones sobre tipos gen√©ricos.

## Ownership y memoria
- **Ownership**
	- Regla que define qui√©n es responsable de liberar un valor en memoria.
- **Move**
	- Transferencia de ownership de un valor a otra variable.
- **Borrowing**
	- Pr√©stamo temporal de un valor mediante referencias.
- **Referencia**
	- Acceso a un valor sin tomar su ownership.
- **Referencia mutable**
	- Referencia que permite modificar el valor prestado.
- **Lifetimes**
	- Anotaciones que indican cu√°nto tiempo es v√°lida una referencia.
- **Borrow checker**
	- Sistema del compilador que valida las reglas de ownership y borrowing.

## Estructuras de datos
- **Struct**
	- Tipo que agrupa datos relacionados con nombres de campo.
- **Tuple struct**
	- Struct con campos sin nombre.
- **Enum**
	- Tipo que puede representar m√∫ltiples variantes.
- **Pattern matching**
	- Mecanismo para desestructurar valores y controlar el flujo.
- **Collection**
	- Estructura de datos din√°mica como `Vec`, `HashMap` o `String`.

## Manejo de errores
- **panic!**
	- Finaliza la ejecuci√≥n del programa ante un error irrecuperable.
- **Option**
	- Tipo que representa un valor opcional (`Some` o `None`).
- **Result**
	- Tipo que representa √©xito (`Ok`) o error (`Err`).
- **Operador `?`**
	- Propaga errores de forma concisa.
- **Error personalizado**
	- Tipo definido por el usuario para representar fallos espec√≠ficos.

## Traits e interfaces
- **Trait**
	- Define un conjunto de m√©todos que un tipo puede implementar.
- **Implementaci√≥n (`impl`)**
	- Bloque donde se define el comportamiento de un trait o struct.
- **Trait bound**
	- Restricci√≥n que exige que un tipo implemente un trait.
- **Associated types**
	- Tipos definidos dentro de un trait.
- **Default methods**
	- M√©todos con implementaci√≥n por defecto en un trait.

## Funciones y closures
- **Funci√≥n**
	- Bloque reutilizable de c√≥digo con par√°metros y retorno.
- **Closure**
	- Funci√≥n an√≥nima que puede capturar variables del entorno.
- **Move closure**
	- Closure que toma ownership de los valores capturados.
- **Iterador**
	- Abstracci√≥n para recorrer secuencias de datos.
- **Adapter**
	- M√©todo que transforma un iterador (`map`, `filter`, etc.).

## Concurrencia y paralelismo
- **Thread**
	- Hilo de ejecuci√≥n del sistema operativo.
- **Send**
	- Trait que indica que un tipo puede moverse entre hilos.
- **Sync**
	- Trait que indica que un tipo puede compartirse entre hilos.
- **Mutex**
	- Primitiva de sincronizaci√≥n para acceso exclusivo.
- **Arc**
	- Puntero inteligente para compartir datos entre hilos.
- **Channel**
	- Mecanismo de comunicaci√≥n segura entre hilos.

## Programaci√≥n as√≠ncrona
- **async**
	- Marca una funci√≥n como as√≠ncrona.
- **await**
	- Espera el resultado de una operaci√≥n as√≠ncrona.
- **Future**
	- Representa un valor que estar√° disponible en el futuro.
- **Executor**
	- Componente que ejecuta futures.
- **Runtime**
	- Infraestructura que gestiona tareas as√≠ncronas (por ejemplo Tokio).

## Macros y metaprogramaci√≥n
- **Macro**
	- C√≥digo que genera c√≥digo en tiempo de compilaci√≥n.
- **macro_rules!**
	- Macros declarativas basadas en patrones.
- **Procedural macros**
	- Macros que operan sobre el AST del c√≥digo.
- **Derive macro**
	- Macro que genera implementaciones autom√°ticas.

## Unsafe y bajo nivel
- **unsafe**
	- Bloque que permite operaciones no verificadas por el compilador.
- **Raw pointer**
	- Puntero sin garant√≠as de seguridad.
- **FFI**
	- Interoperabilidad con otros lenguajes como C.
- **Undefined Behavior**
	- Comportamiento no definido que debe evitarse.

## Arquitectura y organizaci√≥n
- **Module**
	- Espacio de nombres para organizar c√≥digo.
- **Visibility (`pub`)**
	- Controla qu√© elementos son accesibles externamente.
- **Workspace**
	- Conjunto de crates relacionados.
- **Feature flag**
	- Compilaci√≥n condicional de funcionalidades.
- **SemVer**
	- Esquema de versionado sem√°ntico.

## Testing y calidad
- **Test unitario**
	- Verifica una funci√≥n o m√≥dulo aislado.
- **Test de integraci√≥n**
	- Prueba el comportamiento p√∫blico del crate.
- **Benchmark**
	- Medici√≥n de rendimiento.
- **Doc test**
	- Ejemplo de documentaci√≥n ejecutable.

## Plataformas y despliegue
- **Target**
	- Plataforma de compilaci√≥n (arquitectura + sistema).
- **Cross-compilation**
	- Compilar para una plataforma distinta a la local.
- **no_std**
	- Uso de Rust sin la librer√≠a est√°ndar.
- **WASM**
	- Compilaci√≥n a WebAssembly.
