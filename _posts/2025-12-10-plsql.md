---
date: 2025-12-10 13:46
title: PLSQL
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: Databases
tags:
  - databases
  - plsql
  - oracle
  - sql
---
# PLSQL

- [oracle](/cloud/oracle/)
- [Databases](/databases/databases/)
- [java](/software%20engineering/java/)

## Documentaci√≥n
- [PL/SQL para desarrolladores | Oracle Espa√±a](https://www.oracle.com/es/database/technologies/appdev/plsql.html)
- PLSQL para desarrolladores  Oracle Espa√±a-plsql.html
- Diferencia entre SQL y PLSQL Cu√°ndo utilizar cada uno-difference-between-sql-and-plsql

## Qu√© es PL/SQL
PL/SQL es el lenguaje procedimental nativo de Oracle, dise√±ado para extender SQL con estructuras de programaci√≥n para crear l√≥gica compleja, procesos transaccionales y manipulaci√≥n de datos eficiente dentro de la base de datos.

## Caracter√≠sticas principales
- **Extensi√≥n de SQL**: a√±ade variables, bucles, condiciones y tipos de datos avanzados.
- **Bloques Anidados**: estructura basada en *DECLARE ‚Üí BEGIN ‚Üí EXCEPTION ‚Üí END*.
- **Alto rendimiento**: ejecuci√≥n cercana al motor, minimiza viajes entre aplicaci√≥n y base.
- **Manejadores de excepciones**: control robusto de errores.
- **Paquetes**: encapsulaci√≥n de l√≥gica en m√≥dulos reutilizables.
- **Triggers**: ejecuci√≥n autom√°tica ligada a eventos de tablas o vistas.
- **Cursores**: control expl√≠cito o impl√≠cito sobre conjuntos de resultados.

## Arquitectura de un bloque PL/SQL
### Ejemplo de estructura
{% raw %}
```plsql
DECLARE
	v_total NUMBER;
BEGIN
	SELECT SUM(salary) INTO v_total FROM employees;
	DBMS_OUTPUT.PUT_LINE('Total: ' || v_total);
EXCEPTION
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/
```
{% endraw %}`

## Tipos de programas PL/SQL

- **Procedures**: l√≥gica que ejecuta acciones.
- **Functions**: devuelven un valor y pueden usarse desde SQL (con restricciones).
- **Packages**: colecciones de funciones/procedimientos organizadas en especificaci√≥n y cuerpo.
- **Triggers**: l√≥gica que responde a INSERT/UPDATE/DELETE o eventos del sistema.
- **Tipos definidos por usuario**: records, colecciones, objetos.

## Cursores

Los cursores permiten procesar filas una a una cuando la l√≥gica lo requiere.

### Cursor expl√≠cito

{% raw %}
```plsql
DECLARE
	CURSOR c_emp IS SELECT first_name, salary FROM employees;
	v_name employees.first_name%TYPE;
	v_salary employees.salary%TYPE;
BEGIN
	FOR rec IN c_emp LOOP
		DBMS_OUTPUT.PUT_LINE(rec.first_name || ' - ' || rec.salary);
	END LOOP;
END;
/
```
{% endraw %}

## Manejo de excepciones

### Ejemplo

{% raw %}
```plsql
BEGIN
	INSERT INTO employees(id, name) VALUES (1, 'John');
EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		DBMS_OUTPUT.PUT_LINE('ID duplicado.');
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('Error no esperado: ' || SQLERRM);
END;
/
```
{% endraw %}

## Ventajas de PL/SQL

- Encapsulaci√≥n de l√≥gica compleja.
- Seguridad: control de acceso granular y privilegios m√≠nimos.
- Reutilizaci√≥n mediante paquetes.
- Reducci√≥n del tr√°fico entre cliente y servidor.
- Integraci√≥n con SQL y tipos del motor de Oracle.

## Cu√°ndo usar SQL y cu√°ndo PL/SQL

- **Usar SQL**:
	- Consultas simples.
	- Agregaciones sin l√≥gica adicional.
	- Manipulaci√≥n directa de datos sin procesos procedurales.
- **Usar PL/SQL**:
	- L√≥gica condicional compleja.
	- Procesos que requieren control de flujo, bucles o cursores.
	- Automatizaci√≥n mediante triggers.
	- APIs internas dentro de la base.

## Buenas pr√°cticas

- Usar `%TYPE` y `%ROWTYPE` para mantener coherencia con la estructura de la base.
- Colocar EXCEPTION solo cuando sea necesario.
- Documentar cada paquete y rutina.
- Evitar cursores expl√≠citos cuando un bucle impl√≠cito es suficiente.
- Minimizar commits dentro del c√≥digo para evitar inconsistencias.
- Agrupar l√≥gica relacionada en paquetes para claridad y mantenimiento.

## Herramientas recomendadas

- **SQL Developer**
- **Oracle APEX**
- **PL/SQL Unit Testing (UTPLSQL)**
- **Oracle LiveSQL (online)**

# PLSQL ‚Äî Conceptos Avanzados y Temas Faltantes

## Optimizaci√≥n y Rendimiento
- **Bulk Operations (FORALL / BULK COLLECT)**: permiten mejorar el rendimiento al procesar grandes vol√∫menes reduciendo *context switches* entre SQL y PL/SQL.
- **Parallel Execution**: algunas operaciones PL/SQL pueden coordinar trabajo paralelo cuando se ejecutan v√≠a SQL, especialmente en ETL.
- **Pipelined Table Functions**: funciones que devuelven datos fila a fila sin esperar al set completo, ideales para integraciones y flujos de datos en streaming.
- **PL/SQL Native Compilation**: compilar paquetes a c√≥digo nativo para aumentar rendimiento en c√°lculos intensivos.

### Bulk Collect
{% raw %}
```plsql
DECLARE
	TYPE t_names IS TABLE OF employees.first_name%TYPE;
	l_names t_names;
BEGIN
	SELECT first_name BULK COLLECT INTO l_names FROM employees;
	FOR i IN 1 .. l_names.COUNT LOOP
		DBMS_OUTPUT.PUT_LINE(l_names(i));
	END LOOP;
END;
/
```
{% endraw %}`

## Dise√±o Profesional de Paquetes

Los paquetes pueden estructurarse como mini-m√≥dulos de software:

- **Especificaci√≥n m√≠nima**: solo lo que debe ser p√∫blico.
- **Cuerpo encapsulado**: implementar l√≥gica privada, sub-funciones, constantes internas.
- **Variables de estado**: cuidado con estado persistente entre sesiones, usar solo cuando sea estrictamente necesario.
- **Instrumentaci√≥n integrada**: `DBMS_APPLICATION_INFO` para trazabilidad.

### Plantilla recomendada

{% raw %}
```plsql
CREATE OR REPLACE PACKAGE customer_api IS
	PROCEDURE create_customer(p_name VARCHAR2, p_email VARCHAR2);
	FUNCTION get_customer(p_id NUMBER) RETURN customer_obj;
END customer_api;
/
```
{% endraw %}

{% raw %}
```plsql
CREATE OR REPLACE PACKAGE BODY customer_api IS
	PROCEDURE create_customer(p_name VARCHAR2, p_email VARCHAR2) IS
	BEGIN
		INSERT INTO customers(name, email) VALUES (p_name, p_email);
	END;

	FUNCTION get_customer(p_id NUMBER) RETURN customer_obj IS
		l_result customer_obj;
	BEGIN
		SELECT customer_obj(id, name, email)
		INTO l_result
		FROM customers
		WHERE id = p_id;

		RETURN l_result;
	END;
END customer_api;
/
```
{% endraw %}

## Seguridad en PL/SQL

- **Definer Rights vs Invoker Rights**:
	- *Definer Rights*: el c√≥digo usa los permisos del autor.
	- *Invoker Rights*: ejecuta con permisos del usuario que lo llama.
- **Wrappers y ofuscaci√≥n**: proteger l√≥gica sensible.
- **Privilege Minimization**: evitar otorgar m√°s permisos que los necesarios.
- **Roles en PL/SQL**: recordatorio crucial: *los roles no est√°n activos dentro del c√≥digo*, siempre usar privilegios directos.

### Ejemplo de Invoker Rights

{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE report_data AUTHID CURRENT_USER IS
BEGIN
	-- ejecuta con permisos del usuario que llama
	NULL;
END;
/
```
{% endraw %}

## Tipos Avanzados

- **Colecciones anidadas**
- **VARRAY**
- **Objetos y m√©todos**
- **Table Functions con objetos**
- **Tipos para integraci√≥n: JSON_OBJECT_T, JSON_ARRAY_T**

### JSON nativo en PL/SQL

{% raw %}
```plsql
DECLARE
	j JSON_OBJECT_T := JSON_OBJECT_T('{"name":"John","age":30}');
BEGIN
	DBMS_OUTPUT.PUT_LINE(j.get_String('name'));
END;
/
```
{% endraw %}

## Patrones de Dise√±o Recomendados

- **API por paquetes**: separar lectura/escritura, validaciones y utilidades en m√≥dulos claros.
- **Dominio + Validaci√≥n**: crear funciones de validaci√≥n reutilizables antes de cada INSERT/UPDATE.
- **Control de Transacciones**: centralizar commits/rollbacks en niveles superiores.
- **Excepciones personalizadas**: crear un paquete `errors_pkg` para estandarizar errores.

### Excepci√≥n personalizadas

{% raw %}
```plsql
DECLARE
	e_invalid_status EXCEPTION;
	PRAGMA EXCEPTION_INIT(e_invalid_status, -20010);
BEGIN
	RAISE e_invalid_status;
END;
/
```
{% endraw %}

## Testing Profesional en PL/SQL

- **UTPLSQL** (framework est√°ndar)
- **Test de procedimientos**
- **Mock de tablas mediante entornos temporales**
- **Pruebas determin√≠sticas con fixtures**

### Ejemplo UTPLSQL

{% raw %}
```plsql
BEGIN
	ut.expect(customer_api.get_customer(1).name).to_equal('John');
END;
/
```
{% endraw %}

## Integraciones Modernas

- **PL/SQL + REST (Oracle REST Data Services ‚Äî ORDS)**:
	- Exponer procedimientos como endpoints REST.
	- Controlar JSON IN/OUT con `APEX_JSON` o tipos nativos.
- **Eventos y colas (AQ / Advanced Queuing)**:
	- Integraci√≥n as√≠ncrona entre sistemas.
- **Programaci√≥n con DBMS_SCHEDULER**:
	- Crear jobs autom√°ticos avanzados, dependencias y flujos.

### Job programado

{% raw %}
```plsql
BEGIN
	DBMS_SCHEDULER.create_job(
		job_name => 'daily_customer_sync',
		job_type => 'PLSQL_BLOCK',
		job_action => 'BEGIN sync_customers; END;',
		repeat_interval => 'FREQ=DAILY;BYHOUR=3;',
		enabled => TRUE
	);
END;
/
```
{% endraw %}

## Depuraci√≥n e Instrumentaci√≥n

- **DBMS_OUTPUT**: b√°sico, evitar en producci√≥n.
- **DBMS_DEBUG**: depuraci√≥n paso a paso.
- **DBMS_PROFILER / PL/SQL Hierarchical Profiler**: medir rendimiento real.
- **Logs estructurados**: registrar par√°metros, errores y tiempos.

## Errores Comunes a Evitar

- Declarar cursores cuando un bucle impl√≠cito ser√≠a suficiente.
- Realizar commit dentro de procedimientos internos.
- Exponer l√≥gica interna en especificaciones de paquetes.
- Excepciones gen√©ricas sin diagn√≥stico.
- No usar `%TYPE` / `%ROWTYPE`.

## Conceptos Avanzados a Vigilar

- Gesti√≥n de memoria interna de colecciones.
- Diferencias entre SQL Engine y PL/SQL Engine.
- Context Switching (*CPU killer* si no se controla).
- PL/SQL en entornos multitenant (CDB/PDB).

# PLSQL ‚Äî Nota actualizada a 2025 con recursos recientes

## Qu√© es PL/SQL y por qu√© sigue vigente  
PL/SQL es la extensi√≥n procedimental de SQL para Oracle Database, dise√±ada para permitir l√≥gica compleja, modular y eficiente directamente en la base de datos. Combina la potencia de manipulaci√≥n de datos de SQL con las capacidades de un lenguaje de programaci√≥n: variables, estructuras de control, excepciones, subprogramas, etc.  
Gracias a su integraci√≥n nativa con el motor de Oracle, PL/SQL mantiene ventajas clave hoy en d√≠a: alto rendimiento, portabilidad, escalabilidad, reutilizaci√≥n de c√≥digo, facilidad para mantenimientos centrales y seguridad.

## Novedades, pr√°cticas actuales y optimizaci√≥n (2025)  
### Buenas pr√°cticas y optimizaci√≥n recomendadas  
- Evita operaciones una-fila-a-una: usa operaciones bulk (`BULK COLLECT / FORALL`) para procesar lotes de datos, reduciendo los context switches entre SQL y PL/SQL y aumentando el rendimiento.  
- Utiliza correctamente los tipos de datos: evita conversiones impl√≠citas de tipo, dimensiona `VARCHAR2` adecuadamente para evitar desperdicio de memoria.  
- Prefiere utilidades internas de Oracle antes de reinventar l√≥gica del sistema.  
- Usa herramientas de perfilado como `DBMS_PROFILER` para detectar cuellos de botella.  
- Dise√±a paquetes con interfaz p√∫blica m√≠nima y l√≥gica privada clara.

## Temas y capacidades modernas dentro del ecosistema Oracle (2025)  
- Soporte completo para tipos SQL (VARCHAR2, DATE, LOB‚Ä¶), variables con `%TYPE/%ROWTYPE`.  
- Uso de SQL est√°tico y din√°mico para mayor flexibilidad.  
- Estructuras modulares: procedimientos, funciones, paquetes, triggers.  
- Manejo de excepciones avanzado y homog√©neo en toda la aplicaci√≥n.

## Recursos recomendados (2024-2025)  
- **PL/SQL para desarrolladores | Oracle Espa√±a** ‚Äî gu√≠a base del lenguaje, contexto, ventajas y recursos de inicio.  
- **Database PL/SQL Language Reference (2025)** ‚Äî documentaci√≥n oficial completa y actualizada del lenguaje.  
- **PL/SQL Best Practices** ‚Äî pr√°cticas modernas de optimizaci√≥n, rendimiento y estilo.  
- **Curso fundamentos PL/SQL (OpenWebinars)** ‚Äî formaci√≥n introductoria en espa√±ol.  
- **Libro Oracle PL/SQL (C√©sar P√©rez L√≥pez, Ra-Ma)** ‚Äî base te√≥rica recomendable para dominar fundamentos.

## Estado actual del uso de PL/SQL en 2025  
Aunque la publicaci√≥n de nuevos libros se ha ralentizado, la documentaci√≥n oficial de Oracle contin√∫a actualiz√°ndose regularmente, manteniendo PL/SQL como una pieza central en entornos empresariales con Oracle Database.  
En comunidades t√©cnicas se observa que la demanda laboral especializada exclusivamente en PL/SQL ha disminuido, pero crece su valor combinado con otras tecnolog√≠as (frontend, backend generalista, cloud, ORDS, APEX).  
Sigue siendo altamente √∫til en proyectos con l√≥gica compleja, integraciones internas y sistemas cr√≠ticos, especialmente en el sector bancario, seguros, fintech y organismos p√∫blicos.

## Conclusi√≥n  
PL/SQL contin√∫a siendo en 2025 un lenguaje potente, seguro, escalable y profundamente integrado con Oracle Database. Para aprovechar su m√°ximo potencial es necesario aplicar buenas pr√°cticas modernas: operaciones bulk, dise√±o modular, uso de paquetes, profiling y control cuidadoso de transacciones.  
Este stack sigue siendo relevante en entornos corporativos y cr√≠ticos, aunque combinado cada vez m√°s con tecnolog√≠as externas.

---

## Enlaces utilizados

- https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/overview.html  
- https://docs.oracle.com/en/database/oracle/oracle-database/19/lnpls/database-pl-sql-language-reference.pdf  
- https://docs.oracle.com/en/industries/retail/retail-analytics-planning/24.1.201.0/rapig/pl-sql-best-practice.htm  
- https://www.oracle.com/es/database/technologies/appdev/plsql.html  
- https://openwebinars.net/cursos/fundamentos-pl-sql  
- https://www.ra-ma.es/libro/oracle-pl-sql_141216  
- https://www.reddit.com/r/oracle/comments/1idmlbg  

# Glosario PL/SQL (Listado)

## Fundamentos del Lenguaje
- PL/SQL: Extensi√≥n procedural de SQL integrada en Oracle.
- Bloque PL/SQL: Estructura con `DECLARE`, `BEGIN`, `EXCEPTION`, `END`.
- Bloque an√≥nimo: No almacenado, ejecuci√≥n directa.
- Bloque nombrado: Procedimientos, funciones o paquetes almacenados.
- Declaraci√≥n de variables.
- Tipos escalares: `NUMBER`, `VARCHAR2`, `DATE`, `BOOLEAN`.
- Tipos anclados: `%TYPE`, `%ROWTYPE`.
- Constantes: Uso de `CONSTANT`.
- Estructuras de control: `IF`, `CASE`, `FOR`, `WHILE`, `LOOP`.

## Estructuras de Programaci√≥n
- Procedimientos:
	- Par√°metros `IN`, `OUT`, `IN OUT`.
	- Sobrecarga (overload).
- Funciones:
	- Devuelven valor.
	- Usables en SQL si son deterministas o seguras.
- Packages:
	- Specification (interfaz p√∫blica).
	- Body (implementaci√≥n privada).
	- Variables de paquete persistentes.

## SQL en PL/SQL
- `SELECT INTO`: Asignaci√≥n de resultados.
- DML directo: `INSERT`, `UPDATE`, `DELETE`.
- `RETURNING INTO`: Obtener valores tras un DML.
- Cursores:
	- Impl√≠citos.
	- Expl√≠citos: `OPEN / FETCH / CLOSE`.
	- `FOR cursor IN ... LOOP`.
	- Cursores con par√°metros.
- Bulk processing:
	- `BULK COLLECT`.
	- `FORALL`.
	- `SAVE EXCEPTIONS`.

## Manejo de Excepciones
- Excepciones predefinidas: `NO_DATA_FOUND`, `TOO_MANY_ROWS`, `DUP_VAL_ON_INDEX`.
- Excepciones definidas por el usuario.
- `RAISE` y `RAISE_APPLICATION_ERROR`.
- `SQLCODE` y `SQLERRM`.

## Tipos Avanzados
- Registros:
	- `%ROWTYPE`.
	- `TYPE ... IS RECORD`.
- Colecciones:
	- Associative Arrays (`INDEX BY`).
	- Nested Tables.
	- VARRAYs.

## Rendimiento
- Bulk operations para evitar row-by-row.
- Reducci√≥n de context switching SQL ‚Üî PL/SQL.
- Caching con variables de paquete.
- Minimizar queries dentro de loops.
- Bind variables en SQL din√°mico.
- Uso de `DBMS_PROFILER` y `DBMS_HPROF`.

## Seguridad y Acceso
- Definer‚Äôs Rights (por defecto).
- Invoker‚Äôs Rights (`AUTHID CURRENT_USER`).
- SQL Injection en SQL din√°mico.
- Mitigaci√≥n mediante par√°metros bind.

## SQL Din√°mico
- `EXECUTE IMMEDIATE`:
	- `USING` para bind variables.
	- `INTO` para resultados.
	- `RETURNING INTO` para DML.
- Paquete `DBMS_SQL`:
	- Ejecuci√≥n de SQL din√°mico complejo.
	- Compatibilidad con columnas variables.

## Paquetes del Sistema
- `DBMS_OUTPUT`: Mostrar texto.
- `DBMS_RANDOM`: Valores aleatorios.
- `DBMS_SCHEDULER`: Jobs programados.
- `DBMS_UTILITY`: Utilidades varias.
- `DBMS_LOCK`: Locks a nivel PL/SQL.
- `UTL_FILE`: Acceso a ficheros.
- `UTL_HTTP`: Llamadas HTTP.

## Transacciones
- `COMMIT` y `ROLLBACK`.
- `SAVEPOINT`.
- Transacciones aut√≥nomas:
	- `PRAGMA AUTONOMOUS_TRANSACTION`.

## Herramientas Habituales
- SQL*Plus.
- SQL Developer.
- SQLcl.
- Oracle APEX.
- Oracle REST Data Services (ORDS).

# PL/SQL ‚Äî Ejemplos de C√≥digo Explicados (2025)

## Bloques PL/SQL

### Bloque An√≥nimo
{% raw %}
```plsql
DECLARE
	v_msg VARCHAR2(50) := 'Hola desde PL/SQL';
BEGIN
	DBMS_OUTPUT.PUT_LINE(v_msg);
END;
/
```
{% endraw %}`

**Explicaci√≥n:**  
Un bloque an√≥nimo no se almacena en la base de datos; se ejecuta directamente. Es ideal para pruebas r√°pidas, scripts o l√≥gica temporal.

---

## Variables y Tipos

### Uso de %TYPE

{% raw %}
```plsql
DECLARE
	v_emp_name employees.last_name%TYPE;
BEGIN
	SELECT last_name INTO v_emp_name
	FROM employees
	WHERE employee_id = 100;

	DBMS_OUTPUT.PUT_LINE(v_emp_name);
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
`%TYPE` hereda el tipo de columna, garantizando consistencia incluso si la estructura de la tabla cambia.

### Uso de %ROWTYPE

{% raw %}
```plsql
DECLARE
	v_emp_record employees%ROWTYPE;
BEGIN
	SELECT * INTO v_emp_record
	FROM employees
	WHERE employee_id = 100;

	DBMS_OUTPUT.PUT_LINE(v_emp_record.last_name);
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
`%ROWTYPE` crea un registro con todas las columnas de la tabla o vista, √∫til para consultas completas.

---

## Estructuras de Control

### IF / ELSIF / ELSE

{% raw %}
```plsql
DECLARE
	v_num NUMBER := 7;
BEGIN
	IF v_num > 10 THEN
		DBMS_OUTPUT.PUT_LINE('Mayor que 10');
	ELSIF v_num = 10 THEN
		DBMS_OUTPUT.PUT_LINE('Igual a 10');
	ELSE
		DBMS_OUTPUT.PUT_LINE('Menor que 10');
	END IF;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Permite evaluar condiciones m√∫ltiples y tomar decisiones l√≥gico-procedimentales.

### FOR Loop

{% raw %}
```plsql
BEGIN
	FOR i IN 1..5 LOOP
		DBMS_OUTPUT.PUT_LINE('Iteraci√≥n: ' || i);
	END LOOP;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
El `FOR` define autom√°ticamente el contador y sus l√≠mites.

---

## Procedimientos

### Procedimiento con Par√°metros IN y OUT

{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE get_salary (
	p_emp_id IN employees.employee_id%TYPE,
	p_salary OUT employees.salary%TYPE
) AS
BEGIN
	SELECT salary INTO p_salary
	FROM employees
	WHERE employee_id = p_emp_id;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
El par√°metro `OUT` devuelve datos al llamador, permitiendo que el procedimiento act√∫e como una operaci√≥n que modifica el estado externo.

---

## Funciones

### Funci√≥n Determinista

{% raw %}
```plsql
CREATE OR REPLACE FUNCTION yearly_salary (
	p_monthly NUMBER
) RETURN NUMBER DETERMINISTIC AS
BEGIN
	RETURN p_monthly * 12;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
`DETERMINISTIC` indica que la funci√≥n devolver√° siempre el mismo resultado con la misma entrada, permitiendo optimizaciones internas.

---

## Packages

### Package Specification y Body

{% raw %}
```plsql
CREATE OR REPLACE PACKAGE math_pkg AS
	FUNCTION square(p_num NUMBER) RETURN NUMBER;
END math_pkg;
/

CREATE OR REPLACE PACKAGE BODY math_pkg AS
	FUNCTION square(p_num NUMBER) RETURN NUMBER IS
	BEGIN
		RETURN p_num * p_num;
	END;
END math_pkg;
/
```
{% endraw %}

**Explicaci√≥n:**  
Los paquetes separan la interfaz (spec) de la implementaci√≥n (body), facilitando el mantenimiento y ocultando detalles.

---

## Cursores

### Cursor Expl√≠cito

{% raw %}
```plsql
DECLARE
	CURSOR c_emps IS
		SELECT employee_id, last_name FROM employees;
	v_id employees.employee_id%TYPE;
	v_name employees.last_name%TYPE;
BEGIN
	OPEN c_emps;
	LOOP
		FETCH c_emps INTO v_id, v_name;
		EXIT WHEN c_emps%NOTFOUND;
		DBMS_OUTPUT.PUT_LINE(v_id || ' - ' || v_name);
	END LOOP;
	CLOSE c_emps;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Permite recorrer fila a fila el resultado de una consulta, ideal cuando se necesita procesar datos individualmente.

### Cursor FOR Loop

{% raw %}
```plsql
BEGIN
	FOR rec IN (SELECT employee_id, last_name FROM employees) LOOP
		DBMS_OUTPUT.PUT_LINE(rec.employee_id || ': ' || rec.last_name);
	END LOOP;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Simplifica la sintaxis: Oracle maneja `OPEN`, `FETCH` y `CLOSE` autom√°ticamente.

---

## Bulk Processing

### BULK COLLECT

{% raw %}
```plsql
DECLARE
	TYPE t_names IS TABLE OF employees.last_name%TYPE;
	v_names t_names;
BEGIN
	SELECT last_name BULK COLLECT INTO v_names
	FROM employees;

	DBMS_OUTPUT.PUT_LINE('Total: ' || v_names.COUNT);
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Permite obtener muchas filas a la vez, eliminando m√∫ltiples cambios de contexto SQL‚ÜîPLSQL y acelerando procesos masivos.

### FORALL

{% raw %}
```plsql
DECLARE
	TYPE t_ids IS TABLE OF NUMBER;
	v_ids t_ids := t_ids(1, 2, 3, 4, 5);
BEGIN
	FORALL i IN v_ids.FIRST .. v_ids.LAST
		UPDATE employees
		SET salary = salary * 1.05
		WHERE employee_id = v_ids(i);
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Ejecuta DML masivo en lotes, mucho m√°s r√°pido que ejecutar `UPDATE` dentro de un loop.

---

## Excepciones

### Manejo de Excepciones

{% raw %}
```plsql
DECLARE
	v_sal NUMBER;
BEGIN
	SELECT salary INTO v_sal
	FROM employees
	WHERE employee_id = 9999; -- No existe

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		DBMS_OUTPUT.PUT_LINE('Empleado no encontrado.');
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
`EXCEPTION` intercepta errores y permite un manejo controlado.

---

## SQL Din√°mico

### EXECUTE IMMEDIATE B√°sico

{% raw %}
```plsql
DECLARE
	v_sql VARCHAR2(200) := 'UPDATE employees SET salary = salary * 1.10 WHERE employee_id = :id';
BEGIN
	EXECUTE IMMEDIATE v_sql USING 100;
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
SQL din√°mico permite construir y ejecutar sentencias en tiempo de ejecuci√≥n, con soporte para bind variables.

### EXECUTE IMMEDIATE con INTO

{% raw %}
```plsql
DECLARE
	v_count NUMBER;
BEGIN
	EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM employees' INTO v_count;
	DBMS_OUTPUT.PUT_LINE('Total: ' || v_count);
END;
/
```
{% endraw %}

---

## Transacciones

### Uso de SAVEPOINT y ROLLBACK

{% raw %}
```plsql
BEGIN
	UPDATE employees SET salary = salary + 100 WHERE employee_id = 101;
	SAVEPOINT sp1;

	UPDATE employees SET salary = salary + 100 WHERE employee_id = 9999; -- error

	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK TO sp1;
		DBMS_OUTPUT.PUT_LINE('Se revierte al savepoint.');
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Los savepoints permiten revertir parcialmente una transacci√≥n sin perder operaciones anteriores.

---

## Transacciones Aut√≥nomas

### PRAGMA AUTONOMOUS_TRANSACTION

{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE log_event(p_msg VARCHAR2) AS
	PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	INSERT INTO event_log(message, created_at)
	VALUES (p_msg, SYSDATE);

	COMMIT; -- independiente de la transacci√≥n principal
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Este procedimiento hace commit por s√≠ mismo sin afectar la l√≥gica externa.

---

## Paquetes del Sistema

### DBMS_OUTPUT

{% raw %}
```plsql
BEGIN
	DBMS_OUTPUT.PUT_LINE('Mostrando un mensaje');
END;
/
```
{% endraw %}

### DBMS_RANDOM

{% raw %}
```plsql
DECLARE
	v_num NUMBER;
BEGIN
	v_num := DBMS_RANDOM.VALUE(1, 100);
	DBMS_OUTPUT.PUT_LINE('N√∫mero aleatorio: ' || v_num);
END;
/
```
{% endraw %}

### UTL_HTTP ‚Äî Petici√≥n HTTP

{% raw %}
```plsql
DECLARE
	v_resp CLOB;
BEGIN
	v_resp := UTL_HTTP.REQUEST('https://example.com');
	DBMS_OUTPUT.PUT_LINE(v_resp);
END;
/
```
{% endraw %}

**Explicaci√≥n:**  
Permite acceder a servicios web desde PL/SQL (requiere ACL configurado).

---

# PL/SQL ‚Äî Casos Reales de Empresa (Ejemplos Extensos y Explicados)

## Caso 1: C√°lculo de Comisiones Mensuales (Sector Ventas / Retail)
### Descripci√≥n  
Una empresa de retail necesita calcular comisiones mensuales basadas en el total vendido por cada empleado. El sistema debe:
	- Detectar ventas del mes.
	- Aplicar reglas diferentes seg√∫n categor√≠a del vendedor.
	- Registrar el c√°lculo en una tabla hist√≥rica.
	- Ser ejecutado autom√°ticamente cada inicio de mes.

### Ejemplo de C√≥digo
{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE calc_comisiones IS
	CURSOR c_vendedores IS
		SELECT v.vendedor_id,
		       v.categoria,
		       SUM(s.monto) total_mes
		FROM ventas s
		JOIN vendedores v ON v.vendedor_id = s.vendedor_id
		WHERE s.fecha BETWEEN ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -1)
		                   AND TRUNC(SYSDATE, 'MM') - 1
		GROUP BY v.vendedor_id, v.categoria;

	v_comision NUMBER;
BEGIN
	FOR rec IN c_vendedores LOOP
		-- Reglas por categor√≠a
		IF rec.categoria = 'A' THEN
			v_comision := rec.total_mes * 0.12;
		ELSIF rec.categoria = 'B' THEN
			v_comision := rec.total_mes * 0.08;
		ELSE
			v_comision := rec.total_mes * 0.05;
		END IF;

		INSERT INTO historial_comisiones(vendedor_id, total_mes, comision, fecha_calculo)
		VALUES (rec.vendedor_id, rec.total_mes, v_comision, SYSDATE);
	END LOOP;

	COMMIT;
END;
/
```
{% endraw %}`

### Explicaci√≥n

Este procedimiento reemplaza informes manuales. Puede ejecutarse mediante `DBMS_SCHEDULER` mensualmente, evitando c√°lculos externos (Excel, scripts Python) y garantizando consistencia.

---

## Caso 2: Auditor√≠a Autom√°tica de Cambios (Sector Bancario)

### Descripci√≥n

Regulaciones financieras obligan a auditar cada modificaci√≥n de ciertas tablas (clientes, cuentas, transacciones). La auditor√≠a debe incluir:  
- Usuario que realiz√≥ el cambio.  
- Timestamp.  
- Valores antes y despu√©s.

### Ejemplo de Trigger de Auditor√≠a

{% raw %}
```plsql
CREATE OR REPLACE TRIGGER audit_cuentas_trg
AFTER UPDATE ON cuentas
FOR EACH ROW
BEGIN
	INSERT INTO auditoria_cuentas(
		cuenta_id,
		usuario,
		fecha_cambio,
		saldo_anterior,
		saldo_nuevo
	)
	VALUES(
		:OLD.cuenta_id,
		SYS_CONTEXT('USERENV','SESSION_USER'),
		SYSTIMESTAMP,
		:OLD.saldo,
		:NEW.saldo
	);
END;
/
```
{% endraw %}

### Explicaci√≥n

Este patr√≥n es muy com√∫n en banca, donde trazabilidad = cumplimiento normativo. PL/SQL es ideal, pues la auditor√≠a reside dentro del motor y no depende de aplicaciones externas.

---

## Caso 3: Env√≠o de Notificaciones a Clientes (Sector Seguros / Telecom)

### Descripci√≥n

Una compa√±√≠a quiere avisar a clientes cuyo contrato expira en los pr√≥ximos 30 d√≠as. Las notificaciones deben enviarse mediante ORDS o un API REST.

### Ejemplo con `UTL_HTTP`

{% raw %}
```plsql
DECLARE
	CURSOR c_clientes IS
		SELECT cliente_id, email
		FROM contratos
		WHERE fecha_fin BETWEEN SYSDATE AND SYSDATE + 30;

	v_payload VARCHAR2(4000);
	v_response CLOB;
BEGIN
	FOR rec IN c_clientes LOOP
		v_payload := '{"email": "' || rec.email || '", "mensaje": "Su contrato est√° pr√≥ximo a expirar."}';

		v_response := UTL_HTTP.REQUEST(
			url => 'https://api.miempresa.com/notificaciones',
			method => 'POST',
			body => v_payload
		);

		INSERT INTO log_notificaciones(cliente_id, fecha_envio, respuesta)
		VALUES (rec.cliente_id, SYSDATE, v_response);
	END LOOP;

	COMMIT;
END;
/
```
{% endraw %}

### Explicaci√≥n

Ideal para integraciones sin intermediarios. Requiere ACL, pero evita tener que sacar datos fuera de la BD para enviarlos desde un servicio externo.

---

## Caso 4: Procesamiento Masivo de Datos (Sector Log√≠stica)

### Descripci√≥n

Una empresa log√≠stica recibe a diario millones de registros de escaneos de paquetes (IoT). Necesita:  
- Procesar en lotes (bulk collect).  
- Consolidar datos y actualizar estados.  
- Mantener rendimiento alto.

### Ejemplo con BULK COLLECT + FORALL

{% raw %}
```plsql
DECLARE
	TYPE t_escaneos IS TABLE OF escaneos%ROWTYPE;
	v_lote t_escaneos;

BEGIN
	SELECT * 
	BULK COLLECT INTO v_lote
	FROM escaneos
	WHERE procesado = 'N'
	FETCH FIRST 50000 ROWS ONLY;

	FORALL i IN v_lote.FIRST .. v_lote.LAST
		UPDATE paquetes
		SET ultima_localizacion = v_lote(i).ubicacion,
		    fecha_ultima = v_lote(i).fecha
		WHERE paquete_id = v_lote(i).paquete_id;

	FORALL i IN v_lote.FIRST .. v_lote.LAST
		UPDATE escaneos SET procesado = 'S'
		WHERE id = v_lote(i).id;

	COMMIT;
END;
/
```
{% endraw %}

### Explicaci√≥n

Procesar fila por fila ser√≠a inviable. Bulk operations permiten procesar cientos de miles de registros en segundos.

---

## Caso 5: Generaci√≥n de Informes Diarios (Sector Financiero)

### Descripci√≥n

Se generan PDFs o CSV con movimientos, saldos y operaciones. La generaci√≥n se hace dentro de la BD para evitar transferencias.

### Ejemplo: Generaci√≥n de CSV con `UTL_FILE`

{% raw %}
```plsql
DECLARE
	fh UTL_FILE.FILE_TYPE;
BEGIN
	fh := UTL_FILE.FOPEN('DIR_REPORTES', 'movimientos.csv', 'W');

	FOR rec IN (SELECT cuenta_id, monto, fecha FROM movimientos WHERE fecha >= TRUNC(SYSDATE)) LOOP
		UTL_FILE.PUT_LINE(fh, rec.cuenta_id || ';' || rec.monto || ';' || rec.fecha);
	END LOOP;

	UTL_FILE.FCLOSE(fh);
END;
/
```
{% endraw %}

### Explicaci√≥n

Usado en ambientes core, donde los informes diarios deben generarse r√°pido y con datos consistentes.

---

## Caso 6: Limpieza y Archivado Autom√°tico (Sector Administraci√≥n P√∫blica)

### Descripci√≥n

El sistema debe archivar registros antiguos en una tabla hist√≥rica, eliminar registros muy antiguos y mantener √≠ndices limpios.

### Ejemplo

{% raw %}
```plsql
BEGIN
	INSERT INTO historico_tramites
	SELECT * FROM tramites
	WHERE fecha < ADD_MONTHS(SYSDATE, -24);

	DELETE FROM tramites
	WHERE fecha < ADD_MONTHS(SYSDATE, -24);

	COMMIT;
END;
/
```
{% endraw %}

### Explicaci√≥n

Permite mantener el rendimiento de tablas cr√≠ticas y cumplir pol√≠ticas de conservaci√≥n de datos.

---

## Caso 7: Validaci√≥n Compleja de Datos (Sector Salud)

### Descripci√≥n

Antes de registrar un acto cl√≠nico, deben validarse m√∫ltiples reglas:  
- Formatos.  
- Rango de valores.  
- Existencia de datos obligatorios.  
- Reglas de negocio espec√≠ficas del centro.

### Ejemplo

{% raw %}
```plsql
CREATE OR REPLACE FUNCTION validar_datos (
	p_paciente_id NUMBER,
	p_codigo_acto VARCHAR2,
	p_monto NUMBER
) RETURN VARCHAR2 AS
BEGIN
	IF p_monto < 0 THEN
		RETURN 'Monto inv√°lido';
	END IF;

	IF NOT EXISTS (SELECT 1 FROM pacientes WHERE paciente_id = p_paciente_id) THEN
		RETURN 'Paciente inexistente';
	END IF;

	IF p_codigo_acto NOT IN ('C01','C02','C03') THEN
		RETURN 'Acto no permitido';
	END IF;

	RETURN 'OK';
END;
/
```
{% endraw %}

### Explicaci√≥n

Permite centralizar reglas complejas en la base de datos, evitando inconsistencias entre m√∫ltiples aplicaciones.

---

## Caso 8: Sincronizaci√≥n de Sistemas (Sector Multinacional / ERP)

### Descripci√≥n

Un ERP debe sincronizar datos con un sistema externo cada noche:  
- Extraer datos modificados.  
- Convertirlos a JSON.  
- Enviar a un API.

### Ejemplo

{% raw %}
```plsql
DECLARE
	v_json CLOB;
BEGIN
	FOR rec IN (SELECT * FROM productos WHERE fecha_mod > SYSDATE - 1) LOOP
		v_json := '{"id": ' || rec.id || ', "name": "' || rec.nombre || '"}';

		-- Llamada HTTP simulada
		UTL_HTTP.REQUEST('https://externo/api/sync', 'POST', v_json);
	END LOOP;

	INSERT INTO log_sync(fecha, registros)
	VALUES (SYSDATE, SQL%ROWCOUNT);

	COMMIT;
END;
/
```
{% endraw %}

### Explicaci√≥n

Evita tener procesos ETL externos para sincronizaciones peque√±as y frecuentes.

---

## Caso 9: Control de Inventario en Tiempo Real (Sector Industrial)

### Descripci√≥n

Sensores notifican cambios de stock. La BD debe actualizar inventario y detectar alertas.

### Ejemplo

{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE actualizar_stock (
	p_item_id NUMBER,
	p_cantidad NUMBER
) AS
BEGIN
	UPDATE inventario
	SET stock = stock + p_cantidad
	WHERE item_id = p_item_id;

	IF (SELECT stock FROM inventario WHERE item_id = p_item_id) < 10 THEN
		INSERT INTO alertas(item_id, fecha, mensaje)
		VALUES(p_item_id, SYSDATE, 'Stock bajo');
	END IF;

	COMMIT;
END;
/
```
{% endraw %}

### Explicaci√≥n

Procesos de stock cr√≠ticos requieren que la l√≥gica est√© en el motor para ser inmediata.

---

## Caso 10: Logs de Aplicaci√≥n Centralizados (Cualquier Sector)

### Descripci√≥n

Se quiere que todas las aplicaciones escriban logs en una tabla √∫nica con transacciones aut√≥nomas.

### Ejemplo

{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE app_log(p_msg VARCHAR2) AS
	PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	INSERT INTO app_logs(mensaje, fecha)
	VALUES(p_msg, SYSTIMESTAMP);
	COMMIT;
END;
/
```
{% endraw %}

### Explicaci√≥n

Permite que los logs no dependan del flujo normal ni de commits externos.

---

Si quieres, puedo generar **otra versi√≥n con casos extremadamente avanzados**, como:

- modelado de particiones + PL/SQL,
- flujos distribuidos,
- PL/SQL como motor de reglas,
- automatizaci√≥n con ORDS + PL/SQL,
- pipelines de datos internos.

# Casos Extremadamente Avanzados en PL/SQL (2025)

## 1. **Procesamiento Masivo con Pipelines, Paralelismo y Bulk Ops**
### Caso: ETL interno de millones de registros con m√≠nima carga en buffer cache

**Explicaci√≥n:**  
En entornos de data warehousing, PL/SQL permite crear *table functions* pipelined combinadas con paralelismo para transformar conjuntos enormes sin materializar tablas intermedias.

### Ejemplo ‚Äî Pipeline + Bulk + Transformaci√≥n Compleja
{% raw %}
```plsql
CREATE OR REPLACE TYPE t_etl_row AS OBJECT (
	id NUMBER,
	valor NUMBER,
	etiqueta VARCHAR2(50)
);
/

CREATE OR REPLACE TYPE t_etl_tab IS TABLE OF t_etl_row;
/

CREATE OR REPLACE FUNCTION etl_pipeline_f(p_limit NUMBER)
	RETURN t_etl_tab PIPELINED
IS
	TYPE t_src_tab IS TABLE OF src_table%ROWTYPE;
	v_src t_src_tab;
BEGIN
	LOOP
		-- Extracci√≥n por lotes
		SELECT * BULK COLLECT INTO v_src
		FROM (
			SELECT * FROM src_table
			WHERE procesado = 0
			AND ROWNUM <= p_limit
		);

		EXIT WHEN v_src.COUNT = 0;

		FOR i IN 1 .. v_src.COUNT LOOP
			-- L√≥gica avanzada de enriquecimiento + segmentaci√≥n
			PIPE ROW (t_etl_row(
				v_src(i).id,
				v_src(i).valor * DBMS_CRYPTO.HASH(TO_CHAR(v_src(i).id), 2),
				CASE
					WHEN v_src(i).valor < 100 THEN 'LOW'
					WHEN v_src(i).valor < 500 THEN 'MID'
					ELSE 'HIGH'
				END
			));
		END LOOP;
	END LOOP;

	RETURN;
END;
/

-- Consulta paralela del pipeline
SELECT /*+ PARALLEL(4) */ *
FROM TABLE(etl_pipeline_f(5000));
```
{% endraw %}`

**Qu√© resuelve:**

- ETL de alto volumen sin staging tables.
- Transformaci√≥n en streaming.
- Uso eficiente de memoria.
- Puede ser paralelizado, incluso distribuido.

---

## 2. **Motor de Reglas Empresariales Din√°micas (Dynamic SQL + JSON + PLSQL)**

### Caso: Un banco debe cambiar reglas de scoring sin desplegar c√≥digo

**Explicaci√≥n:**  
Las reglas se almacenan como JSON en una tabla. PL/SQL las interpreta din√°micamente.

### Ejemplo ‚Äî Regla din√°mica

{% raw %}
```plsql
DECLARE
	v_regla JSON_OBJECT_T;
	v_sql   VARCHAR2(4000);
	v_score NUMBER;
BEGIN
	-- Obtener regla JSON
	SELECT JSON_OBJECT_T(regla_json)
	INTO v_regla
	FROM reglas_scoring
	WHERE regla_id = 10;

	-- Construcci√≥n din√°mica de expresi√≥n
	v_sql := '
		SELECT (' || v_regla.get_String('formula') || ')
		FROM dual';

	EXECUTE IMMEDIATE v_sql INTO v_score;

	DBMS_OUTPUT.PUT_LINE('Score resultante = ' || v_score);
END;
```
{% endraw %}

**Qu√© resuelve:**

- Cambios de reglas por negocio sin tocar PL/SQL.
- Permite evaluaciones matem√°ticas o l√≥gicas complejas configurables.

---

## 3. **Particionamiento L√≥gico por C√≥digo con Result Cache Inteligente**

### Caso: Sistema que debe servir c√°lculos pesados a miles de consultas por segundo

**Explicaci√≥n:**  
`RESULT_CACHE` + invalidaci√≥n manual permite reducir tiempos a microsegundos.

### Ejemplo ‚Äî Cache con partici√≥n l√≥gica

{% raw %}
```plsql
CREATE OR REPLACE FUNCTION fx_get_riesgo(p_cliente NUMBER)
	RETURN NUMBER
	RESULT_CACHE RELIES_ON(clientes)
IS
	v_riesgo NUMBER;
BEGIN
	SELECT riesgo INTO v_riesgo
	FROM clientes
	WHERE id = p_cliente;

	RETURN v_riesgo;
END;
/

-- Invalida el valor del cache al actualizar
CREATE OR REPLACE TRIGGER trg_upd_cliente
AFTER UPDATE ON clientes
BEGIN
	DBMS_RESULT_CACHE.FLUSH;
END;
```
{% endraw %}

**Qu√© resuelve:**

- Consultas repetitivas ultra r√°pidas.
- Control total sobre invalidaci√≥n.
- Ideal para dashboards en tiempo real.

---

## 4. **Optimizaci√≥n de Pricing Avanzado usando Colecciones Indexadas + Hashes**

### Caso: Motor de precios que debe recalcular tarifas seg√∫n cientos de reglas jerarquizadas

**Explicaci√≥n:**  
Las _associative arrays_ permiten crear estructuras hash ultra r√°pidas para b√∫squedas complejas en memoria PL/SQL.

### Ejemplo ‚Äî Motor de pricing en memoria

{% raw %}
```plsql
DECLARE
	TYPE t_price_map IS TABLE OF NUMBER INDEX BY VARCHAR2(200);
	v_prices t_price_map;

	v_key VARCHAR2(200);
BEGIN
	-- Cargar reglas en memoria
	FOR r IN (SELECT categoria, subcat, coef
	          FROM pricing_reglas) LOOP
		v_key := r.categoria || ':' || r.subcat;
		v_prices(v_key) := r.coef;
	END LOOP;

	-- Aplicar reglas a transacci√≥n
	DBMS_OUTPUT.PUT_LINE(
		'Precio final = ' ||
		(100 * v_prices('ELEC:HIGH'))
	);
END;
```
{% endraw %}

**Qu√© resuelve:**

- Reglas jer√°rquicas r√°pidas (tiempo O(1)).
- Sistemas de pricing, scoring, tarifas y segmentaci√≥n.
- Evita JOINs costosos.

---

## 5. **Procesos de Conciliaci√≥n Inter-Sistemas a Alta Velocidad**

### Caso: Comparaci√≥n masiva de datos entre dos sistemas externos

**Explicaci√≥n:**  
Uso de `BULK COLLECT`, hashing y procesamiento batch para medir diferencias entre millones de registros.

### Ejemplo ‚Äî Conciliaci√≥n con hashing

{% raw %}
```plsql
DECLARE
	TYPE t_rows IS TABLE OF VARCHAR2(4000);

	v_src1 t_rows;
	v_src2 t_rows;

	v_diff t_rows := t_rows();
BEGIN
	-- Cargar datos (simplificado)
	SELECT DBMS_CRYPTO.HASH(col1 || col2, 2)
	BULK COLLECT INTO v_src1
	FROM tabla_a;

	SELECT DBMS_CRYPTO.HASH(col1 || col2, 2)
	BULK COLLECT INTO v_src2
	FROM tabla_b;

	-- Comparaci√≥n avanzada
	FOR i IN 1 .. v_src1.COUNT LOOP
		IF v_src2.EXISTS(i) THEN
			IF v_src1(i) != v_src2(i) THEN
				v_diff.EXTEND;
				v_diff(v_diff.COUNT) := 'DIF: ' || i;
			END IF;
		END IF;
	END LOOP;

	DBMS_OUTPUT.PUT_LINE('Total diferencias: ' || v_diff.COUNT);
END;
```
{% endraw %}

**Qu√© resuelve:**

- Conciliaci√≥n masiva entre sistemas heterog√©neos.
- Uso eficiente de CPU y memoria.
- Detecci√≥n r√°pida de divergencias.

---

## 6. **Orquestaci√≥n de Microservicios desde PL/SQL (HTTP + JSON + L√≥gica Transaccional)**

### Caso: Core bancario llama a microservicios externos pero controla la transacci√≥n en Oracle

**Explicaci√≥n:**  
PL/SQL act√∫a como coordinador de operaciones externas asegurando consistencia.

### Ejemplo ‚Äî Llamada avanzada a microservicios

{% raw %}
```plsql
DECLARE
	v_req   UTL_HTTP.req;
	v_resp  UTL_HTTP.resp;
	v_body  VARCHAR2(32767);
	v_json  JSON_OBJECT_T;
BEGIN
	v_req := UTL_HTTP.begin_request('https://api.interno/cliente/score', 'POST');
	UTL_HTTP.set_header(v_req, 'Content-Type', 'application/json');

	UTL_HTTP.write_text(v_req, '{"id":1234}');
	v_resp := UTL_HTTP.get_response(v_req);

	LOOP
		UTL_HTTP.read_text(v_resp, v_body, 32000);
		EXIT WHEN v_body IS NULL;
	END LOOP;

	UTL_HTTP.end_response(v_resp);

	v_json := JSON_OBJECT_T.parse(v_body);
	DBMS_OUTPUT.PUT_LINE('Score recibido: ' || v_json.get_Number('score'));
END;
```
{% endraw %}

**Qu√© resuelve:**

- Orquestaci√≥n transaccional h√≠brida.
- Integraci√≥n con APIs REST.
- L√≥gica compleja sin exponer Oracle directamente.

---

## 7. **Implementaci√≥n de un Sistema de Auditor√≠a Criptogr√°fica Interna**

### Caso: Empresa de seguros requiere auditor√≠a no repudiable dentro de Oracle

**Explicaci√≥n:**  
PL/SQL + `DBMS_CRYPTO` generan huellas digitales encadenadas (tipo blockchain ligera).

### Ejemplo ‚Äî Cadena de auditor√≠a

{% raw %}
```plsql
DECLARE
	v_last_hash RAW(256);
	v_new_hash  RAW(256);
BEGIN
	SELECT hash INTO v_last_hash
	FROM auditoria
	ORDER BY id DESC
	FETCH FIRST 1 ROW ONLY;

	v_new_hash := DBMS_CRYPTO.HASH(
		UTL_I18N.STRING_TO_RAW('evento=' || SYSTIMESTAMP || '|' || v_last_hash),
		DBMS_CRYPTO.HASH_SH256
	);

	INSERT INTO auditoria(id, timestamp, hash)
	VALUES (auditoria_seq.NEXTVAL, SYSTIMESTAMP, v_new_hash);
END;
```
{% endraw %}

**Qu√© resuelve:**

- Auditor√≠a encadenada estilo blockchain.
- No repudiable.
- Inmutable sin herramientas externas.

---

## ¬øQuieres la versi√≥n siguiente?

Puedo generar:

- **Versi√≥n con casos de ciberseguridad extrema**
- **Versi√≥n con patrones arquitect√≥nicos PL/SQL + microservicios**
- **Versi√≥n con optimizaciones de rendimiento extremo para 2025**
- **Versi√≥n con anti-patterns avanzados (qu√© NO hacer)**

# Patrones Arquitect√≥nicos PL/SQL + Microservicios (2025)

## 1. **Pattern: Orquestador Centralizado**
### Descripci√≥n
PL/SQL act√∫a como nodo central que coordina m√∫ltiples microservicios y bases de datos externas, asegurando consistencia transaccional.

### Ejemplo
{% raw %}
```plsql
DECLARE
	v_response1 CLOB;
	v_response2 CLOB;
BEGIN
	-- Llamada a microservicio A
	v_response1 := UTL_HTTP.REQUEST('https://api.servicioA.com/operacion', 'POST', '{"id":1001}');

	-- Llamada a microservicio B solo si A fue exitoso
	IF v_response1 IS NOT NULL THEN
		v_response2 := UTL_HTTP.REQUEST('https://api.servicioB.com/validar', 'POST', '{"ref":1001}');
	END IF;

	-- Registro interno de transacci√≥n
	INSERT INTO log_orquestacion(fecha, servicioA_resp, servicioB_resp)
	VALUES(SYSDATE, v_response1, v_response2);

	COMMIT;
END;
```
{% endraw %}`

**Ventaja:**
Control total de la l√≥gica empresarial desde Oracle, manteniendo integridad sin depender de middleware externo.

---

## 2. **Pattern: Event-Driven Architecture**

### Descripci√≥n

PL/SQL act√∫a como productor y consumidor de eventos usando tablas de cola o triggers; los microservicios reaccionan a cambios en la base de datos.

### Ejemplo ‚Äî Trigger Event Queue

{% raw %}
```plsql
CREATE OR REPLACE TRIGGER trg_evento_cliente
AFTER INSERT OR UPDATE ON clientes
FOR EACH ROW
BEGIN
	INSERT INTO event_queue(event_type, payload, fecha)
	VALUES(
		'CLIENTE_MODIFICADO',
		'{"id":' || :NEW.cliente_id || ',"nombre":"' || :NEW.nombre || '"}',
		SYSTIMESTAMP
	);
END;
/
```
{% endraw %}

**Explicaci√≥n:**
Microservicios externos leen `event_queue` y procesan eventos de forma as√≠ncrona, permitiendo desacoplar sistemas.

---

## 3. **Pattern: API Gateway Interno**

### Descripci√≥n

Oracle PL/SQL expone endpoints internos mediante ORDS o REST Data Services, actuando como gateway para microservicios y clientes internos.

### Ejemplo ‚Äî ORDS PL/SQL Endpoint

{% raw %}
```plsql
BEGIN
	-- Endpoint: /clientes/get
	ORDS.ENABLE_SCHEMA(
		p_enabled => TRUE,
		p_schema  => 'APP_SCHEMA'
	);

	-- Procedimiento que se mapea como REST GET
	CREATE OR REPLACE PROCEDURE get_cliente(p_id IN NUMBER) AS
		v_name VARCHAR2(100);
	BEGIN
		SELECT nombre INTO v_name FROM clientes WHERE cliente_id = p_id;
		HTP.P('{"cliente_id":' || p_id || ',"nombre":"' || v_name || '"}');
	END;
END;
```
{% endraw %}

**Ventaja:**

* Exposici√≥n segura de datos internos.
* Simplifica acceso de microservicios a datos cr√≠ticos.
* Permite control de autenticaci√≥n y throttling en Oracle.

---

## 4. **Pattern: Transacciones Distribuidas / Saga Pattern**

### Descripci√≥n

PL/SQL gestiona pasos locales con commits parciales o auton√≥micos, coordinando microservicios externos en transacciones distribuidas tipo saga.

### Ejemplo ‚Äî Saga Simplificada

{% raw %}
```plsql
BEGIN
	-- Paso 1: Actualizar inventario
	UPDATE inventario SET stock = stock - 1 WHERE item_id = 101;

	-- Paso 2: Llamada a microservicio de facturaci√≥n
	BEGIN
		UTL_HTTP.REQUEST('https://api.facturacion.com/generar', 'POST', '{"item":101}');
	EXCEPTION
		WHEN OTHERS THEN
			-- Revertir inventario si falla facturaci√≥n
			UPDATE inventario SET stock = stock + 1 WHERE item_id = 101;
			RAISE;
	END;

	COMMIT;
END;
```
{% endraw %}

**Ventaja:**

* Garantiza consistencia eventual sin depender de XA o middleware complicado.
* Cada paso maneja su propio rollback en caso de fallo.

---

## 5. **Pattern: Bulk + Queue para Alta Concurrencia**

### Descripci√≥n

PL/SQL act√∫a como motor de procesamiento de lotes para microservicios, usando BULK COLLECT y FORALL para disminuir latencia y bloqueo.

### Ejemplo

{% raw %}
```plsql
DECLARE
	TYPE t_jobs IS TABLE OF job_queue%ROWTYPE;
	v_jobs t_jobs;
BEGIN
	SELECT * BULK COLLECT INTO v_jobs
	FROM job_queue
	WHERE status = 'PENDING';

	FORALL i IN v_jobs.FIRST .. v_jobs.LAST
		UPDATE job_queue
		SET status = 'PROCESSING'
		WHERE job_id = v_jobs(i).job_id;

	-- Enviar a microservicio de procesamiento
	FOR i IN v_jobs.FIRST .. v_jobs.LAST LOOP
		UTL_HTTP.REQUEST('https://api.procesador.com/job', 'POST', '{"job_id":' || v_jobs(i).job_id || '}');
	END LOOP;

	COMMIT;
END;
```
{% endraw %}

**Ventaja:**

* Escalabilidad para cientos de miles de jobs diarios.
* Reducci√≥n de context switches.
* Control total desde Oracle, sin saturar microservicios externos.

---

## 6. **Pattern: Orquestaci√≥n de L√≥gica de Negocio Compleja**

### Descripci√≥n

Centralizar reglas cr√≠ticas de negocio en PL/SQL y exponerlas a microservicios mediante funciones REST o colas, evitando duplicaci√≥n en varios lenguajes.

### Ejemplo ‚Äî Motor de Reglas

{% raw %}
```plsql
CREATE OR REPLACE FUNCTION calcular_descuento(
	p_cliente_id NUMBER,
	p_monto NUMBER
) RETURN NUMBER AS
	v_desc NUMBER := 0;
BEGIN
	SELECT CASE
		WHEN tipo_cliente = 'VIP' THEN p_monto * 0.15
		WHEN tipo_cliente = 'REGULAR' THEN p_monto * 0.05
		ELSE 0
	END INTO v_desc
	FROM clientes
	WHERE cliente_id = p_cliente_id;

	RETURN p_monto - v_desc;
END;
```
{% endraw %}

**Ventaja:**

* Microservicios externos llaman a la funci√≥n v√≠a REST.
* Evita inconsistencias entre sistemas.
* Toda la l√≥gica de negocio permanece centralizada y auditada.

---

## 7. **Pattern: Integraci√≥n H√≠brida con Legacy Systems**

### Descripci√≥n

PL/SQL orquesta interacciones entre microservicios modernos y sistemas legacy (bases antiguas, mainframes), actuando como puente.

### Ejemplo ‚Äî Adaptador de Legacy

{% raw %}
```plsql
DECLARE
	v_data CLOB;
BEGIN
	-- Extraer datos legacy v√≠a DB Link
	SELECT datos_xml INTO v_data FROM legacy_db.remote_table@DBLINK_LEGACY;

	-- Transformar y enviar a microservicio
	UTL_HTTP.REQUEST('https://api.nuevo.com/import', 'POST', v_data);

	COMMIT;
END;
```
{% endraw %}

**Ventaja:**

* Evita reescribir sistemas antiguos.
* Centraliza integraci√≥n y control de errores.
* Permite migraci√≥n incremental a microservicios.

---

## 8. **Pattern: Observabilidad / Logging Centralizado**

### Descripci√≥n

Todos los microservicios reportan eventos a Oracle, que centraliza logs, m√©tricas y alertas usando procedimientos aut√≥nomos.

### Ejemplo ‚Äî Logging Aut√≥nomo

{% raw %}
```plsql
CREATE OR REPLACE PROCEDURE log_microservicio(
	p_servicio VARCHAR2,
	p_evento VARCHAR2
) AS
	PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	INSERT INTO log_microservicios(servicio, evento, fecha)
	VALUES(p_servicio, p_evento, SYSTIMESTAMP);
	COMMIT;
END;
```
{% endraw %}

**Ventaja:**

* Logs consistentes, independientes de transacciones externas.
* Facilita observabilidad y alertas en tiempo real.
* Ideal para microservicios distribuidos.

---

## Conclusi√≥n

Estos patrones muestran c√≥mo PL/SQL puede:

* Ser **nodo central** de orquestaci√≥n.
* Gestionar **eventos y colas** para microservicios.
* Exponer **REST / ORDS** de forma segura.
* Mantener **consistencia transaccional** incluso en entornos distribuidos.
* Servir como **motor de reglas de negocio** y de **procesamiento masivo**.

Integrar microservicios con PL/SQL permite modernizar arquitectura sin sacrificar el poder y la consistencia de Oracle Database.


# PL/SQL ‚Äî Anti-Patterns Avanzados (Qu√© NO hacer en 2025)

## 1. **Bloques Monol√≠ticos Gigantes**
### Descripci√≥n
Escribir un √∫nico bloque con cientos de l√≠neas, m√∫ltiples loops, DML y l√≥gica de negocio mezclada.

### Ejemplo
{% raw %}
```plsql
BEGIN
	FOR i IN 1..10000 LOOP
		UPDATE empleados SET salario = salario * 1.05 WHERE dept_id = i;
		INSERT INTO log_emp VALUES(i, SYSDATE, 'update');
		-- m√°s l√≥gica compleja, condiciones, llamadas a APIs
	END LOOP;
	COMMIT;
END;
```
{% endraw %}`

**Problemas:**

* Dif√≠cil de mantener y depurar.
* Alta probabilidad de errores.
* Consume demasiados recursos y puede bloquear la base de datos.

**Qu√© hacer en su lugar:**

* Modularizar en procedimientos, funciones y paquetes.
* Usar BULK COLLECT / FORALL.

---

## 2. **Cursor Row-by-Row (Slow-by-Slow / ‚ÄúSlow by Row‚Äù)**

### Descripci√≥n

Procesar fila por fila cuando hay miles o millones de registros, sin usar BULK COLLECT.

### Ejemplo

{% raw %}
```plsql
DECLARE
	v_name empleados.last_name%TYPE;
BEGIN
	FOR rec IN (SELECT last_name FROM empleados) LOOP
		-- Procesamiento fila a fila
		v_name := rec.last_name;
		DBMS_OUTPUT.PUT_LINE(v_name);
	END LOOP;
END;
```
{% endraw %}

**Problemas:**

* Cambios de contexto SQL ‚Üî PL/SQL frecuentes.
* Rendimiento extremadamente bajo.

**Qu√© hacer en su lugar:**

* BULK COLLECT + FORALL o procesamiento en SQL directo.

---

## 3. **Dynamic SQL sin Bind Variables**

### Descripci√≥n

Concatenar cadenas para construir consultas SQL din√°micas, incluyendo valores de entrada.

### Ejemplo

{% raw %}
```plsql
DECLARE
	v_sql VARCHAR2(4000);
	v_count NUMBER;
BEGIN
	v_sql := 'SELECT COUNT(*) FROM empleados WHERE dept_id = ' || :dept_id;
	EXECUTE IMMEDIATE v_sql INTO v_count;
END;
```
{% endraw %}

**Problemas:**

* Vulnerable a SQL Injection.
* Pierde performance por falta de reutilizaci√≥n de plan de ejecuci√≥n.

**Qu√© hacer en su lugar:**

* Usar bind variables con `EXECUTE IMMEDIATE ‚Ä¶ USING`.

---

## 4. **Excepciones Silenciosas**

### Descripci√≥n

Capturar todas las excepciones sin registrar ni manejar.

### Ejemplo

{% raw %}
```plsql
BEGIN
	UPDATE empleados SET salario = salario * 1.05;
EXCEPTION
	WHEN OTHERS THEN
		NULL; -- Ignora todos los errores
END;
```
{% endraw %}

**Problemas:**

* Dificulta debugging.
* Puede corromper datos o pasar errores inadvertidos a producci√≥n.

**Qu√© hacer en su lugar:**

* Manejar excepciones espec√≠ficas.
* Registrar errores y tomar acciones correctivas.

---

## 5. **Commit Frecuente o Dentro de Loops**

### Descripci√≥n

Ejecutar COMMIT dentro de un bucle fila por fila.

### Ejemplo

{% raw %}
```plsql
BEGIN
	FOR i IN 1..1000 LOOP
		UPDATE empleados SET salario = salario * 1.05 WHERE emp_id = i;
		COMMIT;
	END LOOP;
END;
```
{% endraw %}

**Problemas:**

* Reduce performance.
* Fragmenta undo y redo.
* Dif√≠cil de revertir transacciones.

**Qu√© hacer en su lugar:**

* Hacer COMMIT fuera de loops, usar BULK.

---

## 6. **Hardcoding de Par√°metros / Valores M√°gicos**

### Descripci√≥n

Incluir strings, n√∫meros o rutas directamente en c√≥digo PL/SQL.

### Ejemplo

{% raw %}
```plsql
BEGIN
	INSERT INTO log VALUES ('/home/oracle/logs/app.log', SYSDATE);
END;
```
{% endraw %}

**Problemas:**

* Dif√≠cil mantener entre entornos (dev, test, prod).
* Dif√≠cil de parametrizar.

**Qu√© hacer en su lugar:**

* Usar tablas de configuraci√≥n, constantes o variables de entorno.

---

## 7. **Dependencia Directa de Tablas Externas**

### Descripci√≥n

Hacer SELECT o DML directo en tablas de otros sistemas o legacy desde procesos cr√≠ticos sin intermediarios.

### Ejemplo

{% raw %}
```plsql
BEGIN
	SELECT nombre INTO v_name FROM legacy_db.clientes@dblink;
END;
```
{% endraw %}

**Problemas:**

* Fallas externas detienen procesos cr√≠ticos.
* Bloqueos y latencias inesperadas.

**Qu√© hacer en su lugar:**

* Replicar datos en tablas locales o usar colas/eventos.

---

## 8. **Triggers Complejos y Multi-Nivel**

### Descripci√≥n

Triggers que disparan otros triggers, con l√≥gica de negocio pesada.

### Ejemplo

{% raw %}
```plsql
CREATE OR REPLACE TRIGGER trg_emp AFTER INSERT ON empleados
FOR EACH ROW
BEGIN
	-- Hace m√∫ltiples llamadas, c√°lculos, updates
END;
```
{% endraw %}

**Problemas:**

* Dif√≠cil depuraci√≥n.
* Riesgo de recursi√≥n infinita.
* Impacto severo en performance.

**Qu√© hacer en su lugar:**

* Usar procedimientos almacenados llamados expl√≠citamente.
* Evitar l√≥gica pesada en triggers.

---

## 9. **Uso Excesivo de Autonomous Transactions**

### Descripci√≥n

Hacer commit aut√≥nomo en muchos lugares sin control.

### Ejemplo

{% raw %}
```plsql
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	INSERT INTO log VALUES('evento', SYSDATE);
	COMMIT;
END;
```
{% endraw %}

**Problemas:**

* Dificulta rollback global.
* Puede corromper integridad de datos en transacciones distribuidas.

**Qu√© hacer en su lugar:**

* Usar auton√≥micos solo para logging cr√≠tico o auditor√≠a.
* Mantener control central de transacciones.

---

## 10. **Generaci√≥n de Informes Dentro de PL/SQL con L√≥gica Compleja**

### Descripci√≥n

Crear PDFs, CSV o HTML en PL/SQL con loops y formateo masivo.

### Problemas:**

* Consumo excesivo de CPU y memoria.
* Dificultad de mantenimiento.
* Mejor delegar a ETL o microservicios especializados.

**Qu√© hacer en su lugar:**

* Extraer datos desde PL/SQL y procesarlos en un microservicio o aplicaci√≥n dedicada.

---

## Conclusi√≥n

Evitar estos anti-patterns avanzados permite que tu PL/SQL sea:

* Mantenible y legible.
* Eficiente y escalable.
* Seguro y confiable.

Siempre modulariza, usa BULK, maneja errores correctamente y separa l√≥gica de negocio de integraciones externas.

# Gu√≠a Completa de Entrevistas PL/SQL (2025)

## 1. **Conceptos Clave que Debes Dominar**
- **Diferencia SQL vs PL/SQL**:  
	- SQL: Lenguaje declarativo para manipulaci√≥n y consulta de datos.  
	- PL/SQL: Lenguaje procedimental que extiende SQL con variables, loops, condiciones, excepciones y subprogramas.
- **Bloques PL/SQL**:  
	- An√≥nimos, procedimientos, funciones, paquetes, triggers.  
- **Tipos de Datos**:  
	- Escalares: NUMBER, VARCHAR2, DATE, BOOLEAN.  
	- %TYPE / %ROWTYPE para mantener compatibilidad con columnas y tablas.  
- **Control de flujo**: IF, CASE, LOOP, WHILE, FOR, EXIT, GOTO (poco usado).  
- **Manejo de errores**: Excepciones predefinidas (NO_DATA_FOUND, TOO_MANY_ROWS) y excepciones personalizadas.  
- **Colecciones y tipos avanzados**:  
	- VARRAY, Nested Tables, Associative Arrays.  
- **Operaciones Bulk**: BULK COLLECT / FORALL para optimizar procesamiento masivo.  
- **SQL din√°mico**: EXECUTE IMMEDIATE, DBMS_SQL para consultas flexibles.  
- **Paquetes**: Encapsulan funciones, procedimientos, tipos y variables globales.  
- **Triggers**: BEFORE, AFTER, INSTEAD OF; fila a fila o statement level.  
- **Integraciones**: UTL_HTTP, UTL_FILE, DBMS_SCHEDULER, DBMS_ALERT, JSON/REST con ORDS.

---

## 2. **Preguntas T√©cnicas Comunes**
### SQL vs PL/SQL
- ¬øCu√°ndo usar SQL y cu√°ndo PL/SQL?  
- Ejemplo: INSERT masivo, c√°lculo de comisiones, transformaciones de datos.

### Bloques y Procedimientos
- Diferencia entre procedimiento y funci√≥n.  
- Ventajas de usar paquetes.  

### Manejo de Errores
- ¬øC√≥mo se captura una excepci√≥n en PL/SQL?  
- Diferencia entre excepciones predefinidas y definidas por el usuario.  
- Ejemplo: manejo de NO_DATA_FOUND en SELECT INTO.

### Optimizaci√≥n
- ¬øQu√© es un BULK COLLECT y cu√°ndo usarlo?  
- ¬øC√≥mo evitar context switches SQL ‚Üî PL/SQL?  

### Cursores
- Diferencia entre cursores impl√≠citos y expl√≠citos.  
- C√≥mo recorrer resultados y liberar recursos.

### SQL Din√°mico
- Ventajas de EXECUTE IMMEDIATE vs DBMS_SQL.  
- Uso seguro con bind variables para evitar SQL Injection.

### Triggers
- Tipos de triggers y ejemplos de uso.  
- Riesgos de triggers complejos y recursivos.

### Integraciones
- ¬øC√≥mo se env√≠a un HTTP POST desde PL/SQL?  
- Uso de UTL_FILE para generaci√≥n de CSV o logs.  
- Integraci√≥n con JSON y REST usando ORDS.

---

## 3. **Preguntas Avanzadas / Escenarios Reales**
- Dise√±ar un procedimiento que calcule bonificaciones y guarde resultados en tabla hist√≥rica.  
- Detectar cambios en tablas cr√≠ticas y almacenar auditor√≠a (trigger + tabla).  
- Procesar millones de registros sin saturar memoria (bulk collect + forall).  
- Exponer una funci√≥n PL/SQL a microservicios mediante REST.  
- Integrar PL/SQL con sistemas legacy o APIs externas sin perder consistencia.  
- Crear un motor de reglas din√°mico configurable desde JSON.  

---

## 4. **Preguntas de Optimizaci√≥n y Buenas Pr√°cticas**
- Diferencia entre row-by-row y BULK processing.  
- Cu√°ndo usar paquetes vs procedimientos sueltos.  
- C√≥mo evitar locks y deadlocks en transacciones masivas.  
- Uso adecuado de commit, autononomous transaction y manejo de rollback.  
- Evitar triggers complejos que disparen otros triggers.

---

## 5. **Preguntas de Dise√±o y Arquitectura**
- C√≥mo dise√±ar un paquete para l√≥gica de negocio reutilizable.  
- C√≥mo exponer PL/SQL a microservicios sin duplicar l√≥gica.  
- Dise√±o de auditor√≠a o logs centralizados.  
- Patrones de ETL internos con pipelines, bulk y cache de resultados.  
- Integraci√≥n con ORDS y RESTful services.  

---

## 6. **Ejercicios Pr√°cticos Comunes**
- Escribir un procedimiento que:  
	1. Seleccione clientes con contratos pr√≥ximos a vencer.  
	2. Genere CSV con sus datos.  
	3. Inserte log de env√≠o de notificaciones.  

- Crear un trigger que:  
	1. Detecte cambios de saldo en cuentas bancarias.  
	2. Inserte registro de auditor√≠a.  

- Optimizar un loop que actualiza 1 mill√≥n de registros en tabla `ventas`.

- Generar un motor de scoring que:  
	1. Reciba par√°metros din√°micos.  
	2. Devuelva calificaci√≥n calculada seg√∫n reglas configurables en JSON.  

---

## 7. **Recursos para Preparaci√≥n**
- [PL/SQL para desarrolladores | Oracle Espa√±a](https://www.oracle.com/es/database/technologies/appdev/plsql.html)  
- Oracle Database PL/SQL Language Reference 2025.  
- [Oracle Live SQL](https://livesql.oracle.com/) ‚Äî Practicar ejercicios online.  
- Cursos online: OpenWebinars, Udemy, Coursera.  
- Libros recomendados: *Oracle PL/SQL Programming* de Steven Feuerstein, √∫ltima edici√≥n.

---

## 8. **Tips Finales para la Entrevista**
- S√© capaz de explicar tus decisiones de dise√±o y optimizaci√≥n.  
- Familiar√≠zate con casos reales: comisiones, auditor√≠a, ETL, integraci√≥n microservicios.  
- Practica escribir procedimientos, funciones, triggers y paquetes en Oracle Live SQL.  
- Prep√°rate para preguntas sobre errores comunes y anti-patterns.  
- Explica c√≥mo mantienes consistencia y performance en sistemas cr√≠ticos.

# PL/SQL ‚Äî Respuestas y Hoja de Trucos para Entrevistas (2025)

## 1. **Conceptos Clave ‚Äî Respuestas R√°pidas**
- **SQL vs PL/SQL**:  
	- SQL: declarativo, solo consulta/manipula datos.  
	- PL/SQL: procedimental, combina SQL con variables, loops, excepciones y subprogramas.  

- **Bloques PL/SQL**:  
	- **An√≥nimo**: Ejecutable inmediato, no reutilizable.  
	- **Procedimiento**: Realiza acciones, puede recibir par√°metros, no devuelve valor.  
	- **Funci√≥n**: Devuelve un valor, se puede usar en SQL.  
	- **Paquete**: Agrupa procedimientos, funciones, tipos y variables globales.  
	- **Trigger**: Ejecuta l√≥gica autom√°ticamente ante eventos DML o DDL.

- **Tipos de Datos**:  
	- Escalares: NUMBER, VARCHAR2, DATE, BOOLEAN.  
	- `%TYPE / %ROWTYPE`: para mantener compatibilidad autom√°tica con columnas y tablas.

- **Control de flujo**: IF, CASE, LOOP, WHILE, FOR, EXIT.  
- **Manejo de errores**: Excepciones predefinidas (NO_DATA_FOUND, TOO_MANY_ROWS), excepciones definidas por usuario.  
- **Colecciones**: VARRAY, Nested Tables, Associative Arrays.  
- **Operaciones Bulk**: BULK COLLECT y FORALL para optimizaci√≥n de procesamiento masivo.  
- **SQL din√°mico**: EXECUTE IMMEDIATE + bind variables para seguridad y performance.  
- **Integraciones**: UTL_HTTP, UTL_FILE, DBMS_SCHEDULER, DBMS_ALERT, JSON, REST/ORDS.

---

## 2. **Preguntas T√©cnicas ‚Äî Respuestas Cortas**
- **Diferencia SQL vs PL/SQL**: SQL = consulta; PL/SQL = l√≥gica + SQL.  
- **Procedimiento vs Funci√≥n**: Procedimiento = no retorna valor; Funci√≥n = retorna valor.  
- **Paquetes**: Encapsulan y organizan c√≥digo, permiten variables globales, modularidad y mantenimiento.  
- **Excepciones**: NO_DATA_FOUND captura SELECT INTO vac√≠o; TOO_MANY_ROWS captura m√°s de una fila.  
- **BULK COLLECT / FORALL**: Para evitar procesamiento fila a fila y context switches SQL‚ÜîPL/SQL.  
- **Cursor impl√≠cito vs expl√≠cito**: Impl√≠cito = autom√°tico en SELECT INTO; expl√≠cito = OPEN/FETCH/LOOP/ CLOSE.  
- **SQL Din√°mico**: Usa bind variables para seguridad y plan reutilizable.  
- **Trigger**: Evitar l√≥gica pesada y recursi√≥n.  

---

## 3. **Escenarios Reales ‚Äî Respuestas / Tips**
- **Procedimiento de bonificaciones**: Usar BULK COLLECT para leer empleados, FORALL para updates masivos.  
- **Auditor√≠a en tabla hist√≥rica**: Trigger AFTER INSERT/UPDATE + autononomous transaction para logging seguro.  
- **Procesamiento millones de registros**: Bulk + FORALL, evitar row-by-row.  
- **Exposici√≥n a microservicios**: ORDS REST endpoints para funciones PL/SQL.  
- **Motor de reglas din√°mico**: Almacenar reglas en JSON + EXECUTE IMMEDIATE seguro con bind.  

---

## 4. **Optimizaci√≥n ‚Äî Trucos**
- Evitar loops fila a fila ‚Üí BULK COLLECT / FORALL.  
- Commit fuera de loops; auton√≥micos solo para logging/auditor√≠a.  
- Usar paquetes para centralizar l√≥gica.  
- Evitar triggers multi-nivel complejos.  
- SQL din√°mico = bind variables.  
- Profiling: DBMS_PROFILER, DBMS_TRACE.  
- Result Cache para c√°lculos repetitivos.  

---

## 5. **Dise√±o / Arquitectura ‚Äî Hoja de Trucos**
- **Orquestaci√≥n Centralizada**: PL/SQL coordina microservicios y transacciones.  
- **Event-Driven**: Tabla de colas + triggers ‚Üí microservicios reaccionan a eventos.  
- **API Gateway / ORDS**: Exponer procedimientos y funciones como REST.  
- **Saga / Transacciones Distribuidas**: Cada paso controlado; rollback parcial si falla.  
- **Bulk + Queue**: Procesamiento masivo eficiente.  
- **Motor de reglas**: JSON configurable; funci√≥n PL/SQL centralizada.  
- **Integraci√≥n con legacy**: DB Link o ETL incremental.  
- **Logging centralizado**: Pragma autonomous_transaction para logs independientes.  

---

## 6. **Anti-Patterns ‚Äî Recordatorio**
- Bloques monol√≠ticos gigantes ‚Üí modularizar.  
- Row-by-row loops ‚Üí BULK COLLECT / FORALL.  
- Dynamic SQL sin bind ‚Üí riesgo SQL Injection.  
- Excepciones silenciosas ‚Üí siempre manejar y loggear.  
- Commit dentro de loops ‚Üí mover fuera.  
- Hardcoding ‚Üí usar tablas de configuraci√≥n.  
- Dependencia directa en sistemas externos ‚Üí replicar/localizar datos.  
- Triggers complejos multi-nivel ‚Üí usar procedimientos expl√≠citos.  
- Auton√≥micos excesivos ‚Üí solo logs cr√≠ticos.  
- Informes complejos dentro de PL/SQL ‚Üí delegar a microservicios o ETL.

---

## 7. **Ejercicios Comunes ‚Äî Respuestas R√°pidas**
- **Clientes pr√≥ximos a vencer**: SELECT INTO BULK COLLECT, generar CSV con UTL_FILE, log con auton√≥micos.  
- **Trigger auditor√≠a**: AFTER UPDATE ‚Üí insert en tabla log.  
- **Optimizaci√≥n loop 1 mill√≥n registros**: BULK COLLECT + FORALL + COMMIT en batches.  
- **Motor de scoring din√°mico**: JSON reglas + EXECUTE IMMEDIATE + bind.  

---

## 8. **Atajos y Comandos √ötiles**
- `DECLARE ... BEGIN ... END;` ‚Üí bloque an√≥nimo.  
- `CREATE OR REPLACE PROCEDURE nombre IS ... END;` ‚Üí procedimiento.  
- `CREATE OR REPLACE FUNCTION nombre RETURN tipo IS ... END;` ‚Üí funci√≥n.  
- `%TYPE / %ROWTYPE` ‚Üí mantiene consistencia de tipos.  
- `BULK COLLECT INTO` ‚Üí cargar varias filas en colecciones.  
- `FORALL` ‚Üí ejecutar DML masivo.  
- `EXECUTE IMMEDIATE` ‚Üí SQL din√°mico.  
- `DBMS_OUTPUT.PUT_LINE()` ‚Üí debug.  
- `PRAGMA AUTONOMOUS_TRANSACTION` ‚Üí commit independiente.  
- `DBMS_PROFILER` / `DBMS_TRACE` ‚Üí perfilado de performance.  
- `ORDS` ‚Üí exponer funciones como REST.  
- `JSON_OBJECT_T` / `JSON_ARRAY_T` ‚Üí manipulaci√≥n JSON en PL/SQL.

---

**Tip final:**  
Antes de la entrevista, repasar:

- Sintaxis r√°pida de bloque/procedimiento/funci√≥n/paquete.  
- Ejemplos BULK COLLECT / FORALL.  
- Manejo de excepciones comunes y custom.  
- Triggers simples vs complejos y c√≥mo evitarlos.  
- Casos de integraci√≥n microservicios / REST / JSON.  
- Anti-patterns para mostrar conocimiento avanzado y buenas pr√°cticas.
