---
date: 2024-11-16 17:59
title: net
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: Software engineering
tags:
  - NET
  - ASP
  - CSharp
  - xnl
  - xaml
---
# .NET  

- [Desarrollo multiplataforma](/desarrollo%20multiplataforma/desarrollo-multiplataforma/)
- 
- [cpp](/software%20engineering/cpp/)
- [csharp](/software%20engineering/csharp/)
- android
- [Sistemas](/sistemas/sistemas/)
- [ASP NET](/backend/asp-net/)
- [MAUI NET](/desarrollo%20multiplataforma/maui-net/)
- [xamarin](/desarrollo%20multiplataforma/xamarin/)
- Blazor

## Contenedores y despliegue
- [Docker](/software%20engineering/docker/)
	- Containerize an app with Docker tutorial - .NET-build-containertabs=windows&pivots=dotnet-9-0
	- **Buenas pr√°cticas al contenerizar apps .NET**
		- Usa im√°genes base oficiales de .NET (runtime y SDK separadas).
		- Implementa multi-stage builds para reducir el tama√±o de la imagen.
		- Define variables de entorno para `ASPNETCORE_ENVIRONMENT` y logging.
		- Utiliza `ENTRYPOINT` y `CMD` correctamente para servicios y tareas programadas.
		- Gestiona secrets con herramientas como `Docker secrets`, `Azure Key Vault` o `AWS Secrets Manager`.
	- **Integraci√≥n con CI/CD**
		- Usa GitHub Actions o Azure Pipelines para automatizar el build y push al registry.
		- Escanea vulnerabilidades en im√°genes con herramientas como `trivy` o `dockle`.

## Hojas de c√°lculo y automatizaci√≥n
- [visual basic VBA](/software%20engineering/visual-basic-vba/)
- [Aspose.Cells for .NET | Documentation](https://docs.aspose.com/cells/net/)
- [ClosedXML - GitHub](https://github.com/ClosedXML/ClosedXML)
- app para exportar a excel con plantillas angular, net y cell üî•

### Librer√≠as y frameworks destacados
- **Aspose.Cells for .NET**
	- Permite crear, leer y modificar archivos Excel program√°ticamente.
	- Soporta f√≥rmulas, gr√°ficos, pivot tables y estilos complejos.
	- Ideal para automatizaci√≥n de reportes o generaci√≥n de hojas de c√°lculo sin depender de Excel instalado.
- **ClosedXML**
	- API fluida y sencilla sobre OpenXML.
	- Permite manejar `.xlsx` y `.xlsm` con enfoque declarativo.
	- Ejemplo b√°sico:
	{% raw %}
```csharp
	using ClosedXML.Excel;

	var workbook = new XLWorkbook();
	var worksheet = workbook.Worksheets.Add("Datos");
	worksheet.Cell(1, 1).Value = "Nombre";
	worksheet.Cell(1, 2).Value = "Edad";
	worksheet.Cell(2, 1).Value = "Eduardo";
	worksheet.Cell(2, 2).Value = 29;
	workbook.SaveAs("Reporte.xlsx");
	```
{% endraw %}
- **VBA (Visual Basic for Applications)**
	- Permite automatizar tareas dentro de Excel u Office.
	- Combinable con .NET a trav√©s de COM Interop o scripts externos.
	- Ejemplo: desde .NET, ejecutar macro VBA existente:
	{% raw %}
```csharp
	var excelApp = new Microsoft.Office.Interop.Excel.Application();
	var workbook = excelApp.Workbooks.Open("C:\\reportes\\macro.xlsm");
	excelApp.Run("ActualizarDatos");
	workbook.Close(true);
	excelApp.Quit();
	```
{% endraw %}

### Integraci√≥n de .NET con Excel
- Exportar datos desde aplicaciones .NET (ej. ASP.NET, MAUI o WinForms) a plantillas Excel.
- Uso de librer√≠as para reportes con estilos corporativos.
- Automatizaci√≥n de tareas repetitivas (generar reportes diarios, leer inventarios, procesar celdas).
- Integraci√≥n con Angular o frontend SPA:
	- Backend .NET genera el archivo Excel.
	- Angular descarga el archivo con `FileSaver.js` o similar.
	- Ideal para sistemas administrativos o ERP modulares.

## Ampliaciones y temas relacionados
- Entity Framework Core para acceso a datos en entornos .NET.
- Blazor como alternativa web a Angular/React en ecosistema .NET.
- Testing en .NET (xUnit, NUnit, Moq).
- [CICD](/devops/cicd/) para pipelines automatizados.
- Microservicios con .NET usando gRPC o REST.
- Performance y profiling .NET con herramientas como dotTrace y BenchmarkDotNet.


---
# .NET ‚Äî Ampliaci√≥n de conceptos avanzados  

## Arquitectura y dise√±o avanzado
- **Patrones de arquitectura aplicados a .NET**
	- **Clean Architecture** y **Onion Architecture**: separan las capas de dominio, aplicaci√≥n e infraestructura, facilitando el mantenimiento y los tests.
	- **Domain-Driven Design (DDD)**: organiza el c√≥digo alrededor del dominio empresarial.  
		- Uso de **Value Objects**, **Entities**, **Aggregates**, **Repositories** y **Domain Events**.  
		- Compatible con **CQRS** y **Event Sourcing** para separaci√≥n de lectura/escritura y auditor√≠a hist√≥rica.
	- **Microservicios con .NET**:
		- Comunicaci√≥n con [gRPC](/backend/grpc/) o mensajer√≠a (RabbitMQ, Azure Service Bus).
		- Uso de **API Gateway** (Ocelot, YARP) para enrutar peticiones.
		- Sincronizaci√≥n de datos eventual con eventos distribuidos.
	- **Modular Monoliths**: estructura intermedia entre monolito y microservicio; permite escalar de forma controlada.

- **Patrones de dise√±o comunes**
	- **Dependency Injection** (DI): est√°ndar en .NET Core mediante `IServiceCollection`.
	- **Factory**, **Strategy**, **Observer**, **Decorator**, **Mediator**: patrones que se implementan f√°cilmente con C# gracias a delegates, interfaces y eventos.
	- **Command Pattern** para desacoplar acciones de UI en [MAUI NET](/desarrollo%20multiplataforma/maui-net/) o [xamarin](/desarrollo%20multiplataforma/xamarin/).

## Ecosistema moderno de desarrollo .NET
- **Rendimiento y runtime**
	- **.NET 9 y AOT (Ahead-of-Time Compilation)**: permite generar binarios nativos m√°s r√°pidos y ligeros.
	- **Span\<T\> y Memory\<T\>**: optimizaci√≥n de acceso a memoria.
	- **Minimal APIs** en [ASP NET](/backend/asp-net/) para servicios ligeros.
	- **NativeAOT** para entornos sin runtime preinstalado.

- **Interoperabilidad multiplataforma**
	- [MAUI NET](/desarrollo%20multiplataforma/maui-net/) para apps m√≥viles, escritorio y web h√≠brido.
	- Blazor y WebAssembly: ejecutar C# en el navegador sin JavaScript.
	- Integraci√≥n con android mediante bindings nativos o APIs de plataforma.
	- Comunicaci√≥n entre [cpp](/software%20engineering/cpp/) y .NET v√≠a P/Invoke o C++/CLI.

- **Integraci√≥n con contenedores y nube**
	- [Docker](/software%20engineering/docker/) como entorno de ejecuci√≥n port√°til.
	- Publicaci√≥n directa en [Azure](/cloud/azure/) con `dotnet publish --os linux --arch x64 /t:PublishContainer`.
	- Uso de **Kubernetes** con configuraciones Helm o manifestos YAML.
	- Logs centralizados mediante **Serilog** o **Seq**.

## Herramientas de productividad y automatizaci√≥n
- **Builds y DevOps**
	- CI CD con GitHub Actions, Azure DevOps o Jenkins.
	- Versionado sem√°ntico automatizado con `GitVersion`.
	- An√°lisis est√°tico con **SonarQube** o **Roslyn Analyzers**.

- **Testing**
	- Unit testing con **xUnit** o **NUnit**.
	- Mocking de dependencias con **Moq** o **NSubstitute**.
	- **Integration Tests** con `WebApplicationFactory` en ASP.NET Core.
	- **Benchmarking** con **BenchmarkDotNet**.

## Integraci√≥n con hojas de c√°lculo y documentos
- [visual basic VBA](/software%20engineering/visual-basic-vba/) para automatizaci√≥n nativa.
- **ClosedXML**, **Aspose.Cells**, y **EPPlus** como principales librer√≠as .NET para Excel.
- Generaci√≥n de reportes corporativos:
	- Plantillas Excel din√°micas con placeholders.
	- Exportaci√≥n a PDF combinando Aspose.Cells + Aspose.PDF.
	- Automatizaci√≥n de reportes financieros o logs operativos.

### Ejemplo: generaci√≥n avanzada de reportes con ClosedXML
{% raw %}
```csharp
using ClosedXML.Excel;
using System.Data;

public class ReportGenerator
{
	public void Generate(DataTable data)
	{
		using var workbook = new XLWorkbook();
		var ws = workbook.Worksheets.Add("Reporte");
		// Encabezados
		for (int i = 0; i < data.Columns.Count; i++)
			ws.Cell(1, i + 1).Value = data.Columns[i].ColumnName;

		// Cuerpo
		ws.Cell(2, 1).InsertData(data.AsEnumerable());
		// Estilo
		ws.RangeUsed().Style.Border.OutsideBorder = XLBorderStyleValues.Thin;
		ws.Columns().AdjustToContents();
		workbook.SaveAs("ReporteAvanzado.xlsx");
	}
}
```
{% endraw %}`

## Extensiones y ecosistema externo

* **ORMs y acceso a datos**

  * Entity Framework Core con LINQ-to-SQL y Migrations.
  * Dapper para consultas r√°pidas y control sobre SQL.
  * **Prisma.NET** (alternativa moderna multiplataforma).

* **Autenticaci√≥n y seguridad**

  * Identity Server para OAuth2 y OpenID Connect.
  * **JWT** para microservicios.
  * Encriptaci√≥n de datos con `DataProtectionProvider`.

* **APIs y mensajer√≠a**

  * [gRPC](/backend/grpc/) para comunicaci√≥n binaria eficiente.
  * **SignalR** para tiempo real (chats, dashboards).
  * MediatR para CQRS e inyecci√≥n de comportamientos cross-cutting (logging, validaciones).
## Siguientes pasos y temas por expandir

* Event Sourcing y CQRS con .NET
* Saga Pattern y transacciones distribuidas
* Testing distribuido entre microservicios
* Optimizaci√≥n y profiling .NET
* [[Reflexi√≥n y metaprogramaci√≥n en C#]]
* Interoperabilidad avanzada con C++ y Rust desde .NET
* Desarrollo de librer√≠as NuGet internas
* Arquitectura hexagonal aplicada a .NET Core

# .NET ‚Äî Fundamentos complementarios y conceptos esenciales  

## Fundamentos del ecosistema .NET

### 1. CLR, BCL y compilaci√≥n
- **CLR (Common Language Runtime)**  
	Es el motor de ejecuci√≥n de .NET, responsable de:
	- Gesti√≥n de memoria (GC, heap, stack).
	- Seguridad y aislamiento de c√≥digo (sandboxing, CAS).
	- Ejecuci√≥n de c√≥digo intermedio (IL) compilado a m√°quina nativa mediante **JIT** o **AOT**.

- **BCL (Base Class Library)**  
	Conjunto de namespaces fundamentales como:
	- `System`, `System.IO`, `System.Collections`, `System.Threading`, `System.Net`.
	- Proporciona estructuras base, colecciones, IO, red, threading, tareas y utilidades generales.
	- Facilita la interoperabilidad entre lenguajes soportados (C#, F#, VB.NET).

- **Compilaci√≥n y despliegue**
	- **JIT (Just-in-Time)**: compila el c√≥digo IL en tiempo de ejecuci√≥n.
	- **AOT (Ahead-of-Time)**: genera binarios nativos optimizados (ideal para entornos embebidos o contenedores).
	- **Assembly** (`.dll` o `.exe`): unidad de despliegue que incluye metadatos, IL y recursos.
	- **NuGet**: sistema de gesti√≥n de dependencias y distribuci√≥n de paquetes.

### 2. Tipos, memoria y gesti√≥n
- **Tipos por valor y por referencia**
	- Valor: `struct`, `enum` ‚Üí almacenados en stack.
	- Referencia: `class`, `interface`, `delegate`, `array` ‚Üí heap.
- **Garbage Collector (GC)**
	- Administra la memoria autom√°ticamente.
	- Generacional (Gen 0, 1, 2) para optimizar rendimiento.
	- Permite modos configurables (`Server`, `Workstation`, `SustainedLowLatency`).
- **Span\<T\> y Memory\<T\>**
	- Acceso seguro y eficiente a datos sin copias adicionales.
	- Fundamentales en .NET moderno para optimizaci√≥n de rendimiento.

### 3. Asincron√≠a y concurrencia
- **Task-based Asynchronous Pattern (TAP)**  
	Usa `async` / `await` para manejar I/O no bloqueante.
	- `Task.Run()` ‚Üí ejecuci√≥n paralela en pool de threads.
	- `ValueTask` ‚Üí reduce overhead en operaciones r√°pidas o sincr√≥nicas.
- **Parallelism & Threading**
	- `Parallel.For` y `Parallel.ForEach` para procesamiento concurrente.
	- `System.Threading.Channels` para pipelines asincr√≥nicos.
	- `PLINQ` para consultas paralelas sobre colecciones.

### 4. Configuraci√≥n, logging y dependencia
- **Configuraci√≥n flexible**
	- `appsettings.json`, variables de entorno, secrets locales.
	- `IConfiguration` y `IOptions<T>` para inyecci√≥n tipada.
- **Logging unificado**
	- `ILogger<T>` integrado en todo el ecosistema.
	- Integraciones con Serilog, Seq, Application Insights.
- **Dependency Injection nativo**
	- Registro mediante `AddTransient`, `AddScoped`, `AddSingleton`.
	- Compatible con `IServiceProvider` y decoradores din√°micos.

## Fundamentos de desarrollo y despliegue

### 5. Entrada/salida y red
- **System.IO**
	- Streams, archivos, directorios y buffers.
	- Asincron√≠a con `FileStream` y `StreamReader` async.
- **Networking**
	- `HttpClient` moderno, `Sockets` para bajo nivel.
	- `System.Net.Http.Json` para APIs REST.
	- [gRPC](/backend/grpc/) para comunicaci√≥n binaria optimizada entre microservicios.

### 6. Serializaci√≥n y formatos
- **JSON**
	- `System.Text.Json` por defecto: r√°pido, eficiente y tipado.
	- `Newtonsoft.Json` a√∫n √∫til para escenarios complejos (polimorfismo, LINQ a JSON).
- **XML y BSON**
	- `System.Xml` para configuraciones o compatibilidad legacy.
	- `MongoDB.Bson` para NoSQL.
- **Binary serialization**
	- Usada en entornos controlados o para performance cr√≠tico.
	- Reemplazada en la mayor√≠a de casos por JSON o MessagePack.

### 7. Entornos de ejecuci√≥n y compatibilidad
- **.NET Standard**
	- Abstracci√≥n que unific√≥ APIs entre .NET Framework, .NET Core y Xamarin.
- **.NET Core ‚Üí .NET 5+**
	- Unificaci√≥n completa del runtime.
	- Soporte multiplataforma real (Windows, Linux, macOS, ARM).
- **Frameworks especializados**
	- [ASP NET](/backend/asp-net/) para web.
	- [MAUI NET](/desarrollo%20multiplataforma/maui-net/) y [xamarin](/desarrollo%20multiplataforma/xamarin/) para m√≥vil.
	- Blazor para UI web con C#.
	- WPF y WinForms para escritorio cl√°sico.

### 8. Seguridad y autenticaci√≥n
- **Criptograf√≠a**
	- `System.Security.Cryptography` incluye AES, RSA, HMAC.
	- Soporte para certificados X.509 y firma digital.
- **Identity y autenticaci√≥n**
	- ASP NET Identity para manejo de usuarios y roles.
	- JWT para APIs y microservicios.
	- OpenID Connect y OAuth2 con Identity Server o Azure AD.

## 9. Ecosistema de herramientas y flujo de trabajo

### CLI y automatizaci√≥n
- `dotnet new`, `build`, `run`, `publish`, `test`, `pack`.
- Integraci√≥n con CI/CD y Docker.
- Scripts cross-platform (`.NET tools` globales y locales).

### IDEs y editores
- **Visual Studio**: entorno completo, debugger avanzado.
- **VS Code**: ligero y multiplataforma.
- **JetBrains Rider**: integraci√≥n profunda con herramientas de an√°lisis.

### Testing
- **Unit Tests:** xUnit, NUnit, MSTest.
- **Mocking:** Moq, NSubstitute, FakeItEasy.
- **Integraci√≥n y E2E:** Playwright.NET, Selenium, WebApplicationFactory.
- **Coverage y pipelines:** integraci√≥n con Azure DevOps o GitHub Actions.

## 10. Ecosistema moderno y comunidad
- **NuGet y GitHub Packages** para distribuci√≥n de librer√≠as.
- **Open Source en .NET**: .NET runtime, Roslyn, ASP.NET Core, EF Core.
- **Comunidad activa**: .NET Foundation, Microsoft Learn, Stack Overflow.
- **Actualizaciones frecuentes**: releases semestrales con .NET 9 y versiones LTS (cada 2 a√±os).

## Siguientes expansiones recomendadas
- Internals del CLR y JIT avanzado
- Memoria, GC y optimizaci√≥n de heap
- Patrones asincr√≥nicos y concurrencia avanzada
- Networking de alto rendimiento en .NET
- Metaprogramaci√≥n con Reflection y Source Generators
- Creaci√≥n de NuGet packages internos y versionado sem√°ntico
- Desarrollo multiplataforma con MAUI y Blazor Hybrid
- Infraestructura como c√≥digo con .NET y Terraform

# .NET ‚Äî Temas avanzados y √°reas complementarias  

## 1. Internals del CLR y optimizaci√≥n avanzada

### Ejecuci√≥n interna del CLR
- **Metadata y Reflection**
	- Cada `Assembly` contiene *metadata tables* que describen tipos, m√©todos y atributos.
	- `System.Reflection` permite inspecci√≥n y creaci√≥n din√°mica de tipos en runtime.
	- **Reflection.Emit** y **DynamicMethod** permiten generar IL din√°mico (√∫til en frameworks o proxies).

- **Runtime Generics**
	- Generics se implementan mediante *reification* completa: los tipos gen√©ricos existen en tiempo de ejecuci√≥n.
	- Permite reflejar, instanciar y optimizar tipos gen√©ricos con constraints (`where T : class`, etc.).
	- Reduce *boxing/unboxing* en colecciones tipadas (`List<int>` vs `ArrayList`).

- **Tiered Compilation**
	- El CLR usa dos fases: compilaci√≥n r√°pida y optimizaci√≥n progresiva.
	- **Tier 0:** c√≥digo JIT r√°pido para inicio veloz.  
	  **Tier 1:** optimizaci√≥n posterior basada en perfilado (Hot Path JIT).

- **Profile-guided Optimization (PGO)**
	- A partir de .NET 8, el runtime ajusta optimizaciones seg√∫n ejecuci√≥n real.
	- Permite mejoras autom√°ticas de rendimiento en builds posteriores.

## 2. Memoria, GC y optimizaci√≥n del heap

- **Estructura de memoria**
	- *Stack:* variables locales y llamadas.  
	- *Heap:* objetos, closures, referencias.  
	- *LOH (Large Object Heap):* bloques >85KB, liberados en GC completo.
	- *Pinned Objects:* evitan movimiento de memoria (√∫tiles en interoperabilidad).

- **T√©cnicas de optimizaci√≥n**
	- Evitar **allocations** innecesarias (usar `Span`, `ArrayPool`).
	- Reutilizar buffers (patr√≥n *Object Pooling* con `Microsoft.Extensions.ObjectPool`).
	- Aplicar *structs* inmutables y *readonly* cuando sea posible.
	- Usar **ValueTask** y **IAsyncEnumerable** para reducir overhead asincr√≥nico.

## 3. Concurrencia avanzada

- **Dataflow y actores**
	- `System.Threading.Tasks.Dataflow`: modelo de bloques (producer-consumer, pipelines).
	- Implementaci√≥n de patrones actor-like para procesamiento concurrente sin locks.
- **Async Streams**
	- `await foreach` en `IAsyncEnumerable<T>` permite flujos asincr√≥nicos continuos.
- **Synchronization Context**
	- Controla c√≥mo se programan tareas (UI thread, web context, etc.).
	- √ötil para integrar tareas background con [ASP NET](/backend/asp-net/) o [MAUI NET](/desarrollo%20multiplataforma/maui-net/) sin bloquear.

## 4. Networking de alto rendimiento

- **Sockets y pipelines**
	- `System.IO.Pipelines`: base interna de Kestrel y SignalR, optimiza I/O sin copias.
	- `SocketAsyncEventArgs` para operaciones masivas de red sin crear objetos.
- **HTTP/3 y QUIC**
	- Soporte en .NET 8+ para HTTP/3 (m√°s r√°pido, seguro y basado en UDP).
- **MessagePack y gRPC**
	- MessagePack: serializaci√≥n binaria ultrarr√°pida.
	- gRPC: comunicaci√≥n tipo RPC con contratos `.proto`, ideal para microservicios.

## 5. Metaprogramaci√≥n y generaci√≥n de c√≥digo

- **Reflection y atributos**
	- Atributos personalizados para metadata declarativa (`[Authorize]`, `[CustomMapping]`).
	- Inspecci√≥n y ejecuci√≥n din√°mica seg√∫n decoradores.
- **Source Generators**
	- Ejecutan en compilaci√≥n para generar c√≥digo est√°tico.
	- Usados en frameworks modernos (por ejemplo, `System.Text.Json` genera serializadores a compile-time).
	- Mejora rendimiento evitando reflection runtime.
- **Roslyn APIs**
	- Permiten an√°lisis y transformaci√≥n de c√≥digo fuente (linting, refactoring, tooling interno).

## 6. Extensibilidad e interoperabilidad

- **Interop con C++**
	- `DllImport` y `extern` para llamar funciones nativas (P/Invoke).
	- C++/CLI para integraci√≥n profunda y gesti√≥n mixta.
- **Interop con Rust**
	- Comunicaci√≥n v√≠a FFI (`extern "C"`) usando `unsafe` y `Marshal`.
- **COM Interop**
	- Uso de librer√≠as legacy (Office, Windows Shell) desde .NET moderno.
- **Embeddings**
	- .NET embebido dentro de motores C++ o Python con `hostfxr` y `nethost`.

## 7. Infraestructura y despliegue

- **Infraestructura como c√≥digo (IaC)**
	- Integraci√≥n con Terraform, Pulumi o Bicep mediante SDKs .NET.
- **Observabilidad**
	- Logging estructurado (Serilog), m√©tricas (Prometheus .NET exporters), tracing (OpenTelemetry).
- **Diagn√≥stico**
	- `dotnet-counters`, `dotnet-trace`, `dotnet-dump` para profiling live.
	- **PerfView** para inspeccionar GC, CPU y memoria.
- **Hot Reload**
	- Permite edici√≥n en tiempo real sin recompilar completamente (productividad alta en UI y API).

## 8. Multiplataforma y dispositivos

- **MAUI avanzado**
	- Integraci√≥n nativa con sensores, Bluetooth, c√°mara y almacenamiento.
	- Soporte para Blazor Hybrid: web + nativo en una misma app.
- **WebAssembly y Blazor WASM**
	- Ejecuci√≥n directa en navegador, sin servidor.
	- Integraci√≥n con APIs JS mediante `IJSRuntime`.
- **IoT y .NET nanoFramework**
	- Framework liviano para microcontroladores (.NET CLR reducido).
	- Uso de `System.Device.Gpio` para hardware Raspberry Pi, ESP32, etc.

## 9. Cloud-native y resiliencia

- **Resiliencia**
	- Pol√≠ticas de reintento, fallback y circuit breaker con **Polly**.
	- Integraci√≥n de resiliencia autom√°tica en `HttpClientFactory`.
- **Distribuci√≥n y mensajer√≠a**
	- RabbitMQ, Azure Service Bus, Kafka mediante librer√≠as oficiales.
	- Event-driven architecture con `MassTransit`, `Rebus` o `NServiceBus`.
- **Serverless**
	- Azure Functions o AWS Lambda con runtime .NET nativo.
	- Ejecuci√≥n basada en eventos y despliegue inmediato desde CLI.

## 10. Pr√°cticas de ingenier√≠a y calidad

- **Versionado y mantenimiento**
	- LTS (Long Term Support) y Current releases: planificar migraciones.
	- Semantic Versioning (SemVer) aplicado a NuGet.
- **Performance Testing**
	- `BenchmarkDotNet` para microbenchmarks reproducibles.
- **Code Quality**
	- An√°lisis est√°tico con Roslyn Analyzers.
	- Uso de convenciones `StyleCop`, `FxCop`, `.editorconfig`.
- **Documentaci√≥n**
	- `docfx` o `Sandcastle` para generar documentaci√≥n a partir de XML docs.

## 11. Integraci√≥n con otros lenguajes y ecosistemas

- **Python y R**
	- Comunicaci√≥n v√≠a REST, gRPC o con `Python.NET`.
- **JavaScript**
	- Interoperabilidad directa en Blazor WASM o mediante SignalR.
- **Java**
	- Uso de `IKVM.NET` (hist√≥rico) o integraci√≥n por API Gateway.
- **SQL y NoSQL**
	- Conectores nativos para SQL Server, PostgreSQL, MongoDB, Redis, Cassandra.
	- LINQ-to-Entities y LINQ-to-Objects para consultas tipadas.

## 12. Pruebas distribuidas y sistemas complejos

- **Tests de integraci√≥n entre microservicios**
	- Contenedores de prueba con `Testcontainers.NET`.
	- Mock de colas y buses de mensajes.
- **Contratos y validaci√≥n**
	- Pact Testing (Consumer-Driven Contracts).
	- Validaciones autom√°ticas con `FluentValidation` y `DataAnnotations`.

## Siguientes pasos y notas relacionadas
- Patrones Enterprise en .NET
- Event Driven Architecture con MassTransit
- Source Generators y metaprogramaci√≥n pr√°ctica
- Profiling y optimizaci√≥n .NET con PerfView y BenchmarkDotNet
- Desarrollo h√≠brido con MAUI + Blazor
- Implementaci√≥n de resiliencia avanzada con Polly y HttpClientFactory
- Creaci√≥n de SDKs y librer√≠as NuGet internas
- Diagn√≥stico de memoria y GC tuning en producci√≥n

# .NET ‚Äî Extensi√≥n completa de temas especializados  

## 1. Ecosistema empresarial y arquitectura organizacional

### Arquitectura orientada a dominios amplios (DDD + Enterprise)
- **Bounded Contexts**: cada m√≥dulo del negocio tiene su propio modelo y l√≥gica interna, comunic√°ndose mediante eventos o APIs.  
- **Anti-Corruption Layer (ACL)**: capa intermedia que evita acoplar dominios heterog√©neos.
- **Domain Events y Event Bus**: coordinaci√≥n as√≠ncrona entre m√≥dulos o microservicios.
- **Specification Pattern**: encapsula consultas de negocio complejas reutilizables (ideal para Entity Framework Core).

### Monitoreo de ecosistemas distribuidos
- Telemetr√≠a unificada con **OpenTelemetry**:
	- *Tracing*: seguimiento de peticiones a trav√©s de microservicios.
	- *Metrics*: consumo de CPU, memoria, latencia, throughput.
	- *Logs correlacionados* con `Activity.Current` y `ILogger`.

### Estrategias de migraci√≥n empresarial
- Migrar desde NET Framework a .NET moderno:
	- An√°lisis con `try-convert` o `Upgrade Assistant`.
	- Uso de **Compatibility Shim Packages**.
	- Modularizaci√≥n progresiva y despliegue h√≠brido (.NET Core + Framework coexistentes).

---

## 2. Data Engineering y procesamiento masivo

### Acceso y persistencia avanzada
- **EF Core avanzado**
	- Soporte para `Temporal Tables` (auditor√≠a hist√≥rica).
	- `Raw SQL` y `Interpolated Queries` seguras.
	- `Value Converters` para tipos personalizados (ej. `Currency`, `Email`).
- **ORM alternativos**
	- Dapper para queries manuales de alto rendimiento.
	- `Linq2Db` y `RepoDB` para acceso directo con LINQ optimizado.
- **Caching**
	- `IMemoryCache`, `DistributedCache`, y Redis con `StackExchange.Redis`.
	- Patr√≥n *Cache Aside* para mejorar tiempos de respuesta.

### Data Processing
- **Parallel Data Pipelines**
	- Uso de `Channels`, `TPL Dataflow` o `IAsyncEnumerable` para ETL interno.
- **Integraci√≥n con sistemas de Big Data**
	- Conectores hacia Kafka, Spark, o Data Lake con SDKs .NET.
- **Batch y scheduling**
	- Hangfire para tareas programadas persistentes.
	- Quartz.NET para orquestaci√≥n temporal distribuida.

---

## 3. DevOps, observabilidad y despliegue continuo

### CI/CD avanzado
- **Build Pipelines**
	- GitHub Actions, Azure DevOps, GitLab CI.
	- Estrategia de versiones autom√°ticas (tags, commits, branches).
- **Deployment Targets**
	- Docker registries, Azure Web Apps, AWS ECS/Fargate, Kubernetes.
	- Publicaci√≥n multi-stage con YAML pipelines.
- **Infraestructura reproducible**
	- Terraform + .NET SDK.
	- `Pulumi` con C# o F# para declarar infraestructura como c√≥digo.

### Observabilidad extendida
- **Tracing distribuido**
	- Correlaci√≥n de peticiones con `ActivitySource`.
	- Visualizaci√≥n en Jaeger, Zipkin o Application Insights.
- **Alertas y dashboards**
	- M√©tricas exportadas con Prometheus .NET SDK.
	- Integraci√≥n con Grafana para observaci√≥n centralizada.

---

## 4. Seguridad avanzada

### Autenticaci√≥n y autorizaci√≥n
- **Claims-based Authentication** con `ClaimsPrincipal` y `ClaimsIdentity`.
- **Role-based Access Control (RBAC)** nativo en [ASP NET](/backend/asp-net/).
- **Policies** y **Requirements** para reglas complejas.
- **IdentityServer + Duende** para OAuth2/OpenID Connect completo.

### Cifrado, firma y secretos
- **Protecci√≥n de datos**
	- `DataProtectionProvider` integrado en ASP.NET.
	- Rotaci√≥n autom√°tica de claves.
- **Certificados y firma**
	- Creaci√≥n de X509 con `System.Security.Cryptography.X509Certificates`.
	- Validaci√≥n de firma y timestamp en documentos.
- **Secrets y credenciales**
	- `dotnet user-secrets` en desarrollo.
	- Azure Key Vault o AWS Secrets Manager en producci√≥n.

---

## 5. Testing distribuido, QA y performance

### Estrategias de pruebas
- **Pruebas de carga y estr√©s**
	- `NBomber`, `k6`, o `JMeter` con endpoints .NET.
- **Testcontainers.NET**
	- Ejecuci√≥n de bases de datos y colas en contenedores ef√≠meros para integraci√≥n realista.
- **Pact Testing**
	- Contratos Consumer-Driven entre servicios REST/gRPC.
- **Mutation Testing**
	- `Stryker.NET` para asegurar cobertura de l√≥gica.

### Benchmarking
- `BenchmarkDotNet` para microbenchmarking.
- `dotnet-trace` y `PerfView` para profiling detallado.
- `EventPipe` para an√°lisis de eventos runtime (GC, CPU, ThreadPool).

---

## 6. Cloud-native y Serverless

### Microservicios escalables
- Despliegue en Kubernetes:
	- Autoescalado horizontal con `HPA`.
	- ConfigMaps y Secrets para configuraci√≥n segura.
- **Service Mesh (Istio, Linkerd)**:
	- Tr√°fico seguro, m√©tricas y resiliencia a nivel red.
- **Event-driven con CloudEvents**:
	- Integraci√≥n nativa en Azure Event Grid o AWS EventBridge.

### Serverless
- **Azure Functions / AWS Lambda con .NET**
	- Cold start reducido con .NET AOT.
	- Integraci√≥n con colas, triggers y timers.
- **Durable Functions**
	- Workflow as code (sagas y orquestaciones distribuidas).

---

## 7. Inteligencia artificial, an√°lisis y automatizaci√≥n

### IA con .NET
- **ML.NET**
	- Entrenamiento y consumo de modelos ML sin depender de Python.
	- Clasificaci√≥n, regresi√≥n, detecci√≥n de anomal√≠as, recomendadores.
- **ONNX Runtime**
	- Ejecuci√≥n de modelos preentrenados (PyTorch, TensorFlow) en .NET.
- **Integraci√≥n con OpenAI, Hugging Face**
	- Consumo de APIs de IA desde .NET con clientes HTTP o SDKs oficiales.
- **AI + Office Automation**
	- Generaci√≥n autom√°tica de reportes Excel o Word integrando ML.NET + ClosedXML o Aspose.Cells for .NET.

---

## 8. Frontend y UX en el ecosistema .NET

### Blazor
- **Blazor Server**: renderizado en servidor v√≠a SignalR.
- **Blazor WASM**: ejecuci√≥n completa en navegador con WebAssembly.
- **Blazor Hybrid (MAUI)**: UI combinada web + nativa.
- **Componentizaci√≥n avanzada**
	- Reutilizaci√≥n entre proyectos.
	- Comunicaci√≥n por `EventCallback` y `CascadingParameter`.

### Integraci√≥n con frameworks externos
- **Angular, React, Vue**
	- API REST + JWT gestionado desde [ASP NET](/backend/asp-net/).
	- SSR h√≠brido (Angular Universal o React Static con .NET backend).
- **Interoperabilidad JS**
	- `IJSRuntime` y `JSObjectReference` en Blazor.

---

## 9. Ecosistema extendido

### Lenguajes soportados
- **C#**
	- Lenguaje principal, multiparadigma (OO, FP, asincron√≠a nativa).
- **F#**
	- Funcional puro, ideal para pipelines, data y testing.
- **VB.NET**
	- Mantenido para soporte legacy y entornos administrativos.
- **PowerShell**
	- Automatizaci√≥n avanzada y scripting con .NET Core Runtime.
- **C++/CLI**
	- Interoperabilidad directa con c√≥digo nativo.

### Frameworks especializados
- **Orleans**
	- Modelo actor distribuido para sistemas reactivos y escalables.
- **Akka.NET**
	- Implementaci√≥n de actores para concurrencia segura y resiliente.
- **MassTransit / Rebus**
	- Mensajer√≠a distribuida con sagas, retries, y middleware integrable.
- **GraphQL for .NET**
	- API declarativas con resolvers y esquemas tipados.

---

## 10. Ecosistema de productividad y automatizaci√≥n

### Generaci√≥n de documentaci√≥n
- `docfx` para portales t√©cnicos.
- `Swashbuckle` (Swagger/OpenAPI) para endpoints.
- `NSwag` para generar clientes TypeScript o C# desde APIs.

### Herramientas de mantenimiento
- **dotnet-format** para estilo y convenci√≥n.
- **Roslyn analyzers** y **StyleCop** para inspecci√≥n autom√°tica.
- **Dependabot** o **Renovate** para actualizar dependencias.

### Automatizaci√≥n interna
- **Code Generators y Templates**
	- `dotnet new --install` para scaffolding personalizado.
	- Integraci√≥n con `T4` y Source Generators para boilerplate.
- **Builds reproducibles**
	- MSBuild y YAML pipelines con versiones fijadas.
	- Cach√© de dependencias y artefactos con `nuget.config`.

---

## 11. Temas para expansi√≥n futura
- IA generativa e integraci√≥n con ML.NET y ONNX
- Arquitecturas distribuidas orientadas a eventos
- Interoperabilidad avanzada con Rust y WebAssembly
- Automatizaci√≥n y scripting con PowerShell y .NET CLI
- Dise√±o de SDKs empresariales y clientes gRPC internos
- Estrategias de resiliencia y escalado din√°mico en Kubernetes
- Sistemas actor con Orleans y Akka.NET
- Integraci√≥n avanzada de .NET con Big Data y Spark
- Ejecuci√≥n AOT y compilaci√≥n cruzada para IoT y edge computing

# üß† .NET Programming CheatSheet  

## ‚öôÔ∏è Comandos b√°sicos CLI
{% raw %}
```bash
# Crear proyecto
dotnet new console -n MiApp  
dotnet new webapi -n MiApi  
dotnet new maui -n MiAppMaui  

# Ejecutar y compilar
dotnet run  
dotnet build  
dotnet watch run  

# Gestionar dependencias
dotnet add package Newtonsoft.Json  
dotnet restore  

# Testing
dotnet test  

# Publicar (para Docker o servidor)
dotnet publish -c Release -r linux-x64  
```
{% endraw %}`

---

## üß© Estructura t√≠pica de un proyecto .NET

{% raw %}
```
/MiProyecto
	/Controllers
	/Models
	/Services
	/Data
	wwwroot/
	appsettings.json
	Program.cs
```
{% endraw %}

---

## üß± Sintaxis esencial C#

{% raw %}
```csharp
// Variables y tipos
int edad = 30;
string nombre = "Edu";
bool activo = true;

// Condicionales
if (edad > 18) Console.WriteLine("Adulto");
else Console.WriteLine("Menor");

// Bucles
for (int i = 0; i < 10; i++) Console.WriteLine(i);
foreach (var item in lista) Console.WriteLine(item);

// M√©todos
int Sumar(int a, int b) => a + b;

// Clases y objetos
public class Persona
{
	public string Nombre { get; set; }
	public void Saludar() => Console.WriteLine($"Hola, soy {Nombre}");
}
```
{% endraw %}

---

## üß† Funcional y LINQ

{% raw %}
```csharp
var numeros = new List<int> {1,2,3,4,5};
var pares = numeros.Where(n => n % 2 == 0)
                   .Select(n => n * 10)
                   .ToList();

int suma = numeros.Aggregate((a,b) => a + b);
```
{% endraw %}

---

## üóÇÔ∏è Archivos y JSON

{% raw %}
```csharp
using System.IO;
using System.Text.Json;

var texto = File.ReadAllText("data.txt");
var objeto = JsonSerializer.Deserialize<MiClase>(texto);
File.WriteAllText("salida.json", JsonSerializer.Serialize(objeto));
```
{% endraw %}

---

## üíâ Dependency Injection

{% raw %}
```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddScoped<IUserService, UserService>();
var app = builder.Build();

app.MapGet("/users", (IUserService service) => service.GetAll());
app.Run();
```
{% endraw %}

---

## üåê Minimal API

{% raw %}
```csharp
var app = WebApplication.Create();
app.MapGet("/", () => "Hello .NET!");
app.MapPost("/echo", (string msg) => $"Echo: {msg}");
app.Run();
```
{% endraw %}

---

## üß± Entity Framework Core

{% raw %}
```csharp
public class AppDbContext : DbContext
{
	public DbSet<User> Users { get; set; }
}

public class User { public int Id { get; set; } public string Name { get; set; } }
```
{% endraw %}

**Migraciones y base de datos**

{% raw %}
```bash
dotnet ef migrations add Init  
dotnet ef database update
```
{% endraw %}

**Consulta b√°sica**

{% raw %}
```csharp
using var db = new AppDbContext();
var users = db.Users.Where(u => u.Name.Contains("Ana")).ToList();
```
{% endraw %}

---

## üß∞ Testing con xUnit

{% raw %}
```csharp
public class CalculatorTests
{
	[Fact]
	public void Add_ReturnsCorrectSum()
	{
		Assert.Equal(4, new Calculator().Add(2,2));
	}
}
```
{% endraw %}

---

## ‚ö° Asincron√≠a y tareas

{% raw %}
```csharp
async Task DescargarAsync()
{
	var http = new HttpClient();
	var data = await http.GetStringAsync("https://api.example.com");
	Console.WriteLine(data);
}
```
{% endraw %}

---

## üîÑ Manejo de errores

{% raw %}
```csharp
try
{
	var result = 10 / 0;
}
catch (DivideByZeroException ex)
{
	Console.WriteLine(ex.Message);
}
finally
{
	Console.WriteLine("Finalizado");
}
```
{% endraw %}

---

## üê≥ Docker + .NET

{% raw %}
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
COPY . .
ENTRYPOINT ["dotnet", "MiApp.dll"]
```
{% endraw %}

{% raw %}
```bash
docker build -t miappnet .
docker run -p 8080:80 miappnet
```
{% endraw %}

---

## üîê Autenticaci√≥n b√°sica con JWT

{% raw %}
```csharp
builder.Services.AddAuthentication("Bearer")
	.AddJwtBearer(options =>
	{
		options.TokenValidationParameters = new()
		{
			ValidateIssuer = true,
			ValidIssuer = "miapp",
			ValidateAudience = false,
			IssuerSigningKey = new SymmetricSecurityKey(
				Encoding.UTF8.GetBytes("clave-secreta-super-segura"))
		};
	});
```
{% endraw %}

---

## üßæ Logging y configuraci√≥n

{% raw %}
```csharp
builder.Logging.ClearProviders();
builder.Logging.AddConsole();

var config = builder.Configuration;
string conn = config.GetConnectionString("DefaultConnection");
```
{% endraw %}

---

## üì¶ Serializaci√≥n y utilidades

{% raw %}
```csharp
var json = JsonSerializer.Serialize(objeto, new JsonSerializerOptions { WriteIndented = true });
var anon = new { Id = 1, Nombre = "Edu" };
```
{% endraw %}

---

## üß≠ Recursos √∫tiles

* [ASP NET](/backend/asp-net/)
* [MAUI NET](/desarrollo%20multiplataforma/maui-net/)
* [xamarin](/desarrollo%20multiplataforma/xamarin/)
* [Docker](/software%20engineering/docker/)
* Entity Framework Core
* Csharp
* [visual basic VBA](/software%20engineering/visual-basic-vba/)
* ClosedXML
* [Sistemas](/sistemas/sistemas/)
* Clean Architecture
* CQRS y Event Sourcing con .NET
* Saga Pattern y transacciones distribuidas

# üß† .NET Programming CheatSheet II ‚Äî Avanzado  

## üß© Arquitectura avanzada
- **Clean Architecture (ampliado)**
	- Capas principales:
		- *Domain*: entidades, value objects, eventos de dominio.
		- *Application*: l√≥gica de negocio, casos de uso, servicios.
		- *Infrastructure*: acceso a datos, servicios externos.
		- *Presentation*: API, UI o endpoints.
	- Reglas: las dependencias siempre apuntan hacia el dominio.

- **CQRS y MediatR**
	- Separaci√≥n de comandos y consultas.
	- `IRequest<T>` y `IRequestHandler<TRequest, TResponse>`.
	- Ideal con `MediatR` para inyecci√≥n autom√°tica de handlers.
{% raw %}
```csharp
public record GetUsersQuery() : IRequest<IEnumerable<User>>;

public class GetUsersHandler : IRequestHandler<GetUsersQuery, IEnumerable<User>>
{
	private readonly AppDbContext _db;
	public GetUsersHandler(AppDbContext db) => _db = db;

	public async Task<IEnumerable<User>> Handle(GetUsersQuery request, CancellationToken ct)
		=> await _db.Users.ToListAsync(ct);
}
```
{% endraw %}`

---

## ü™∂ Reflection y metaprogramaci√≥n

{% raw %}
```csharp
var type = typeof(User);
foreach (var prop in type.GetProperties())
	Console.WriteLine($"{prop.Name} : {prop.PropertyType}");
```
{% endraw %}

* **Use cases:**

  * Serializaci√≥n personalizada.
  * Mapping din√°mico entre DTOs.
  * Creaci√≥n de plug-ins y carga de ensamblados en tiempo de ejecuci√≥n (`Assembly.LoadFrom()`).

---

## üßµ Programaci√≥n concurrente

{% raw %}
```csharp
Parallel.For(0, 10, i => Console.WriteLine(i));
await Task.WhenAll(
	DownloadAsync("a"), 
	DownloadAsync("b")
);
```
{% endraw %}

* **TPL (Task Parallel Library)** para paralelismo de alto nivel.
* **Concurrent collections**: `ConcurrentDictionary`, `BlockingCollection`.
* **Channels** para pipelines y colas internas (`System.Threading.Channels`).

---

## üåê gRPC y comunicaci√≥n entre servicios

* **gRPC**: protocolo binario de alta eficiencia entre microservicios.
* Definir `.proto`:

{% raw %}
```proto
service UserService {
	rpc GetUser (UserRequest) returns (UserReply);
}
```
{% endraw %}

* Generar c√≥digo con `Grpc.Tools`.
* Ideal para comunicaci√≥n entre servicios .NET o entre lenguajes.

---

## üï∏Ô∏è SignalR ‚Äî comunicaci√≥n en tiempo real

{% raw %}
```csharp
app.MapHub<ChatHub>("/chat");
```
{% endraw %}

* Permite comunicaci√≥n bidireccional en webs y apps MAUI.
* Escenarios: chats, dashboards, actualizaciones en vivo.
* Compatible con WebSockets, SSE y Long Polling.

---

## üì° Integraci√≥n con APIs externas

{% raw %}
```csharp
var client = new HttpClient();
client.DefaultRequestHeaders.Add("Authorization", "Bearer token");
var data = await client.GetFromJsonAsync<Usuario>("https://api.miapp.com/users/1");
```
{% endraw %}

* **Typed Clients**: inyecci√≥n nativa en DI.
* **Polly**: pol√≠ticas de resiliencia (reintentos, circuit breakers).

---

## üß∞ Logging avanzado

* **Serilog**

  * En `Program.cs`:

  {% raw %}
```csharp
  Log.Logger = new LoggerConfiguration()
  	.WriteTo.Console()
  	.WriteTo.File("logs/log-.txt", rollingInterval: RollingInterval.Day)
  	.CreateLogger();
  ```
{% endraw %}
* **Enriquecedores** para incluir contexto (usuario, requestId).
* **Seq** o **Grafana Loki** para visualizar logs distribuidos.

---

## üßÆ Background Services y Hosted Workers

{% raw %}
```csharp
public class Worker : BackgroundService
{
	protected override async Task ExecuteAsync(CancellationToken ct)
	{
		while (!ct.IsCancellationRequested)
		{
			Console.WriteLine("Running task...");
			await Task.Delay(1000, ct);
		}
	}
}
```
{% endraw %}

* Ideal para tareas programadas o listeners de colas.
* Reg√≠stralos con `builder.Services.AddHostedService<Worker>();`.

---

## üíæ Caching y rendimiento

* **IMemoryCache** para cach√© en memoria local.
* **DistributedCache** con Redis.

{% raw %}
```csharp
builder.Services.AddStackExchangeRedisCache(options =>
	options.Configuration = "localhost:6379");
```
{% endraw %}

* Uso de `OutputCache` en endpoints para optimizaci√≥n de respuestas.
* Profiling con `dotnet-trace`, `dotnet-counters`, `PerfView`.

---

## üß± Integraci√≥n con bases de datos NoSQL

* **MongoDB**

  {% raw %}
```csharp
  var client = new MongoClient("mongodb://localhost:27017");
  var db = client.GetDatabase("test");
  var users = db.GetCollection<User>("Users");
  await users.InsertOneAsync(new User { Name = "Ana" });
  ```
{% endraw %}
* **CosmosDB (Azure)** con SDK oficial.
* **LiteDB** para persistencia embebida en aplicaciones locales.

---

## üîê Seguridad avanzada

* **Data Protection API**

  {% raw %}
```csharp
  var provider = DataProtectionProvider.Create("MiApp");
  var protector = provider.CreateProtector("Credenciales");
  var encriptado = protector.Protect("clave");
  ```
{% endraw %}
* **Autorizaci√≥n basada en pol√≠ticas**

  * `[Authorize(Policy = "AdminOnly")]`
  * `builder.Services.AddAuthorization(o => o.AddPolicy("AdminOnly", p => p.RequireRole("Admin")));`
* **Rate Limiting Middleware**

  {% raw %}
```csharp
  builder.Services.AddRateLimiter(_ => _.AddFixedWindowLimiter("default",
  	options => { options.PermitLimit = 5; options.Window = TimeSpan.FromSeconds(10); }));
  ```
{% endraw %}

---

## üß© Modularidad y plugins din√°micos

* Cargar ensamblados externos:

{% raw %}
```csharp
var asm = Assembly.LoadFrom("MiPlugin.dll");
var type = asm.GetType("MiPlugin.Plugin");
dynamic instance = Activator.CreateInstance(type);
instance.Run();
```
{% endraw %}

* √ötil para aplicaciones extensibles o sistemas de scripts.

---

## ‚öôÔ∏è Interoperabilidad nativa

* **C++/CLI y P/Invoke**

  {% raw %}
```csharp
  [DllImport("kernel32.dll")]
  static extern bool Beep(int freq, int dur);
  ```
{% endraw %}
* Comunicaci√≥n con [cpp](/software%20engineering/cpp/) y librer√≠as nativas.
* [Rust](/desarrollo%20multiplataforma/rust/) o Python interoperables mediante procesos externos o bindings.

---

## üß± Publicaci√≥n y despliegue

{% raw %}
```bash
dotnet publish -c Release -r win-x64 --self-contained true
```
{% endraw %}

* **Opciones:**

  * `--self-contained`: incluye el runtime.
  * `-p:PublishSingleFile=true`: genera un √∫nico ejecutable.
  * `-p:PublishTrimmed=true`: elimina dependencias no usadas.
* Despliegue en [Docker](/software%20engineering/docker/), [Azure](/cloud/azure/), AWS Lambda o [Kubernetes](/virtualizacion/kubernetes/).

---

## üì¶ NuGet y distribuci√≥n

{% raw %}
```bash
dotnet pack -c Release
dotnet nuget push bin/Release/MiLib.1.0.0.nupkg -k API_KEY -s https://api.nuget.org/v3/index.json
```
{% endraw %}

* Crear librer√≠as reutilizables internas.
* Usar `Directory.Build.props` para configuraci√≥n global.

---

## üß≠ Temas adicionales a explorar

* Source Generators en .NET
* Roslyn Analyzers personalizados
* Performance Tuning con Span y Memory
* .NET AOT y Native Compilation
* Dynamic LINQ y Expression Trees
* Testing distribuido y contenedores de prueba
* Integraci√≥n avanzada con Azure Functions y Service Bus

# üöÄ Tendencias .NET 2025  

## üåç Visi√≥n general
El ecosistema **.NET en 2025** refleja un salto hacia la **eficiencia, la inteligencia y la unificaci√≥n** del desarrollo multiplataforma. Las tendencias actuales combinan rendimiento nativo, IA integrada, seguridad avanzada y desarrollo orientado al *edge computing*.  
Esta gu√≠a sintetiza las l√≠neas m√°s relevantes sin repetir notas previas, enfoc√°ndose en evoluci√≥n, herramientas y estrategias para adoptar estas tendencias.

---

## ‚öôÔ∏è 1. Compilaci√≥n AOT (Ahead-of-Time) y rendimiento extremo
- **NativeAOT** consolida la tendencia hacia ejecutables nativos sin dependencia del runtime.  
	- Ideal para **microservicios, apps serverless y entornos edge**.  
	- Reduce *startup time*, consumo de memoria y tama√±o del despliegue.  
- **AOT h√≠brido** combina rendimiento nativo con depuraci√≥n JIT cuando se necesita.  
- Herramientas: `dotnet publish -p:PublishAot=true`, `dotnet-native`.  
- Se integra con optimizaciones como `TrimMode=link` para eliminar c√≥digo no usado.

üìé Ver tambi√©n: .NET AOT y Native Compilation ¬∑ Performance Tuning con Span y Memory

---

## üíª 2. Desarrollo multiplataforma unificado
- **.NET MAUI** madura como framework completo para **m√≥vil, escritorio y web h√≠brido**.  
- **Blazor Hybrid** permite compartir l√≥gica entre UI y backend sin JavaScript.  
- **Visual Studio 2025** integra plantillas unificadas que soportan web + MAUI + gRPC.  
- Se consolida la tendencia **Full-Stack .NET**: un solo lenguaje (C#) para todo el ciclo.

üìé Relacionado: [MAUI NET](/desarrollo%20multiplataforma/maui-net/) ¬∑ Blazor ¬∑ [xamarin](/desarrollo%20multiplataforma/xamarin/)

---

## üß† 3. Integraci√≥n con IA y Machine Learning
- **ML.NET 3.0** ampl√≠a soporte para modelos ONNX y PyTorch.  
- Nuevas APIs simplifican el uso de IA generativa en .NET (Azure OpenAI, Hugging Face).  
- Integraci√≥n natural con **.NET Aspire**, el stack para *intelligent cloud-native apps*.  
- Tendencia: ‚Äú*AI-embedded apps*‚Äù, donde la IA forma parte de la l√≥gica de negocio.

Ejemplo:
{% raw %}
```csharp
var prediction = mlModel.Predict(new InputData { Text = "Consulta del usuario" });
```
{% endraw %}`

üìé Ver tambi√©n: Integraci√≥n IA en .NET ¬∑ Azure Cognitive Services

---

## ‚òÅÔ∏è 4. Arquitecturas cloud-native y microservicios

* .NET se orienta a√∫n m√°s al **entorno nativo en la nube**:

  * Integraci√≥n directa con **Kubernetes**, **Dapr**, y **Azure Container Apps**.
  * Soporte AOT en im√°genes base de **mcr.microsoft.com/dotnet/aspnet:9.0**.
* Patrones dominantes:

  * **Event-driven architecture**.
  * **Saga Pattern** y **Outbox Pattern** para consistencia distribuida.
* Se priorizan despliegues ligeros con observabilidad integrada (OpenTelemetry).

üìé Ver: Saga Pattern y transacciones distribuidas ¬∑ [Docker](/software%20engineering/docker/) ¬∑ [Kubernetes](/virtualizacion/kubernetes/)

---

## üß© 5. Seguridad avanzada y cumplimiento

* **Zero Trust y autenticaci√≥n federada** son el nuevo est√°ndar.
* .NET refuerza seguridad de APIs mediante:

  * `Microsoft.Identity.Web` con Azure AD.
  * Pol√≠ticas de autorizaci√≥n personalizables y claims din√°micos.
* **Supply Chain Security**:

  * Verificaci√≥n de paquetes con firmas (`dotnet nuget verify`).
  * Escaneo de dependencias (`dotnet list package --vulnerable`).

üìé Referencias: Autenticaci√≥n y seguridad ¬∑ Identity Server

---

## üß∞ 6. Productividad y experiencia del desarrollador (DX)

* **Hot Reload mejorado** y *scaffolding din√°mico*.
* **C# 13** introduce nuevas construcciones:

  * *Primary constructors for classes*.
  * *Discriminated unions*.
  * *Collection expressions* simplificadas.
* **.NET Aspire** ofrece entornos locales reproducibles con dashboards y telemetr√≠a nativa.
* Mayor integraci√≥n entre CLI y DevOps:
  `dotnet new webapi --use-serilog --use-swagger`

üìé Relacionado: CI CD ¬∑ Roslyn Analyzers personalizados

---

## üîã 7. Sostenibilidad y eficiencia operativa

* Prioridad a reducir **coste en la nube y huella energ√©tica**.
* AOT, pooling de conexiones y GC adaptativo reducen consumo.
* Surgen herramientas como **GreenOps Analyzer** para medir impacto energ√©tico.
* KPI emergente: *Watts per Request (WPR)*.

üìé Ver: Optimizaci√≥n y profiling .NET ¬∑ Performance Tuning con Span y Memory

---

## üß± 8. Edge computing e IoT inteligente

* Expansi√≥n de .NET hacia dispositivos y entornos desconectados.
* **.NET nanoFramework** y **.NET for IoT** soportan microcontroladores ARM.
* **Azure IoT Edge + .NET 9 AOT** permite despliegues ligeros y seguros en dispositivos industriales.
* Integraci√≥n con sensores, actuadores y servicios cloud.

üìé Ver: IoT con .NET ¬∑ Integraci√≥n con hardware y serial ports

---

## üéÆ 9. .NET en nuevos dominios: juegos, XR y simulaci√≥n

* Integraci√≥n creciente con motores de juego como **Godot 4 C#** y **Stride Engine**.
* Se fomenta el uso de .NET para **realidad aumentada (AR/XR)** con **MAUI + Unity Bridge**.
* En simulaciones industriales, .NET se usa junto con **Blazor WebGPU** y **ComputeSharp**.
* Extiende el alcance de C# a mundos antes reservados a C++.

üìé Referencias: [cpp](/software%20engineering/cpp/) ¬∑ ComputeSharp ¬∑ Shaders en .NET

---

## üîÆ 10. Nuevos horizontes: metaprogramaci√≥n, an√°lisis y generaci√≥n de c√≥digo

* **Source Generators 3.0** permiten generar c√≥digo de alto rendimiento durante la compilaci√≥n.
* **Roslyn Analyzers** evolucionan para aplicar *linting* din√°mico, refactors autom√°ticos y *code fixes* asistidos por IA.
* Surgen frameworks como **DotNetGen** para crear SDKs internos basados en plantillas.

üìé Ver: Source Generators en .NET ¬∑ [[Reflexi√≥n y metaprogramaci√≥n en C#]]

---

## üß≠ Conclusi√≥n

El .NET de 2025 consolida su madurez empresarial y su expansi√≥n a nuevas √°reas: **inteligencia, rendimiento, sostenibilidad y unificaci√≥n multiplataforma**.
Los equipos que adopten estas tendencias lograr√°n software m√°s r√°pido, seguro y preparado para el futuro.
La clave no est√° solo en usar .NET, sino en **dise√±ar con visi√≥n cloud-native, IA-embedded y sostenibilidad desde el inicio**.

üìé Siguientes notas:

* Arquitectura Cloud-Native con .NET
* AOT y rendimiento extremo en microservicios
* IA aplicada en .NET con ML.NET y Cognitive Services
* Zero Trust y seguridad avanzada en ASP.NET Core
* .NET 9 ‚Äî Cambios de lenguaje y nuevas APIs





# üî•üî•üî• MODULOS PRACTICOS net 9

--- 
# üß± M√≥dulo 1 ‚Äì Entorno Productivo Moderno .NET 9 (2025)

---

## üéØ Objetivo
Configurar un **entorno de desarrollo .NET 9 moderno**, estable y preparado para **proyectos reales**, con tooling actualizado, productividad, testing y despliegue.

---

## üß∞ Requisitos previos

- üß© **SDK:** [.NET 9 SDK](https://dotnet.microsoft.com/download/dotnet/9.0)  
- üß† **IDE:** Visual Studio 2022 / JetBrains Rider / VS Code  
- üê≥ **Docker Desktop** (para contenedores)  
- üîç **Postman** o **HTTPie** (para probar APIs)  
- üßæ **Git** y **GitHub CLI (`gh`)**  

---

## üèóÔ∏è Creaci√≥n de un entorno base

{% raw %}
```bash
# Crear una carpeta ra√≠z para proyectos .NET
mkdir ~/Projects/dotnet2025
cd ~/Projects/dotnet2025

# Inicializar repositorio
git init
dotnet new globaljson --sdk-version 9.0.100
dotnet --info
```
{% endraw %}`

---

## üß© Estructura recomendada para proyectos reales

{% raw %}
```
/src
	/MyApp.Api
	/MyApp.Application
	/MyApp.Domain
	/MyApp.Infrastructure
/tests
	/MyApp.Tests
```
{% endraw %}

> üß≠ Mant√©n la estructura modular desde el inicio.
> Evita mezclar controladores, entidades y l√≥gica en un mismo proyecto.

---

## ü™Ñ Crear la base API limpia

{% raw %}
```bash
dotnet new webapi -n MyApp.Api
cd MyApp.Api
dotnet run
```
{% endraw %}

üëâ Accede a: [https://localhost:5001/swagger](https://localhost:5001/swagger)

---

## ‚öôÔ∏è Configuraci√≥n esencial

**Program.cs**

{% raw %}
```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
	app.UseSwagger();
	app.UseSwaggerUI();
}

app.MapControllers();
app.Run();
```
{% endraw %}

> ‚úÖ Mant√©n este `Program.cs` minimalista; luego a√±adiremos capas y DI real.

---

## üß± A√±adir herramientas de productividad

{% raw %}
```bash
dotnet tool install -g dotnet-ef
dotnet tool install -g dotnet-outdated-tool
dotnet tool install -g dotnet-format
dotnet tool install -g dotnet-watch
```
{% endraw %}

### Verificaci√≥n

{% raw %}
```bash
dotnet ef --version
dotnet format --check
dotnet watch run
```
{% endraw %}

---

## üîç Linter, Analyzer y estilo de c√≥digo

1. **Agrega archivo `.editorconfig` en la ra√≠z:**

{% raw %}
```ini
[*.cs]
indent_size = 4
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_predefined_type_for_locals_parameters_members = true:suggestion
dotnet_style_null_propagation = true:suggestion
```
{% endraw %}

2. **Activa Analyzers:**

{% raw %}
```bash
dotnet new editorconfig
dotnet build -warnaserror
```
{% endraw %}

---

## üß© Configuraci√≥n de GitHub y CI inicial

{% raw %}
```bash
gh repo create myapp-dotnet --public
git add .
git commit -m "chore: init .NET 9 project"
git push -u origin main
```
{% endraw %}

### Ejemplo b√°sico de workflow CI (.github/workflows/build.yml)

{% raw %}
```yaml
name: .NET Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - run: dotnet restore
      - run: dotnet build --no-restore
      - run: dotnet test --no-build --verbosity normal
```
{% endraw %}

---

## üß† Buenas pr√°cticas iniciales

* Usa nombres de proyectos y namespaces coherentes (ej. `Company.Product.Layer`).
* Commits sem√°nticos: `feat:`, `fix:`, `chore:`, `test:`, `refactor:`.
* Automatiza `dotnet restore`, `format`, y `test` en CI antes del merge.

---

## ‚úÖ Resultado esperado

‚úîÔ∏è Entorno moderno listo
‚úîÔ∏è Proyecto API ejecut√°ndose en .NET 9
‚úîÔ∏è GitHub + CI funcional
‚úîÔ∏è Herramientas instaladas para productividad

---



# ‚ö° M√≥dulo 2 ‚Äì API REST limpia desde cero (ASP.NET Core 9)


## üéØ Objetivo
Construir una **API REST limpia, modular y mantenible**, aplicando buenas pr√°cticas modernas de .NET 9, con capas separadas, validaciones y un ejemplo funcional completo.

---

## üèóÔ∏è Estructura del proyecto

En la ra√≠z de tu workspace:
{% raw %}
```bash
cd src
dotnet new webapi -n MyApp.Api
dotnet new classlib -n MyApp.Application
dotnet new classlib -n MyApp.Domain
dotnet new classlib -n MyApp.Infrastructure
```
{% endraw %}`

Vincula las referencias:

{% raw %}
```bash
cd MyApp.Api
dotnet add reference ../MyApp.Application
dotnet add reference ../MyApp.Domain
dotnet add reference ../MyApp.Infrastructure
```
{% endraw %}

Estructura:

{% raw %}
```
/src
	/MyApp.Api
		/Controllers
		MyApp.Api.csproj
	/MyApp.Application
		/Services
	/MyApp.Domain
		/Entities
	/MyApp.Infrastructure
		/Data
```
{% endraw %}

---

## üß© Dominio: entidad base y ejemplo

**MyApp.Domain/Entities/Product.cs**

{% raw %}
```csharp
namespace MyApp.Domain.Entities;

public class Product
{
	public Guid Id { get; set; } = Guid.NewGuid();
	public required string Name { get; set; }
	public decimal Price { get; set; }
	public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```
{% endraw %}

---

## üß† Capa de aplicaci√≥n

**MyApp.Application/Services/ProductService.cs**

{% raw %}
```csharp
using MyApp.Domain.Entities;

namespace MyApp.Application.Services;

public interface IProductService
{
	IEnumerable<Product> GetAll();
	Product Add(Product product);
}

public class ProductService : IProductService
{
	private readonly List<Product> _products = [];

	public IEnumerable<Product> GetAll() => _products;

	public Product Add(Product product)
	{
		_products.Add(product);
		return product;
	}
}
```
{% endraw %}

---

## üåê API ‚Äì Controlador principal

**MyApp.Api/Controllers/ProductController.cs**

{% raw %}
```csharp
using Microsoft.AspNetCore.Mvc;
using MyApp.Application.Services;
using MyApp.Domain.Entities;

namespace MyApp.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ProductController : ControllerBase
{
	private readonly IProductService _service;

	public ProductController(IProductService service)
	{
		_service = service;
	}

	[HttpGet]
	public IActionResult GetAll() => Ok(_service.GetAll());

	[HttpPost]
	public IActionResult Create([FromBody] Product product)
	{
		if (string.IsNullOrWhiteSpace(product.Name) || product.Price <= 0)
			return BadRequest("Invalid product data.");

		var created = _service.Add(product);
		return CreatedAtAction(nameof(GetAll), new { id = created.Id }, created);
	}
}
```
{% endraw %}

---

## ‚öôÔ∏è Inyecci√≥n de dependencias

**MyApp.Api/Program.cs**

{% raw %}
```csharp
using MyApp.Application.Services;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// DI
builder.Services.AddSingleton<IProductService, ProductService>();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
	app.UseSwagger();
	app.UseSwaggerUI();
}

app.MapControllers();
app.Run();
```
{% endraw %}

---

## üîç Pruebas r√°pidas con cURL o HTTPie

{% raw %}
```bash
# Obtener todos los productos
http GET https://localhost:5001/api/product

# Crear nuevo producto
http POST https://localhost:5001/api/product name="Teclado" price:=49.99
```
{% endraw %}

---

## üß™ A√±adir primer test (opcional)

**tests/MyApp.Tests/ProductServiceTests.cs**

{% raw %}
```csharp
using MyApp.Application.Services;
using MyApp.Domain.Entities;
using Xunit;

public class ProductServiceTests
{
	[Fact]
	public void Add_ShouldReturnProduct()
	{
		var service = new ProductService();
		var product = new Product { Name = "Mouse", Price = 25 };

		var result = service.Add(product);

		Assert.Equal("Mouse", result.Name);
		Assert.True(result.Id != Guid.Empty);
	}
}
```
{% endraw %}

Ejecuta:

{% raw %}
```bash
dotnet test
```
{% endraw %}

---

## üß± Buenas pr√°cticas

* Mant√©n **la l√≥gica en la capa Application** y el **estado persistente** (DB) en Infrastructure.
* Usa **DTOs o Records** para los datos de entrada/salida (los agregaremos en el siguiente m√≥dulo).
* No dependas de EF Core a√∫n ‚Äî usa servicios o repositorios abstractos.

---

## ‚úÖ Resultado esperado

‚úîÔ∏è API funcional y modular
‚úîÔ∏è Controlador REST limpio
‚úîÔ∏è L√≥gica separada por capas
‚úîÔ∏è Inyecci√≥n de dependencias configurada
‚úîÔ∏è Primer test ejecutable

---

# üóÑÔ∏è M√≥dulo 3 ‚Äì Persistencia con EF Core 9 y SQLite

---

## üéØ Objetivo
Integrar **Entity Framework Core 9** en la capa `Infrastructure`, crear una base de datos **SQLite**, y conectar los servicios del dominio con persistencia real.

---

## üß© Instalaci√≥n de paquetes

Desde la ra√≠z del proyecto:

{% raw %}
```bash
cd src/MyApp.Infrastructure
dotnet add package Microsoft.EntityFrameworkCore --version 9.*
dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 9.*
dotnet add package Microsoft.EntityFrameworkCore.Tools --version 9.*

cd ../MyApp.Api
dotnet add package Microsoft.EntityFrameworkCore.Design --version 9.*
```
{% endraw %}`

---

## üß± Contexto de datos

**MyApp.Infrastructure/Data/AppDbContext.cs**

{% raw %}
```csharp
using Microsoft.EntityFrameworkCore;
using MyApp.Domain.Entities;

namespace MyApp.Infrastructure.Data;

public class AppDbContext : DbContext
{
	public DbSet<Product> Products => Set<Product>();

	public AppDbContext(DbContextOptions<AppDbContext> options)
		: base(options) { }

	protected override void OnModelCreating(ModelBuilder modelBuilder)
	{
		modelBuilder.Entity<Product>(entity =>
		{
			entity.HasKey(p => p.Id);
			entity.Property(p => p.Name)
				.IsRequired()
				.HasMaxLength(100);
			entity.Property(p => p.Price)
				.HasPrecision(10, 2);
		});
	}
}
```
{% endraw %}

---

## üß† Configurar EF Core en el API

**MyApp.Api/Program.cs**

{% raw %}
```csharp
using Microsoft.EntityFrameworkCore;
using MyApp.Infrastructure.Data;
using MyApp.Application.Services;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// EF Core + SQLite
builder.Services.AddDbContext<AppDbContext>(options =>
	options.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection")));

// DI Services
builder.Services.AddScoped<IProductService, ProductService>();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
	app.UseSwagger();
	app.UseSwaggerUI();
}

app.MapControllers();
app.Run();
```
{% endraw %}

---

## ‚öôÔ∏è Configuraci√≥n de conexi√≥n

**MyApp.Api/appsettings.json**

{% raw %}
```json
{
	"ConnectionStrings": {
		"DefaultConnection": "Data Source=../MyApp.Infrastructure/app.db"
	},
	"Logging": {
		"LogLevel": {
			"Default": "Information",
			"Microsoft": "Warning"
		}
	},
	"AllowedHosts": "*"
}
```
{% endraw %}

---

## üß© Adaptar ProductService a persistencia real

**MyApp.Application/Services/ProductService.cs**

{% raw %}
```csharp
using MyApp.Domain.Entities;
using MyApp.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

namespace MyApp.Application.Services;

public class ProductService : IProductService
{
	private readonly AppDbContext _context;

	public ProductService(AppDbContext context)
	{
		_context = context;
	}

	public IEnumerable<Product> GetAll()
	{
		return _context.Products.AsNoTracking().ToList();
	}

	public Product Add(Product product)
	{
		_context.Products.Add(product);
		_context.SaveChanges();
		return product;
	}
}
```
{% endraw %}

---

## üîß Crear y aplicar migraciones

{% raw %}
```bash
cd src/MyApp.Api
dotnet ef migrations add InitialCreate --project ../MyApp.Infrastructure --startup-project .
dotnet ef database update
```
{% endraw %}

üí° EF Core generar√° autom√°ticamente `app.db` en `MyApp.Infrastructure/`.

---

## üß© Verificar persistencia

Ejecuta el proyecto:

{% raw %}
```bash
dotnet run --project src/MyApp.Api
```
{% endraw %}

Luego prueba:

{% raw %}
```bash
# Crear productos
http POST https://localhost:5001/api/product name="Monitor" price:=199.99
http POST https://localhost:5001/api/product name="Mouse" price:=35.00

# Listar productos
http GET https://localhost:5001/api/product
```
{% endraw %}

Deber√≠as ver la lista persistida en `app.db`.

---

## üîç Visualizar base de datos

Puedes inspeccionar la base de datos SQLite con:

* üîß **DB Browser for SQLite**
* üß± **VS Code extension:** *SQLite Viewer*
  (`Ctrl+Shift+P ‚Üí SQLite: Open Database`)

---

## üßæ Buenas pr√°cticas

* **No usar `SaveChanges()` dentro de bucles.** Usa transacciones si modificas m√∫ltiples entidades.
* **AsNoTracking()** para lecturas r√°pidas.
* **Migrations en el proyecto de infraestructura**, nunca en la API directamente.
* **Context por request** (`AddDbContext`), no singleton.

---

## üß© Extensi√≥n: m√©todos as√≠ncronos

Actualiza el servicio a versi√≥n async:

{% raw %}
```csharp
public async Task<IEnumerable<Product>> GetAllAsync()
	=> await _context.Products.AsNoTracking().ToListAsync();

public async Task<Product> AddAsync(Product product)
{
	_context.Products.Add(product);
	await _context.SaveChangesAsync();
	return product;
}
```
{% endraw %}

Y cambia los controladores a `async Task<IActionResult>`.

---

## ‚úÖ Resultado esperado

‚úîÔ∏è Base de datos SQLite real
‚úîÔ∏è Persistencia funcional con EF Core 9
‚úîÔ∏è Migraciones creadas y aplicadas
‚úîÔ∏è Servicio adaptado a DB
‚úîÔ∏è Lectura y escritura verificadas

---

# üß™ M√≥dulo 4 ‚Äì Testing integral con xUnit y WebApplicationFactory (.NET 9)



## üéØ Objetivo
Probar **la API completa** con peticiones HTTP simuladas, base de datos en memoria y configuraci√≥n autom√°tica del entorno de test.  
Aprender√°s a crear un entorno reproducible que valida controladores, servicios y configuraci√≥n de dependencias.

---

## üß∞ Dependencias necesarias

Desde la ra√≠z del proyecto:

{% raw %}
```bash
cd tests
dotnet new xunit -n MyApp.Tests
cd MyApp.Tests

dotnet add reference ../src/MyApp.Api
dotnet add package Microsoft.AspNetCore.Mvc.Testing --version 9.*
dotnet add package Microsoft.EntityFrameworkCore.InMemory --version 9.*
dotnet add package Microsoft.NET.Test.Sdk --version 17.*
dotnet add package coverlet.collector
```
{% endraw %}`

---

## üß© Estructura de carpetas recomendada

{% raw %}
```
/tests
	/MyApp.Tests
		/Integration
			ProductApiTests.cs
		/Unit
			ProductServiceTests.cs
```
{% endraw %}

---

## üß± Clase base para tests de integraci√≥n

**tests/MyApp.Tests/Integration/CustomWebApplicationFactory.cs**

{% raw %}
```csharp
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using MyApp.Infrastructure.Data;

namespace MyApp.Tests.Integration;

public class CustomWebApplicationFactory : WebApplicationFactory<Program>
{
	protected override void ConfigureWebHost(IWebHostBuilder builder)
	{
		builder.ConfigureServices(services =>
		{
			// Eliminar configuraci√≥n de DB real
			var descriptor = services.SingleOrDefault(
				d => d.ServiceType == typeof(DbContextOptions<AppDbContext>));
			if (descriptor != null) services.Remove(descriptor);

			// A√±adir base de datos en memoria
			services.AddDbContext<AppDbContext>(options =>
				options.UseInMemoryDatabase("TestDb"));
		});
	}
}
```
{% endraw %}

---

## üåê Test de integraci√≥n real de la API

**tests/MyApp.Tests/Integration/ProductApiTests.cs**

{% raw %}
```csharp
using System.Net.Http.Json;
using MyApp.Domain.Entities;
using Xunit;

namespace MyApp.Tests.Integration;

public class ProductApiTests : IClassFixture<CustomWebApplicationFactory>
{
	private readonly HttpClient _client;

	public ProductApiTests(CustomWebApplicationFactory factory)
	{
		_client = factory.CreateClient();
	}

	[Fact]
	public async Task PostProduct_ShouldCreateAndReturnProduct()
	{
		var product = new Product { Name = "Laptop", Price = 999.99M };

		var response = await _client.PostAsJsonAsync("/api/product", product);

		response.EnsureSuccessStatusCode();

		var created = await response.Content.ReadFromJsonAsync<Product>();

		Assert.NotNull(created);
		Assert.Equal("Laptop", created!.Name);
		Assert.True(created.Price > 0);
	}

	[Fact]
	public async Task GetAll_ShouldReturnListOfProducts()
	{
		var response = await _client.GetAsync("/api/product");

		response.EnsureSuccessStatusCode();

		var products = await response.Content.ReadFromJsonAsync<IEnumerable<Product>>();
		Assert.NotNull(products);
	}
}
```
{% endraw %}

---

## üß† Ejecuci√≥n de los tests

{% raw %}
```bash
dotnet test --logger "console;verbosity=detailed"
```
{% endraw %}

Ver√°s algo como:

{% raw %}
```
[xUnit.net 00:00:01.12] MyApp.Tests.Integration.ProductApiTests.PostProduct_ShouldCreateAndReturnProduct [PASS]
[xUnit.net 00:00:01.19] MyApp.Tests.Integration.ProductApiTests.GetAll_ShouldReturnListOfProducts [PASS]
```
{% endraw %}

‚úÖ Si ambos pasan, tu API responde correctamente y la configuraci√≥n de DI funciona como en producci√≥n.

---

## üß© Test unitario adicional (sin WebApplicationFactory)

**tests/MyApp.Tests/Unit/ProductServiceTests.cs**

{% raw %}
```csharp
using MyApp.Application.Services;
using MyApp.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using MyApp.Infrastructure.Data;
using Xunit;

public class ProductServiceTests
{
	[Fact]
	public void Add_ShouldStoreInMemoryContext()
	{
		var options = new DbContextOptionsBuilder<AppDbContext>()
			.UseInMemoryDatabase("TestDb2")
			.Options;

		using var context = new AppDbContext(options);
		var service = new ProductService(context);

		var product = new Product { Name = "Mouse", Price = 25 };
		service.Add(product);

		Assert.Single(context.Products);
	}
}
```
{% endraw %}

---

## üßæ Consejos de testeo profesional

* Usa bases de datos **in-memory o SQLite in-memory** para tests r√°pidos.
* Cada test debe ser **independiente** (recrear el contexto en cada m√©todo).
* Evita mocks innecesarios si puedes **testear la integraci√≥n real**.
* Mant√©n tests de integraci√≥n y unitarios separados (carpetas distintas).
* Puedes a√±adir **`dotnet test /p:CollectCoverage=true`** con *coverlet* para cobertura.

---

## üß∞ Integraci√≥n en CI/CD

Agrega al workflow de GitHub Actions:

{% raw %}
```yaml
- name: Run tests
  run: dotnet test --no-build --verbosity normal
```
{% endraw %}

---

## ‚úÖ Resultado esperado

‚úîÔ∏è Tests de integraci√≥n reales con HTTP
‚úîÔ∏è Base de datos en memoria funcional
‚úîÔ∏è Cobertura de servicios y controladores
‚úîÔ∏è CI con ejecuci√≥n autom√°tica de tests


# üñ•Ô∏è M√≥dulo 5 ‚Äì Frontend + Integraci√≥n (Blazor, MAUI y Angular Client)

## üéØ Objetivo
Conectar la API .NET creada en m√≥dulos previos con diferentes frontends modernos:  
- **Blazor WebAssembly** para aplicaciones SPA .NET puras  
- **.NET MAUI** para apps multiplataforma (desktop + m√≥vil)  
- **Angular** como ejemplo de integraci√≥n con frameworks externos

---

## üß± Parte 1: Blazor WebAssembly + API REST

### üì¶ Crear proyecto Blazor
{% raw %}
```bash
dotnet new blazorwasm -n MyApp.BlazorClient --framework net9.0
cd MyApp.BlazorClient
```
{% endraw %}`

### üîó Configurar HttpClient global

**Program.cs**

{% raw %}
```csharp
using MyApp.BlazorClient;
using MyApp.BlazorClient.Services;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");

builder.Services.AddScoped(sp =>
	new HttpClient { BaseAddress = new Uri("https://localhost:5001/") });

builder.Services.AddScoped<ProductApiClient>();

await builder.Build().RunAsync();
```
{% endraw %}

### üí¨ Servicio para consumir la API

**Services/ProductApiClient.cs**

{% raw %}
```csharp
using System.Net.Http.Json;
using MyApp.Shared;

namespace MyApp.BlazorClient.Services;

public class ProductApiClient
{
	private readonly HttpClient _http;

	public ProductApiClient(HttpClient http) => _http = http;

	public async Task<IEnumerable<ProductDto>?> GetAllAsync()
		=> await _http.GetFromJsonAsync<IEnumerable<ProductDto>>("api/product");

	public async Task<ProductDto?> CreateAsync(ProductDto product)
	{
		var response = await _http.PostAsJsonAsync("api/product", product);
		response.EnsureSuccessStatusCode();
		return await response.Content.ReadFromJsonAsync<ProductDto>();
	}
}
```
{% endraw %}

### üß© Componente para mostrar productos

**Pages/Products.razor**

{% raw %}
```razor
@page "/products"
@inject ProductApiClient Api

<h3>Products</h3>

@if (products == null)
{
	<p>Loading...</p>
}
else
{
	<ul>
		@foreach (var p in products)
		{
			<li>@p.Name - @p.Price ‚Ç¨</li>
		}
	</ul>
}

@code {
	IEnumerable<ProductDto>? products;

	protected override async Task OnInitializedAsync()
	{
		products = await Api.GetAllAsync();
	}
}
```
{% endraw %}

‚úÖ Ejecuta `dotnet run` y abre `/products` ‚Üí ver√°s los productos cargados desde la API real.

---

## üì± Parte 2: .NET MAUI ‚Äì App multiplataforma

### ‚öôÔ∏è Crear proyecto MAUI

{% raw %}
```bash
dotnet new maui -n MyApp.Mobile
cd MyApp.Mobile
```
{% endraw %}

### üîó Servicio para API

**Services/ProductService.cs**

{% raw %}
```csharp
using System.Net.Http.Json;
using MyApp.Shared;

namespace MyApp.Mobile.Services;

public class ProductService
{
	private readonly HttpClient _http;

	public ProductService()
	{
		_http = new HttpClient
		{
			BaseAddress = new Uri("https://localhost:5001/")
		};
	}

	public async Task<List<ProductDto>?> GetAllAsync()
		=> await _http.GetFromJsonAsync<List<ProductDto>>("api/product");
}
```
{% endraw %}

### üì≤ P√°gina principal

**MainPage.xaml.cs**

{% raw %}
```csharp
using MyApp.Mobile.Services;

namespace MyApp.Mobile;

public partial class MainPage : ContentPage
{
	private readonly ProductService _service = new();

	public MainPage()
	{
		InitializeComponent();
		LoadProducts();
	}

	private async void LoadProducts()
	{
		var products = await _service.GetAllAsync();
		ProductList.ItemsSource = products;
	}
}
```
{% endraw %}

‚úÖ Ejecuta en Android Emulator o Windows ‚Üí lista real desde API .NET 9.

---

## üåê Parte 3: Cliente Angular

### üß± Crear cliente Angular

{% raw %}
```bash
ng new myapp-angular --standalone
cd myapp-angular
npm install axios
```
{% endraw %}

### üîó Servicio API

**src/app/api.service.ts**

{% raw %}
```typescript
import axios from 'axios';

export class ApiService {
	private base = 'https://localhost:5001/api/product';

	async getAll() {
		const res = await axios.get(this.base);
		return res.data;
	}

	async create(product: any) {
		const res = await axios.post(this.base, product);
		return res.data;
	}
}
```
{% endraw %}

### üß© Componente simple

**src/app/products.component.ts**

{% raw %}
```typescript
import { Component, OnInit } from '@angular/core';
import { ApiService } from './api.service';

@Component({
	selector: 'app-products',
	template: `
		<h3>Products</h3>
		<ul>
			<li *ngFor="let p of products">{{p.name}} - {{p.price}}‚Ç¨</li>
		</ul>
	`
})
export class ProductsComponent implements OnInit {
	products: any[] = [];
	api = new ApiService();

	async ngOnInit() {
		this.products = await this.api.getAll();
	}
}
```
{% endraw %}

---

## üîê Autenticaci√≥n JWT compartida

### üõ†Ô∏è En API (.NET)

{% raw %}
```csharp
builder.Services.AddAuthentication("Bearer")
	.AddJwtBearer(options =>
	{
		options.Authority = "https://localhost:5001";
		options.Audience = "myapi";
	});
```
{% endraw %}

### üß± En Blazor / Angular

Adjuntar el token JWT a cada petici√≥n:

{% raw %}
```typescript
axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
```
{% endraw %}

---

## üß† Buenas pr√°cticas de integraci√≥n

* Centraliza URLs en un `AppSettings` o `ConfigService`.
* Usa DTOs compartidos entre backend y frontend (`MyApp.Shared`).
* En Blazor y MAUI, reutiliza servicios y modelos comunes.
* Mant√©n la autenticaci√≥n y autorizaci√≥n coherente (Identity o JWT).
* A√≠sla l√≥gica de red (API Clients) de la UI.

---

## ‚úÖ Resultado esperado

‚úîÔ∏è API consumida desde tres clientes reales
‚úîÔ∏è Patr√≥n de comunicaci√≥n unificado
‚úîÔ∏è Ejemplo funcional Full Stack .NET + Angular
‚úîÔ∏è Base s√≥lida para apps empresariales multiplataforma

# ‚öôÔ∏è M√≥dulo 6 ‚Äì DevOps, CI/CD y despliegue de proyectos .NET (2025)

## üéØ Objetivo
Aprender a **automatizar el ciclo de vida completo** de una aplicaci√≥n .NET moderna:
- Build y test automatizados  
- Creaci√≥n de contenedores Docker  
- Despliegue continuo (CI/CD)  
- Publicaci√≥n en entornos como **Azure Web App**, **AWS**, **Render** o **Vercel**

---

## üß± Estructura base del pipeline

Pipeline de ejemplo con:
1. **GitHub Actions**  
2. **Docker multi-stage build**  
3. **Despliegue a Azure Web App**

---

## üêã Parte 1: Dockerfile optimizado

**Dockerfile**
{% raw %}
```dockerfile
# Etapa 1: Build
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore
RUN dotnet publish -c Release -o /app/publish

# Etapa 2: Runtime
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS runtime
WORKDIR /app
COPY --from=build /app/publish .
EXPOSE 8080
ENTRYPOINT ["dotnet", "MyApp.Api.dll"]
```
{% endraw %}`

### üß™ Test local

{% raw %}
```bash
docker build -t myapp-api .
docker run -p 8080:8080 myapp-api
```
{% endraw %}

Accede a: `http://localhost:8080/swagger`

---

## üîÑ Parte 2: GitHub Actions ‚Äì CI/CD

**.github/workflows/dotnet-ci.yml**

{% raw %}
```yaml
name: .NET CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore -c Release

      - name: Run tests
        run: dotnet test --no-build --verbosity normal

      - name: Publish artifacts
        run: dotnet publish -c Release -o out

      - name: Upload build output
        uses: actions/upload-artifact@v4
        with:
          name: published-app
          path: out
```
{% endraw %}

‚úÖ Resultado: compila, ejecuta tests y guarda artefactos autom√°ticamente.

---

## ‚òÅÔ∏è Parte 3: Despliegue autom√°tico a Azure Web App

Agrega un segundo workflow:

**.github/workflows/deploy.yml**

{% raw %}
```yaml
name: Deploy to Azure Web App

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Publish app
        run: dotnet publish -c Release -o out

      - name: Deploy to Azure
        uses: azure/webapps-deploy@v3
        with:
          app-name: "myapp-dotnet9"
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: ./out
```
{% endraw %}

### üîê Configurar secretos

En GitHub ‚Üí `Settings > Secrets and variables > Actions`

* `AZURE_WEBAPP_PUBLISH_PROFILE` = XML del perfil de publicaci√≥n de Azure

---

## üß© Parte 4: Docker + GitHub Container Registry (GHCR)

**Publicar imagen Docker autom√°ticamente**

{% raw %}
```yaml
- name: Log in to GitHub Container Registry
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}

- name: Build and push Docker image
  uses: docker/build-push-action@v6
  with:
    push: true
    tags: ghcr.io/${{ github.repository_owner }}/myapp:latest
```
{% endraw %}

‚úÖ Resultado:

* Imagen se publica en GHCR ([https://ghcr.io/tu-usuario/myapp](https://ghcr.io/tu-usuario/myapp))
* Puede ser usada en Azure, AWS ECS o Kubernetes

---

## üîß Parte 5: Variables y configuraci√≥n por entorno

Usa `appsettings.{Environment}.json`:

{% raw %}
```json
{
	"ConnectionStrings": {
		"DefaultConnection": "Server=db;Database=MyApp;User Id=sa;Password=Pass123;"
	},
	"Logging": {
		"LogLevel": {
			"Default": "Information"
		}
	}
}
```
{% endraw %}

En `Program.cs`:

{% raw %}
```csharp
builder.Configuration.AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true);
```
{% endraw %}

---

## üß† Buenas pr√°cticas de DevOps

* Mant√©n CI/CD separado por entorno (`dev`, `staging`, `prod`).
* Usa *branch protection rules* y *pull request checks*.
* Monitorea con **Application Insights** o **Grafana + Prometheus**.
* Versiona las im√°genes Docker (`myapp:v1.0.0`).
* Integra *Infrastructure as Code* (IaC) con **Bicep**, **Terraform** o **Pulumi**.

---

## üöÄ Resultado esperado

‚úîÔ∏è Pipeline CI/CD funcionando en GitHub Actions
‚úîÔ∏è Despliegue autom√°tico a Azure Web App
‚úîÔ∏è Imagen Docker publicada en GHCR
‚úîÔ∏è Configuraci√≥n adaptable por entorno
‚úîÔ∏è Base s√≥lida para flujos DevOps profesionales

# üõ°Ô∏è M√≥dulo 7 ‚Äì Seguridad, Observabilidad y Rendimiento en .NET 9+
tags:: #dotnet #security #jwt #oauth2 #identity #observability #logging #metrics #performance #tracing

---

## üéØ Objetivo
Asegurar y supervisar una API .NET moderna mediante:
- Autenticaci√≥n JWT y OAuth2  
- Protecci√≥n de endpoints con roles  
- Logging estructurado con **Serilog**  
- Observabilidad con **OpenTelemetry** y **Grafana**  
- Optimizaci√≥n de rendimiento y profiling

---

## üîë Parte 1: Autenticaci√≥n JWT

### üß© Instalar paquetes
{% raw %}
```bash
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package System.IdentityModel.Tokens.Jwt
```
{% endraw %}`

### ‚öôÔ∏è Configurar autenticaci√≥n en `Program.cs`

{% raw %}
```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var key = Encoding.ASCII.GetBytes("SuperSecretKeyForJwtToken12345!");

builder.Services.AddAuthentication(options =>
{
	options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
	options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
	options.RequireHttpsMetadata = false;
	options.SaveToken = true;
	options.TokenValidationParameters = new TokenValidationParameters
	{
		ValidateIssuer = false,
		ValidateAudience = false,
		ValidateLifetime = true,
		IssuerSigningKey = new SymmetricSecurityKey(key),
		ValidateIssuerSigningKey = true
	};
});
```
{% endraw %}

### üß± Crear controlador de autenticaci√≥n

**Controllers/AuthController.cs**

{% raw %}
```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

[ApiController]
[Route("api/[controller]")]
public class AuthController : ControllerBase
{
	[HttpPost("login")]
	public IActionResult Login([FromBody] LoginRequest request)
	{
		if (request.Username != "admin" || request.Password != "1234")
			return Unauthorized();

		var key = new SymmetricSecurityKey(Encoding.ASCII.GetBytes("SuperSecretKeyForJwtToken12345!"));
		var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
		var claims = new[]
		{
			new Claim(ClaimTypes.Name, request.Username),
			new Claim(ClaimTypes.Role, "Admin")
		};

		var token = new JwtSecurityToken(
			claims: claims,
			expires: DateTime.UtcNow.AddHours(1),
			signingCredentials: creds
		);

		return Ok(new { token = new JwtSecurityTokenHandler().WriteToken(token) });
	}
}

public record LoginRequest(string Username, string Password);
```
{% endraw %}

### üîê Proteger endpoints

{% raw %}
```csharp
[Authorize(Roles = "Admin")]
[HttpPost]
public IActionResult CreateProduct(Product product)
{
	_service.Add(product);
	return Ok(product);
}
```
{% endraw %}

---

## üîë Parte 2: OAuth2 con Microsoft Identity Platform

Configuraci√≥n m√≠nima para aplicaciones empresariales.

### üì¶ Paquetes

{% raw %}
```bash
dotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect
```
{% endraw %}

### ‚öôÔ∏è Configuraci√≥n en `Program.cs`

{% raw %}
```csharp
builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)
	.AddMicrosoftIdentityWebApp(builder.Configuration.GetSection("AzureAd"));
```
{% endraw %}

### üß© appsettings.json

{% raw %}
```json
"AzureAd": {
	"Instance": "https://login.microsoftonline.com/",
	"Domain": "mydomain.onmicrosoft.com",
	"TenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
	"ClientId": "yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy",
	"CallbackPath": "/signin-oidc"
}
```
{% endraw %}

‚úÖ Ideal para aplicaciones con Azure AD, B2C o entornos corporativos.

---

## üìä Parte 3: Logging estructurado con Serilog

### üß± Instalar

{% raw %}
```bash
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File
```
{% endraw %}

### ‚öôÔ∏è Configurar

**Program.cs**

{% raw %}
```csharp
using Serilog;

Log.Logger = new LoggerConfiguration()
	.Enrich.FromLogContext()
	.WriteTo.Console()
	.WriteTo.File("logs/log.txt", rollingInterval: RollingInterval.Day)
	.CreateLogger();

builder.Host.UseSerilog();
```
{% endraw %}

### üß© Ejemplo en controlador

{% raw %}
```csharp
private readonly ILogger<ProductController> _logger;

public ProductController(IProductService service, ILogger<ProductController> logger)
{
	_service = service;
	_logger = logger;
}

[HttpGet]
public IActionResult GetAll()
{
	_logger.LogInformation("Fetching all products at {time}", DateTime.UtcNow);
	return Ok(_service.GetAll());
}
```
{% endraw %}

---

## üî≠ Parte 4: Observabilidad con OpenTelemetry

### üì¶ Instalar

{% raw %}
```bash
dotnet add package OpenTelemetry.Exporter.Console
dotnet add package OpenTelemetry.Exporter.OpenTelemetryProtocol
dotnet add package OpenTelemetry.Extensions.Hosting
dotnet add package OpenTelemetry.Instrumentation.AspNetCore
dotnet add package OpenTelemetry.Instrumentation.Http
```
{% endraw %}

### ‚öôÔ∏è Configurar

**Program.cs**

{% raw %}
```csharp
using OpenTelemetry.Trace;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;

builder.Services.AddOpenTelemetry()
	.WithTracing(t => t
		.SetResourceBuilder(ResourceBuilder.CreateDefault().AddService("MyApp.Api"))
		.AddAspNetCoreInstrumentation()
		.AddHttpClientInstrumentation()
		.AddOtlpExporter(o => o.Endpoint = new Uri("http://localhost:4317")))
	.WithMetrics(m => m
		.AddAspNetCoreInstrumentation()
		.AddHttpClientInstrumentation()
		.AddRuntimeInstrumentation()
		.AddOtlpExporter());
```
{% endraw %}

### üìà Exportar datos a Grafana o Jaeger

Ejecuta contenedores con Docker:

{% raw %}
```bash
docker run -d --name jaeger -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p 16686:16686 jaegertracing/all-in-one:latest
```
{% endraw %}

Accede a: `http://localhost:16686` ‚Üí visualiza trazas y spans.

---

## ‚ö° Parte 5: Optimizaci√≥n de rendimiento

### üß© Diagn√≥stico en tiempo real

{% raw %}
```bash
dotnet-counters monitor --process-id <PID>
```
{% endraw %}

### üß∞ Perf tips:

* Usa `async/await` en IO intensivo
* Implementa caching con `IMemoryCache` o Redis
* Evita `ToList()` prematuros en LINQ
* Usa `AddResponseCompression()` y `UseResponseCaching()`
* Ajusta `Kestrel` para concurrencia alta:

{% raw %}
```csharp
builder.WebHost.ConfigureKestrel(options =>
{
	options.Limits.MaxConcurrentConnections = 1000;
});
```
{% endraw %}

---

## üß† Buenas pr√°cticas

* Mant√©n claves fuera del c√≥digo ‚Üí usa `dotnet user-secrets` o `Azure Key Vault`.
* Registra solo lo necesario ‚Üí usa niveles (`Information`, `Warning`, `Error`).
* Aplica *Rate Limiting* en endpoints p√∫blicos (`AddRateLimiter`).
* Combina **Serilog + OpenTelemetry** para trazas unificadas.
* Revisa *Memory Dumps* con `dotnet-dump analyze` en producci√≥n.

---

## ‚úÖ Resultado esperado

‚úîÔ∏è Autenticaci√≥n JWT / OAuth2 funcionando
‚úîÔ∏è Endpoints protegidos con roles
‚úîÔ∏è Logging estructurado y persistente
‚úîÔ∏è Trazabilidad distribuida con OpenTelemetry
‚úîÔ∏è Monitoreo de rendimiento en tiempo real
‚úîÔ∏è API lista para entornos productivos y auditables

# üèóÔ∏è M√≥dulo 8 ‚Äì Arquitecturas avanzadas y patrones distribuidos (.NET 9+)

## Objetivo pr√°ctico
Implementar patrones reales para sistemas distribuidos con .NET 9: **Microservicios**, **CQRS**, **Event Sourcing**, **Sagas/Compensations**, **EventBus (RabbitMQ)**, **gRPC**, **Outbox pattern**, y **resiliencia** (Polly). Cada bloque incluye ejemplos ejecutables m√≠nimos y comandos para probar localmente.

---

## 1. Dise√±o general de microservicios
- Servicios peque√±os con responsabilidad √∫nica (User, Order, Payment, Catalog).  
- Comunicaci√≥n:
	- Sincr√≥nica: gRPC o HTTP/REST.
	- Asincr√≥nica: RabbitMQ / Kafka / Dapr pub/sub.  
- Persistencia: base de datos por servicio (DB-per-service).  
- Consistencia eventual: Outbox + EventBus o Sagas para flujos transaccionales.

---

## 2. CQRS con MediatR (comandos/consultas separados)

### 2.1 Ejemplo: comando y handler con MediatR
#### C√≥digo: Command y Handler
{% raw %}
```csharp
// Application/Commands/CreateOrderCommand.cs
public record CreateOrderCommand(Guid CustomerId, List<OrderItemDto> Items) : IRequest<Guid>;

// Application/Handlers/CreateOrderHandler.cs
public class CreateOrderHandler : IRequestHandler<CreateOrderCommand, Guid>
{
	private readonly AppDbContext _db;
	private readonly IPublishEndpoint _publisher; // MassTransit or custom bus

	public CreateOrderHandler(AppDbContext db, IPublishEndpoint publisher)
	{
		_db = db;
		_publisher = publisher;
	}

	public async Task<Guid> Handle(CreateOrderCommand request, CancellationToken ct)
	{
		var order = new Order { CustomerId = request.CustomerId, Items = request.Items.Select(i => new OrderItem(i.ProductId, i.Quantity)).ToList() };
		_db.Orders.Add(order);
		await _db.SaveChangesAsync(ct);

		// Publicar evento de dominio
		await _publisher.Publish(new OrderCreatedEvent(order.Id, order.Total), ct);

		return order.Id;
	}
}
```
{% endraw %}`

### 2.2 Registro en DI

{% raw %}
```csharp
// Program.cs
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssemblyContaining<CreateOrderCommand>());
```
{% endraw %}

---

## 3. Event Sourcing (concepto + ejemplo m√≠nimo)

* Almacenar s√≥lo eventos inmutables; reconstruir estado por rehidrataci√≥n.
* Usar una tabla `Events` con `Id, AggregateId, Type, Data(json), Version, CreatedAt`.

### 3.1 Ejemplo: evento y ap√©ndice

#### C√≥digo: Event entity y append

{% raw %}
```csharp
// Infrastructure/Events/EventEntity.cs
public class EventEntity
{
	public Guid Id { get; set; } = Guid.NewGuid();
	public Guid AggregateId { get; set; }
	public string Type { get; set; } = null!;
	public string Data { get; set; } = null!;
	public int Version { get; set; }
	public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

// Usage: append event
var evt = new EventEntity { AggregateId = order.Id, Type = "OrderCreated", Data = JsonSerializer.Serialize(new { order.Id, order.Total }), Version = 1 };
db.Events.Add(evt);
await db.SaveChangesAsync();
```
{% endraw %}

---

## 4. Outbox pattern (garantizar publicaci√≥n de eventos)

* Escribir evento en la misma transacci√≥n que la entidad (DB), luego enviar los eventos desde la tabla `Outbox` mediante un proceso background para asegurar entrega at-least-once.

### 4.1 Ejemplo: esquema Outbox y worker

#### C√≥digo: Outbox entity

{% raw %}
```csharp
public class OutboxMessage
{
	public Guid Id { get; set; } = Guid.NewGuid();
	public string Type { get; set; } = null!;
	public string Payload { get; set; } = null!;
	public DateTime OccurredAt { get; set; } = DateTime.UtcNow;
	public bool Sent { get; set; } = false;
}
```
{% endraw %}

#### C√≥digo: Worker simple (BackgroundService)

{% raw %}
```csharp
public class OutboxDispatcher : BackgroundService
{
	private readonly IServiceScopeFactory _scopes;
	private readonly IPublishEndpoint _publisher;

	public OutboxDispatcher(IServiceScopeFactory scopes, IPublishEndpoint publisher)
	{
		_scopes = scopes;
		_publisher = publisher;
	}

	protected override async Task ExecuteAsync(CancellationToken stoppingToken)
	{
		while (!stoppingToken.IsCancellationRequested)
		{
			using var scope = _scopes.CreateScope();
			var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
			var pending = await db.Set<OutboxMessage>().Where(m => !m.Sent).Take(20).ToListAsync(stoppingToken);

			foreach (var msg in pending)
			{
				await _publisher.Publish(msg, stoppingToken); // map to domain event
				msg.Sent = true;
			}

			await db.SaveChangesAsync(stoppingToken);
			await Task.Delay(1000, stoppingToken);
		}
	}
}
```
{% endraw %}

---

## 5. EventBus con RabbitMQ (MassTransit ejemplo)

### 5.1 Docker Compose para RabbitMQ

#### C√≥digo: docker-compose.yml

{% raw %}
```yaml
version: '3.8'
services:
  rabbitmq:
    image: rabbitmq:3.11-management
    ports:
      - "5672:5672"
      - "15672:15672"
```
{% endraw %}

Comando:

{% raw %}
```bash
docker compose up -d
```
{% endraw %}

### 5.2 Configurar MassTransit en servicios

#### C√≥digo: Program.cs (MassTransit)

{% raw %}
```csharp
builder.Services.AddMassTransit(x =>
{
	x.UsingRabbitMq((context, cfg) =>
	{
		cfg.Host("rabbitmq", "/", h => { /* credenciales si es necesario */ });
		cfg.ConfigureEndpoints(context);
	});
});
```
{% endraw %}

### 5.3 Consumidor simple

#### C√≥digo: OrderCreatedConsumer

{% raw %}
```csharp
public class OrderCreatedEvent
{
	public Guid OrderId { get; init; }
	public decimal Total { get; init; }
}

public class OrderCreatedConsumer : IConsumer<OrderCreatedEvent>
{
	public Task Consume(ConsumeContext<OrderCreatedEvent> context)
	{
		Console.WriteLine($"OrderReceived: {context.Message.OrderId} total {context.Message.Total}");
		return Task.CompletedTask;
	}
}
```
{% endraw %}

---

## 6. Sagas (orquestaci√≥n de procesos) con MassTransit

* Usar Sagas para orquestar flujos (Order -> Payment -> Inventory -> Confirmation).
* Persistir estado de saga (EF Core or Mongo) y modelar correcciones (compensaciones).

### 6.1 Ejemplo: Saga State & Saga

#### C√≥digo: OrderState

{% raw %}
```csharp
public class OrderState : SagaStateMachineInstance
{
	public Guid CorrelationId { get; set; }
	public string CurrentState { get; set; } = null!;
	public Guid OrderId { get; set; }
	public bool PaymentConfirmed { get; set; }
}
```
{% endraw %}

#### C√≥digo: StateMachine (esqueleto)

{% raw %}
```csharp
public class OrderStateMachine : MassTransitStateMachine<OrderState>
{
	public State AwaitingPayment { get; private set; }

	public Event<OrderCreatedEvent> OrderCreated { get; private set; }

	public OrderStateMachine()
	{
		InstanceState(x => x.CurrentState);

		Event(() => OrderCreated, x => x.CorrelateById(m => m.Message.OrderId));

		Initially(
			When(OrderCreated)
				.Then(context => { context.Instance.OrderId = context.Data.OrderId; })
				.TransitionTo(AwaitingPayment)
		);

		// agregar manejo de pago, compensaciones, timeouts...
	}
}
```
{% endraw %}

---

## 7. gRPC para llamadas s√≠ncronas r√°pidas

### 7.1 Definir contrato .proto

#### C√≥digo: proto/order.proto

{% raw %}
```proto
syntax = "proto3";
package orders;

service OrderService {
	rpc GetOrder (OrderRequest) returns (OrderReply);
}

message OrderRequest {
	string id = 1;
}

message OrderReply {
	string id = 1;
	double total = 2;
	string status = 3;
}
```
{% endraw %}

### 7.2 Agregar gRPC al proyecto (.NET)

{% raw %}
```csharp
// Program.cs
builder.Services.AddGrpc();
app.MapGrpcService<OrderGrpcService>();
```
{% endraw %}

### 7.3 Implementar servicio gRPC

#### C√≥digo: OrderGrpcService.cs

{% raw %}
```csharp
public class OrderGrpcService : OrderService.OrderServiceBase
{
	public override Task<OrderReply> GetOrder(OrderRequest request, ServerCallContext context)
	{
		// obtener desde DB
		return Task.FromResult(new OrderReply { Id = request.Id, Total = 100.0, Status = "Created" });
	}
}
```
{% endraw %}

---

## 8. Dapr (alternativa ligera para pub/sub, state, bindings)

* Dapr simplifica pub/sub, state stores y service invocation sin acoplar demasiado.
* Instalar Dapr CLI local y ejecutar `dapr run --app-id orders -- dotnet run`.

### 8.1 Ejemplo: publicar evento con Dapr

#### C√≥digo: Publicar evento (HTTP)

{% raw %}
```csharp
var client = new HttpClient();
await client.PostAsJsonAsync("http://localhost:3500/v1.0/publish/pubsub/order_created", new { orderId = id, total = total });
```
{% endraw %}

### 8.2 Suscriptor en otro servicio

* Configurar endpoint `/dapr/subscribe` o usar SDK .NET (Dapr.Client).

---

## 9. Resiliencia: Polly (reintentos, circuit breaker, timeout)

### 9.1 Paquete y pol√≠tica

{% raw %}
```bash
dotnet add package Polly.Extensions.Http
```
{% endraw %}

### 9.2 Ejemplo: HttpClient con pol√≠ticas

#### C√≥digo: Program.cs - HttpClientFactory + Polly

{% raw %}
```csharp
builder.Services.AddHttpClient("payment", client => client.BaseAddress = new Uri("https://payment.local"))
	.AddTransientHttpErrorPolicy(p => p.WaitAndRetryAsync(3, _ => TimeSpan.FromMilliseconds(500)))
	.AddTransientHttpErrorPolicy(p => p.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));
```
{% endraw %}

---

## 10. Testing de integraci√≥n distribuida (Testcontainers)

### 10.1 Usar Testcontainers.NET para RabbitMQ/DB

#### C√≥digo: ejemplo de test setup (C#)

{% raw %}
```csharp
var rabbit = new RabbitMqTestcontainerBuilder().Build();
await rabbit.StartAsync();
// iniciar bus con conexi√≥n rabbit.ConnectionString
```
{% endraw %}

---

## 11. Observabilidad espec√≠fica de microservicios

* Trazas: OpenTelemetry + Jaeger (OTLP).
* M√©tricas: Prometheus exporters + Grafana dashboards por servicio.
* Logs: Correlaci√≥n por `traceId` en Serilog/Seq.

---

## 12. Despliegue y orquestaci√≥n recomendada

* Kubernetes con Helm charts.
* Separar infra: RabbitMQ (stateful), DB (managed), app (deployments).
* Rolling updates + readiness/liveness probes.
* Considerar Service Mesh (Istio/Linkerd) para pol√≠ticas de red y telemetr√≠a.

---

## 13. Checklist pr√°ctico (qu√© implementar primero)

* [ ] Separar responsabilidades en servicios peque√±os.
* [ ] Implementar CQRS m√≠nimo (commands + queries).
* [ ] A√±adir Outbox para eventos publicados desde la transacci√≥n DB.
* [ ] Desplegar RabbitMQ local y validar pub/sub.
* [ ] Implementar Sagas para flujos de negocio multistep.
* [ ] A√±adir gRPC para caminos s√≠ncronos de baja latencia.
* [ ] Integrar resiliencia con Polly.
* [ ] Habilitar OpenTelemetry y dashboards b√°sicos.
* [ ] Tests de integraci√≥n end-to-end con Testcontainers.

---

## Comandos √∫tiles r√°pidos

{% raw %}
```bash
# levantar RabbitMQ
docker compose -f docker-compose.yml up -d

# ejecutar migraciones (ej. infra project)
dotnet ef database update --project src/MyService.Infrastructure --startup-project src/MyService.Api

# ejecutar tests con containers
dotnet test tests/MyService.Tests
```
{% endraw %}

---

## Notas de implementaci√≥n

* Empezar simple: CQRS + Outbox + EventBus. A√±adir Sagas cuando necesites coordinaciones transaccionales.
* Priorizad idempotencia en consumidores (recibidos m√∫ltiples).
* Modelar eventos como contratos estables (versionable).
* Monitorizar entrega (DLQ, retries y dead-letter queues en RabbitMQ).

# üöÄ M√≥dulo 9 ‚Äì Rendimiento, Profiling y Publicaci√≥n Cloud-Ready (.NET 9+)

## Objetivo pr√°ctico
Optimizar, analizar y desplegar aplicaciones .NET 9 en entornos **cloud-ready**, midiendo rendimiento con herramientas reales, aplicando patrones de optimizaci√≥n, y preparando el proyecto para **Azure**, **AWS**, o **Kubernetes** con **CI/CD y observabilidad**.

---

## 1. Fundamentos de rendimiento en .NET
### Principios clave
- **Evitar bloqueos innecesarios** ‚Üí usar `async/await` en IO-bound.  
- **Reducir asignaciones en bucles cr√≠ticos** (usar `Span<T>`, `Memory<T>`).  
- **Evitar LINQ costoso en loops** ‚Üí preferir bucles expl√≠citos o `ArrayPool<T>`.  
- **Configurar correctamente el Garbage Collector (GC)**:
	- Server GC para entornos productivos.
	- Sustituir colecciones por versiones especializadas (`ConcurrentQueue`, `ArrayPool`).

### Configuraci√≥n del GC
{% raw %}
```xml
<!-- app.config o runtimeconfig.json -->
<configuration>
	<runtime>
		<gcServer enabled="true"/>
		<gcConcurrent enabled="true"/>
	</runtime>
</configuration>
```
{% endraw %}`

---

## 2. Profiling y diagn√≥stico local

### Herramientas recomendadas

* **dotnet-counters** ‚Üí m√©tricas en tiempo real.
* **dotnet-trace** ‚Üí capturar eventos de rendimiento.
* **dotnet-dump** ‚Üí an√°lisis de memoria.
* **PerfView** o **Visual Studio Profiler** ‚Üí profiling detallado.
* **JetBrains dotTrace / dotMemory** ‚Üí an√°lisis avanzado.

### Ejemplo: m√©tricas en tiempo real

{% raw %}
```bash
dotnet-counters monitor --process-id <pid> System.Runtime
```
{% endraw %}

### Ejemplo: grabar un trace

{% raw %}
```bash
dotnet-trace collect --process-id <pid> --format speedscope
```
{% endraw %}

Abre en [https://www.speedscope.app](https://www.speedscope.app) para visualizar la llama de CPU.

---

## 3. Benchmarking con BenchmarkDotNet

### Instalaci√≥n

{% raw %}
```bash
dotnet add package BenchmarkDotNet
```
{% endraw %}

### Ejemplo: benchmark simple

{% raw %}
```csharp
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

public class StringBenchmarks
{
	private string[] words = Enumerable.Repeat("benchmark", 1000).ToArray();

	[Benchmark]
	public string Join() => string.Join(",", words);

	[Benchmark]
	public string ManualConcat()
	{
		var sb = new StringBuilder();
		foreach (var w in words) sb.Append(w).Append(',');
		return sb.ToString();
	}
}

BenchmarkRunner.Run<StringBenchmarks>();
```
{% endraw %}

Salida t√≠pica:

{% raw %}
```
|     Method |      Mean |    Error |   StdDev | Allocated |
|------------ |----------:|---------:|---------:|-----------:|
|        Join |  12.45 us | 0.11 us  | 0.10 us  |   12.3 KB  |
| ManualConcat|  25.18 us | 0.15 us  | 0.14 us  |   48.5 KB  |
```
{% endraw %}

---

## 4. Diagn√≥stico en producci√≥n con OpenTelemetry + Logs

### Instrumentaci√≥n b√°sica

{% raw %}
```csharp
builder.Services.AddOpenTelemetry()
	.WithMetrics(m => m.AddAspNetCoreInstrumentation().AddRuntimeInstrumentation())
	.WithTracing(t => t.AddAspNetCoreInstrumentation().AddHttpClientInstrumentation());
```
{% endraw %}

### Exportar a herramientas

* **Azure Monitor**, **Grafana**, **Jaeger** o **Zipkin**.
* **Log sinks**: `Serilog + Seq` o `Application Insights`.

#### Ejemplo: configuraci√≥n Serilog + Seq

{% raw %}
```csharp
Log.Logger = new LoggerConfiguration()
	.WriteTo.Seq("http://localhost:5341")
	.Enrich.WithCorrelationId()
	.CreateLogger();
```
{% endraw %}

---

## 5. Optimizaci√≥n de API ASP.NET Core

### 5.1 Configuraci√≥n recomendada en Program.cs

{% raw %}
```csharp
builder.WebHost
	.UseKestrel(o =>
	{
		o.AddServerHeader = false;
		o.Limits.MaxConcurrentConnections = 1000;
		o.Limits.KeepAliveTimeout = TimeSpan.FromSeconds(120);
	})
	.UseUrls("http://*:5000");

builder.Services.Configure<RouteOptions>(o => o.LowercaseUrls = true);
builder.Services.AddResponseCompression();
builder.Services.AddMemoryCache();
```
{% endraw %}

### 5.2 Minimizar overhead de middleware

* Evitar middlewares innecesarios en rutas cr√≠ticas.
* Aplicar `[ResponseCache]` o `ETag` en endpoints idempotentes.
* Usar `IResult` minimal APIs para m√°xima eficiencia.

### 5.3 Ejemplo de endpoint optimizado

{% raw %}
```csharp
app.MapGet("/status", () => Results.Ok(new { uptime = Environment.TickCount64 }))
	.CacheOutput(policy => policy.Expire(TimeSpan.FromSeconds(30)));
```
{% endraw %}

---

## 6. Load Testing (carga y stress)

### Opciones

* **k6** ‚Üí moderno, scriptable (JavaScript).
* **Bombardier** ‚Üí CLI sencilla.
* **Azure Load Testing** ‚Üí pruebas cloud integradas.

### Ejemplo con k6

{% raw %}
```bash
npm install -g k6
```
{% endraw %}

{% raw %}
```js
// load.js
import http from 'k6/http';
import { sleep } from 'k6';

export default function () {
	http.get('http://localhost:5000/api/orders');
	sleep(0.1);
}
```
{% endraw %}

Ejecutar:

{% raw %}
```bash
k6 run --vus 50 --duration 30s load.js
```
{% endraw %}

---

## 7. Contenedores y publicaci√≥n

### Dockerfile productivo optimizado

{% raw %}
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS base
WORKDIR /app
EXPOSE 8080

FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src
COPY . .
RUN dotnet publish -c Release -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "MyApp.dll"]
```
{% endraw %}

### Ejecutar y probar

{% raw %}
```bash
docker build -t myapp:latest .
docker run -p 8080:8080 myapp:latest
```
{% endraw %}

---

## 8. Despliegue en Azure

### Opci√≥n 1: Azure App Service

{% raw %}
```bash
az webapp up --name myapp2025 --resource-group MyRG --runtime "DOTNET:9"
```
{% endraw %}

### Opci√≥n 2: Azure Container Apps (ACA)

{% raw %}
```bash
az containerapp up \
	--name myapp \
	--resource-group MyRG \
	--environment myenv \
	--image myapp:latest \
	--ingress external --target-port 8080
```
{% endraw %}

### Opci√≥n 3: Azure Kubernetes Service (AKS)

{% raw %}
```bash
kubectl create namespace myapp
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```
{% endraw %}

---

## 9. Despliegue en AWS

### Opci√≥n 1: AWS Elastic Beanstalk

{% raw %}
```bash
eb init -p "dotnet 9" MyApp
eb create myapp-env
```
{% endraw %}

### Opci√≥n 2: AWS ECS con Fargate

{% raw %}
```bash
aws ecs create-cluster --cluster-name MyCluster
aws ecs register-task-definition --cli-input-json file://ecs-task.json
aws ecs create-service --cluster MyCluster --service-name myapp --task-definition myapp-task
```
{% endraw %}

### Opci√≥n 3: AWS Lambda con .NET

{% raw %}
```bash
dotnet lambda deploy-serverless MyLambdaApp
```
{% endraw %}

---

## 10. CI/CD cloud-ready (GitHub Actions ejemplo)

### Workflow .github/workflows/build-deploy.yml

{% raw %}
```yaml
name: Build and Deploy

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'
      - name: Build
        run: dotnet build --configuration Release
      - name: Publish
        run: dotnet publish -c Release -o output
      - name: Deploy to Azure
        uses: azure/webapps-deploy@v3
        with:
          app-name: myapp2025
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: output
```
{% endraw %}

---

## 11. Monitorizaci√≥n post-despliegue

### Azure Application Insights

* Trazas autom√°ticas de peticiones, dependencias y excepciones.
* Consultas Kusto (KQL) para an√°lisis:

{% raw %}
```kusto
requests
| where duration > 200ms
| summarize avg(duration) by operation_Name
```
{% endraw %}

### AWS CloudWatch

* Logs centralizados, alarmas en latencia o errores.
* Integraci√≥n con AWS X-Ray para tracing distribuido.

---

## 12. Checklist de optimizaci√≥n y despliegue

* [ ] Analizar rendimiento con `dotnet-trace` y `BenchmarkDotNet`.
* [ ] Minimizar allocations y latencia de endpoints.
* [ ] Agregar caching (en memoria o Redis).
* [ ] Configurar logging estructurado + correlaci√≥n.
* [ ] Dockerizar con imagen ligera (`aspnet:9.0-alpine`).
* [ ] A√±adir health checks (`/healthz`).
* [ ] Integrar OpenTelemetry y Application Insights.
* [ ] Desplegar en Azure/AWS con CI/CD automatizado.
* [ ] Ejecutar test de carga post-despliegue.
* [ ] Revisar trazas y m√©tricas para mejorar el siguiente ciclo.

---

## 13. Ejemplo: pipeline local ‚Üí cloud (resumen)

{% raw %}
```bash
# Build + test
dotnet build -c Release
dotnet test

# Containerize
docker build -t myapp:latest .

# Run local with telemetry enabled
docker run -p 8080:8080 -e OTEL_EXPORTER_OTLP_ENDPOINT=http://jaeger:4317 myapp

# Deploy to Azure
az containerapp up --name myapp --resource-group MyRG --image myapp:latest
```
{% endraw %}

---

## 14. Siguientes pasos

* Aplicar observabilidad avanzada con OpenTelemetry Collector + Grafana
* Integrar CD con ArgoCD o GitHub Actions + Bicep.
* A√±adir performance budgets en CI (medir tiempos de endpoints).
* Monitorear SLA y costos en tiempo real.

---

M√≥dulo 1 ‚Äì Setup + entorno productivo moderno (.NET 9)
M√≥dulo 2 ‚Äì API REST limpia con ASP.NET Core
M√≥dulo 3 ‚Äì Persistencia con EF Core
M√≥dulo 4 ‚Äì Testing con xUnit
M√≥dulo 5 ‚Äì Frontend y Blazor/MAUI
M√≥dulo 6 ‚Äì CI/CD y Dockerizaci√≥n
M√≥dulo 7 ‚Äì Casos avanzados CQRS + EventBus + Auth
M√≥dulo 8 ‚Äì Arquitecturas distribuidas y resiliencia













