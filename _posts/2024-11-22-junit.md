---
date: 2024-11-22 21:11
title: JUnit
tags:
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
public_note: "true"
category: Junit
categories:
  - Junit
  - testing
  - java
  - hide-embedded-header1
  - wide
  - Testing
---
# JUnit
`$= dv.current().file.tags.join(" ")`

- [java](/software%20engineering/java/)
- [Testing](/testing/testing/)
- [üîçüõ†Ô∏è Dominando los Test Unitarios en JAVA | JUnit üöÄüíª - YouTube](https://youtu.be/mEzoe6KSUu8) 
- [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)

## üß© Fundamentos de JUnit

JUnit es el framework est√°ndar de testing para Java, utilizado para escribir y ejecutar pruebas unitarias automatizadas.  
Su principal objetivo es validar el comportamiento esperado de m√©todos y clases, asegurando que los cambios no rompan funcionalidades existentes.

### Caracter√≠sticas clave
- Compatibilidad con Maven y [Gradle](/automatizacion%20y%20build/gradle/)
- Anotaciones para definir el ciclo de vida del test (`@BeforeAll`, `@AfterEach`, etc.)
- Soporte para Testing parametrizado
- Integraci√≥n con Mockito y AssertJ
- Extensiones con JUnit 5 Jupiter API

## ‚öôÔ∏è Estructura de un Test

Un test en JUnit sigue una estructura simple:
1. **Preparaci√≥n (Arrange):** configurar los datos o dependencias necesarias.  
2. **Ejecuci√≥n (Act):** ejecutar el m√©todo a probar.  
3. **Verificaci√≥n (Assert):** comprobar que los resultados sean los esperados.

{% raw %}
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculadoraTest {

	@Test
	void suma_debeRetornarResultadoCorrecto() {
		Calculadora calc = new Calculadora();
		int resultado = calc.sumar(2, 3);
		assertEquals(5, resultado);
	}
}
```
{% endraw %}`

## üß± Ciclo de vida de los Tests

JUnit permite controlar la inicializaci√≥n y limpieza de recursos antes y despu√©s de los tests.

{% raw %}
```java
@BeforeAll    // Ejecutado una vez antes de todos los tests
@BeforeEach   // Ejecutado antes de cada test
@AfterEach    // Ejecutado despu√©s de cada test
@AfterAll     // Ejecutado una vez despu√©s de todos los tests
```
{% endraw %}

Ejemplo:

{% raw %}
```java
@BeforeEach
void configurar() {
	// Configura datos o mocks antes de cada prueba
}
```
{% endraw %}

## üß™ Tests Parametrizados

Permiten ejecutar el mismo test con m√∫ltiples valores de entrada.

{% raw %}
```java
@ParameterizedTest
@ValueSource(strings = {"madre", "padre", "hermano"})
void testLongitudCadenas(String palabra) {
	assertTrue(palabra.length() > 3);
}
```
{% endraw %}

### Tipos de fuentes de par√°metros

- `@ValueSource` ‚Äî valores simples (int, String, etc.)
- `@CsvSource` ‚Äî combina varios valores
- `@MethodSource` ‚Äî obtiene datos desde un m√©todo
- `@EnumSource` ‚Äî usa enums como datos de entrada
    

## üß© Assertions m√°s usadas

- `assertEquals(expected, actual)`
- `assertTrue(condition)`
- `assertFalse(condition)`
- `assertThrows(Exception.class, () -> { ... })`
- `assertAll("grupo de asserts", () -> {...}, () -> {...})`
    

{% raw %}
```java
assertAll("Validaciones m√∫ltiples",
	() -> assertEquals(4, calc.sumar(2, 2)),
	() -> assertThrows(ArithmeticException.class, () -> calc.dividir(10, 0))
);
```
{% endraw %}

## üß∞ Integraci√≥n con Mockito

JUnit se complementa con Mockito para simular dependencias.

{% raw %}
```java
@ExtendWith(MockitoExtension.class)
class ServicioUsuarioTest {

	@Mock
	private RepositorioUsuario repo;

	@InjectMocks
	private ServicioUsuario servicio;

	@Test
	void debeGuardarUsuarioCorrectamente() {
		when(repo.save(any())).thenReturn(new Usuario("Ana"));
		Usuario u = servicio.crearUsuario("Ana");
		assertEquals("Ana", u.getNombre());
	}
}
```
{% endraw %}

## üîÑ Buenas pr√°cticas

- Nombrar los tests de forma descriptiva (en ingl√©s o espa√±ol).
- Aislar cada prueba del entorno externo.
- Evitar dependencias entre tests.
- Usar CI/CD para ejecutar los tests autom√°ticamente.
- Medir la Cobertura de c√≥digo con JaCoCo o SonarQube.
- Organizar los tests por m√≥dulo o paquete.
    

## ‚ö° Extensiones y complementos

- `@Tag`: permite clasificar tests por categor√≠a.
- `@Disabled`: desactiva temporalmente un test.
- `@RepeatedTest`: ejecuta un test varias veces.
- `@DisplayName`: define un nombre legible para el test.
    

{% raw %}
```java
@DisplayName("Prueba repetida de conexi√≥n")
@RepeatedTest(3)
void testConexion() {
	assertTrue(servicio.conectar());
}
```
{% endraw %}

## üß≠ Integraci√≥n con CI/CD

JUnit se ejecuta f√°cilmente en pipelines de GitHub Actions, Jenkins, o GitLab CI.  
Los reportes XML generados pueden ser interpretados por herramientas de an√°lisis continuo o dashboards personalizados.

---

## üìö Recursos adicionales

- Testing de APIs REST con JUnit y Spring Boot
- Mocking avanzado con Mockito y JUnit
- Patrones de testing en Java
- Testing de integraci√≥n con Testcontainers

# JUnit - Conceptos Avanzados y Patrones de Testing
`$= dv.current().file.tags.join(" ")`

- [JUnit](/junit/junit/)
- [Testing](/testing/testing/)
- Java
- Spring Boot
- Mockito
- Arquitectura de tests

## üß© Testing de Integraci√≥n con JUnit y Spring Boot

Los tests de integraci√≥n validan la interacci√≥n entre varios componentes (servicios, controladores, repositorios, bases de datos).

### Configuraci√≥n b√°sica

{% raw %}
```java
@SpringBootTest
@AutoConfigureMockMvc
class ControladorUsuarioIT {

	@Autowired
	private MockMvc mockMvc;

	@Test
	void debeRetornarListaUsuarios() throws Exception {
		mockMvc.perform(get("/usuarios"))
			.andExpect(status().isOk())
			.andExpect(jsonPath("$").isArray());
	}
}
```
{% endraw %}`

### Puntos clave

* Usa un contexto real de Spring con dependencias cargadas.
* Permite pruebas HTTP simuladas con MockMvc.
* Integra f√°cilmente bases de datos en memoria como H2.

---

## üß± Testing de Bases de Datos con Testcontainers

Permite ejecutar bases de datos reales (PostgreSQL, MySQL, MongoDB) en contenedores Docker durante los tests.

{% raw %}
```java
@Testcontainers
@SpringBootTest
class RepositorioUsuarioIT {

	@Container
	static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16")
		.withDatabaseName("testdb")
		.withUsername("user")
		.withPassword("pass");

	@Autowired
	private RepositorioUsuario repo;

	@Test
	void debeGuardarYRecuperarUsuario() {
		Usuario u = new Usuario("Carlos");
		repo.save(u);
		assertEquals("Carlos", repo.findById(u.getId()).get().getNombre());
	}
}
```
{% endraw %}

Ventajas:

* Pruebas realistas, sin mocks.
* Reproduce entornos productivos.
* Limpieza autom√°tica al finalizar los tests.

---

## üß™ Testing de APIs REST con JUnit + RestAssured

{% raw %}
```java
import static io.restassured.RestAssured.*;
import static org.hamcrest.Matchers.*;

@Test
void debeRetornarUsuarios() {
	given()
		.when().get("/usuarios")
		.then()
		.statusCode(200)
		.body("size()", greaterThan(0));
}
```
{% endraw %}

* Ideal para testing E2E de endpoints reales.
* Permite validar cabeceras, c√≥digos HTTP y payloads JSON.

---

## ‚öôÔ∏è Testeo de Eventos, Jobs y Colas

JUnit tambi√©n puede validar comportamientos as√≠ncronos o basados en colas como Kafka, [RabbitMQ](/backend/rabbitmq/) o Spring Events.

{% raw %}
```java
@ExtendWith(MockitoExtension.class)
class EventoUsuarioTest {

	@Mock
	private ApplicationEventPublisher publisher;

	@InjectMocks
	private ServicioUsuario servicio;

	@Test
	void debePublicarEventoAlCrearUsuario() {
		servicio.crearUsuario("Ana");
		verify(publisher).publishEvent(any(UsuarioCreadoEvent.class));
	}
}
```
{% endraw %}

Puntos clave:

* Validar la emisi√≥n de eventos.
* Usar `awaitility` para esperar eventos asincr√≥nicos.
* Testear consumidores o handlers espec√≠ficos.

---

## üß† Patrones de Testing en JUnit

### 1. **Given-When-Then**

Facilita la lectura de tests como escenarios de comportamiento.

{% raw %}
```java
// Given
Usuario u = new Usuario("Pedro");
// When
u.activar();
// Then
assertTrue(u.isActivo());
```
{% endraw %}

### 2. **Object Mother**

Centraliza la creaci√≥n de objetos de prueba.

{% raw %}
```java
class UsuarioMother {
	static Usuario activo() {
		Usuario u = new Usuario("Activo");
		u.activar();
		return u;
	}
}
```
{% endraw %}

### 3. **Fixture**

Inicializa datos comunes a varios tests usando `@BeforeEach`.

### 4. **Parameterized Behavior**

Reduce duplicaci√≥n en tests similares usando `@MethodSource`.

---

## üß© Extensiones de JUnit 5

JUnit 5 permite crear **extensiones personalizadas** (similar a middlewares).

{% raw %}
```java
public class TiempoDeEjecucionExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback {
	public void beforeTestExecution(ExtensionContext ctx) { start = System.currentTimeMillis(); }
	public void afterTestExecution(ExtensionContext ctx) {
		System.out.println(ctx.getDisplayName() + " ejecutado en " + (System.currentTimeMillis() - start) + " ms");
	}
}
```
{% endraw %}

Aplicaci√≥n:

{% raw %}
```java
@ExtendWith(TiempoDeEjecucionExtension.class)
class MiTest {}
```
{% endraw %}

Permite:

* Medir tiempos.
* Inyectar dependencias personalizadas.
* Aplicar configuraciones globales.

---

## üß≠ Testing de Rendimiento y Carga Ligera

Para microbenchmarks o validaci√≥n de rendimiento b√°sico:

{% raw %}
```java
@Test
void debeEjecutarseEnMenosDe200ms() {
	long start = System.currentTimeMillis();
	servicio.procesarDatos();
	assertTrue(System.currentTimeMillis() - start < 200);
}
```
{% endraw %}

Tambi√©n se puede integrar con:

* JMH (Java Microbenchmark Harness)
* Gatling para escenarios de carga HTTP
* JUnit Performance Plugin

---

## üîÑ Pruebas Condicionales y Din√°micas

JUnit permite ejecutar tests seg√∫n condiciones del entorno o generar tests din√°micos en tiempo de ejecuci√≥n.

{% raw %}
```java
@EnabledOnOs(OS.WINDOWS)
@DisabledIfEnvironmentVariable(named = "CI", matches = "true")
@Test
void soloEnLocalWindows() { ... }

@TestFactory
Stream<DynamicTest> testGenerado() {
	return Stream.of("a", "b", "c")
		.map(letra -> dynamicTest("Prueba con " + letra,
			() -> assertTrue(letra.matches("[a-c]"))));
}
```
{% endraw %}

---

## üß∞ Integraci√≥n con Arquitectura Limpia y [DDD Domain-Driven Design](/computer%20science/ddd-domain-driven-design/)

Los tests deben reflejar la arquitectura del dominio:

* Tests de **dominio puro** sin dependencias externas.
* Tests de **infraestructura** con adaptadores reales o mocks.
* Tests de **aplicaci√≥n** verificando flujos completos.

Organizaci√≥n sugerida:

{% raw %}
```
src/test/java
‚îÇ
‚îú‚îÄ‚îÄ dominio/
‚îú‚îÄ‚îÄ aplicacion/
‚îî‚îÄ‚îÄ infraestructura/
```
{% endraw %}

---

## üìö Recursos complementarios

* Mockito avanzado y testeo de excepciones en JUnit
* Testing de integraci√≥n con Docker y Spring Boot
* JUnit 5 Extensions API
* Patrones de testing en arquitectura hexagonal
* Testing continuo con CI/CD y reportes JUnit XML
* Performance Testing con JMH y JUnit

# üß™ JUnit - Casos Reales de Testing en Proyectos Java
`$= dv.current().file.tags.join(" ")`

- [JUnit](/junit/junit/)
- Mockito
- Spring Boot
- Testcontainers
- Testing de APIs
- Arquitectura Hexagonal

---

## üß© Caso 1: Testing de un Servicio con Dependencias

Prueba t√≠pica de un **servicio de dominio** que depende de un repositorio o cliente externo.  
Usamos `@Mock` y `@InjectMocks` para aislar la l√≥gica.

{% raw %}
```java
@ExtendWith(MockitoExtension.class)
class ServicioPedidoTest {

	@Mock
	private RepositorioPedido repo;

	@InjectMocks
	private ServicioPedido servicio;

	@Test
	void debeCrearPedidoYGuardarEnRepositorio() {
		Pedido pedido = new Pedido("producto-123", 2);
		when(repo.save(any())).thenReturn(pedido);

		Pedido resultado = servicio.crearPedido("producto-123", 2);

		assertEquals("producto-123", resultado.getProductoId());
		verify(repo, times(1)).save(any(Pedido.class));
	}
}
```
{% endraw %}`

### Puntos clave

- Se valida el flujo sin acceder a la base de datos.
    
- `verify()` asegura que la interacci√≥n ocurri√≥ como se esperaba.
    
- Se controla completamente el entorno del test.
    

---

## ‚öôÔ∏è Caso 2: Testing de Controladores REST con Spring Boot y MockMvc

Simula peticiones HTTP sin necesidad de servidor real.

{% raw %}
```java
@SpringBootTest
@AutoConfigureMockMvc
class ControladorProductoTest {

	@Autowired
	private MockMvc mockMvc;

	@Test
	void debeRetornarListaDeProductos() throws Exception {
		mockMvc.perform(get("/productos"))
			.andExpect(status().isOk())
			.andExpect(jsonPath("$.length()").value(greaterThan(0)));
	}
}
```
{% endraw %}

### Ventajas

- Evita levantar un servidor real.
    
- Permite validar rutas, payloads y respuestas HTTP.
    
- Integra con Jackson para serializaci√≥n/deserializaci√≥n JSON.
    

---

## üß± Caso 3: Testing con Testcontainers + PostgreSQL

Ejemplo de prueba de integraci√≥n contra una base de datos real.

{% raw %}
```java
@Testcontainers
@SpringBootTest
class RepositorioProductoIT {

	@Container
	static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16")
		.withDatabaseName("productos_test")
		.withUsername("test")
		.withPassword("test");

	@Autowired
	private RepositorioProducto repo;

	@Test
	void debeGuardarYRecuperarProducto() {
		Producto p = new Producto("Taza cer√°mica", 12.5);
		repo.save(p);

		Optional<Producto> recuperado = repo.findByNombre("Taza cer√°mica");
		assertTrue(recuperado.isPresent());
		assertEquals(12.5, recuperado.get().getPrecio());
	}
}
```
{% endraw %}

### Beneficios

- Crea un entorno reproducible con datos reales.
    
- No requiere configuraci√≥n manual de base de datos.
    
- Limpieza autom√°tica tras la ejecuci√≥n.
    

---

## üì¶ Caso 4: Testing de Publicaci√≥n de Eventos

Simula el comportamiento de **eventos de dominio o aplicaci√≥n** al ejecutarse una acci√≥n.

{% raw %}
```java
@ExtendWith(MockitoExtension.class)
class ServicioUsuarioTest {

	@Mock
	private ApplicationEventPublisher publisher;

	@InjectMocks
	private ServicioUsuario servicio;

	@Test
	void debePublicarEventoAlRegistrarUsuario() {
		servicio.registrarUsuario("Juan", "correo@ejemplo.com");
		verify(publisher).publishEvent(any(UsuarioRegistradoEvent.class));
	}
}
```
{% endraw %}

### Notas

- Ideal para sistemas basados en Event Driven Architecture.
    
- Se testean los **efectos colaterales** del dominio sin ejecutar el listener real.
    

---

## üß† Caso 5: Testing de Validaciones y Excepciones

Verifica que el dominio arroje errores cuando se incumplen reglas.

{% raw %}
```java
@Test
void debeLanzarExcepcionSiElPrecioEsNegativo() {
	IllegalArgumentException ex = assertThrows(IllegalArgumentException.class, () -> {
		new Producto("Camisa", -10);
	});
	assertEquals("El precio no puede ser negativo", ex.getMessage());
}
```
{% endraw %}

### Recomendaciones

- Testear cada regla de negocio por separado.
    
- Usar `assertThrows` para validar flujos de error.
    
- Mantener mensajes de error consistentes.
    

---

## üß© Caso 6: Testing Parametrizado de Reglas de Negocio

Reduce la duplicaci√≥n de tests al probar varias combinaciones.

{% raw %}
```java
@ParameterizedTest
@CsvSource({
	"100, true",
	"0, false",
	"-1, false"
})
void debeValidarMontoMinimo(double monto, boolean esperado) {
	assertEquals(esperado, ServicioPago.esMontoValido(monto));
}
```
{% endraw %}

### Beneficios

- Mayor cobertura con menos c√≥digo.
    
- Se documentan las entradas y salidas esperadas.
    
- Facilita testear funciones puras o est√°ticas.
    

---

## üåê Caso 7: Testing de APIs Externas con WireMock

Simula respuestas HTTP de un servicio externo (por ejemplo, una API de pagos o clima).

{% raw %}
```java
@ExtendWith(WireMockExtension.class)
@WireMockTest(httpPort = 8081)
class ClienteApiClimaTest {

	private ClienteApiClima cliente = new ClienteApiClima("http://localhost:8081");

	@Test
	void debeRetornarTemperaturaSimulada() {
		stubFor(get(urlEqualTo("/clima?ciudad=Madrid"))
			.willReturn(aResponse()
				.withStatus(200)
				.withHeader("Content-Type", "application/json")
				.withBody("{\"temperatura\":25}")));

		double temp = cliente.obtenerTemperatura("Madrid");
		assertEquals(25, temp);
	}
}
```
{% endraw %}

### Casos de uso comunes

- Simular APIs de terceros.
    
- Probar manejo de errores HTTP.
    
- Validar reintentos y timeouts.
    

---

## üîÅ Caso 8: Testing As√≠ncrono con Awaitility

Verifica procesos que tardan en completarse o dependen de hilos.

{% raw %}
```java
import static org.awaitility.Awaitility.*;

@Test
void debeProcesarColaDePedidosEnMenosDe5Segundos() {
	servicio.enviarPedidosPendientes();

	await().atMost(5, TimeUnit.SECONDS)
		.until(() -> servicio.todosProcesados());
}
```
{% endraw %}

### Ideal para

- Jobs en segundo plano.
    
- Procesamiento de colas.
    
- Tests E2E controlados.
    

---

## üßÆ Caso 9: Testing de Performance Ligero

Eval√∫a tiempo m√°ximo permitido de ejecuci√≥n.

{% raw %}
```java
@Test
void debeEjecutarseEnMenosDe300ms() {
	long inicio = System.nanoTime();
	servicio.procesarLote(1000);
	long duracion = (System.nanoTime() - inicio) / 1_000_000;
	assertTrue(duracion < 300, "El procesamiento fue demasiado lento: " + duracion + " ms");
}
```
{% endraw %}

### Mejores pr√°cticas

- √ösalo como indicador, no como m√©trica absoluta.
    
- Evita tiempos muy ajustados que dependan del entorno.
    

---

## üß≠ Caso 10: Testing de Arquitectura con ArchUnit

Valida reglas de estructura en el c√≥digo (por ejemplo, dependencias entre capas).

{% raw %}
```java
import com.tngtech.archunit.junit.AnalyzeClasses;
import com.tngtech.archunit.junit.ArchTest;
import com.tngtech.archunit.lang.syntax.ArchRuleDefinition;

@AnalyzeClasses(packages = "com.miapp")
class ArquitecturaTest {

	@ArchTest
	static final ArchRule serviciosNoDebenDependerDeControladores =
		ArchRuleDefinition.noClasses()
			.that().resideInAPackage("..servicio..")
			.should().dependOnClassesThat().resideInAPackage("..controlador..");
}
```
{% endraw %}

### Beneficio

- Asegura adherencia a la arquitectura limpia o hexagonal.
    
- Detecta dependencias circulares y malas pr√°cticas.
    

---

## ‚úÖ Resumen

|Tipo de Test|Herramienta Principal|Objetivo|
|---|---|---|
|Unitario|JUnit + Mockito|L√≥gica aislada|
|Integraci√≥n|JUnit + Testcontainers|Persistencia real|
|API REST|MockMvc / RestAssured|Validar endpoints|
|Eventos / As√≠ncronos|Mockito / Awaitility|Flujos paralelos|
|Externos|WireMock|Simular dependencias|
|Performance|JUnit|Medir tiempos b√°sicos|
|Arquitectura|ArchUnit|Reglas estructurales|

---

## üìö Recursos complementarios

- Testcontainers con Docker Compose y JUnit
- WireMock para simular APIs externas
- Awaitility - Testing As√≠ncrono en Java
- ArchUnit - Validaci√≥n de Arquitecturas
- Buenas pr√°cticas de testing en microservicios

# üß© Patrones Avanzados de Testing y Estrategias de Mantenimiento de Test Suites
`$= dv.current().file.tags.join(" ")`

- [JUnit](/junit/junit/)
- [Testing](/testing/testing/)
- Arquitectura de Tests
- Refactorizaci√≥n
- CI/CD
- Java

---

## üß† Objetivo

El prop√≥sito de esta nota es unificar los **patrones avanzados de dise√±o de tests** y las **estrategias de mantenimiento** que garantizan calidad, legibilidad y escalabilidad en suites de testing profesionales.  
Aplicable a entornos con JUnit 5, Spring Boot, Mockito y arquitecturas [DDD Domain-Driven Design](/computer%20science/ddd-domain-driven-design/) o Hexagonal.

---

## üß© 1. Patr√≥n: **Object Mother**

Centraliza la creaci√≥n de objetos complejos usados en m√∫ltiples tests, reduciendo duplicaci√≥n.

{% raw %}
```java
public class UsuarioMother {

	public static Usuario activo() {
		Usuario u = new Usuario("Carlos", "carlos@correo.com");
		u.activar();
		return u;
	}

	public static Usuario inactivo() {
		return new Usuario("Ana", "ana@correo.com");
	}
}
```
{% endraw %}`

Uso:

{% raw %}
```java
@Test
void debeEnviarCorreoAUsuarioActivo() {
	Usuario usuario = UsuarioMother.activo();
	servicio.enviarCorreo(usuario);
	assertTrue(usuario.tieneCorreoPendiente());
}
```
{% endraw %}

### Ventajas

* Reutilizaci√≥n de datos de prueba coherentes.
* Centralizaci√≥n de constructores repetidos.
* F√°cil mantenimiento si cambian los modelos del dominio.

---

## üß± 2. Patr√≥n: **Data Builder**

Permite crear objetos de prueba de forma expresiva y configurable.

{% raw %}
```java
public class PedidoBuilder {
	private String producto = "Taza";
	private int cantidad = 1;
	private double precio = 9.99;

	public static PedidoBuilder unPedido() { return new PedidoBuilder(); }

	public PedidoBuilder conCantidad(int cantidad) {
		this.cantidad = cantidad;
		return this;
	}

	public PedidoBuilder conPrecio(double precio) {
		this.precio = precio;
		return this;
	}

	public Pedido construir() {
		return new Pedido(producto, cantidad, precio);
	}
}
```
{% endraw %}

Uso:

{% raw %}
```java
@Test
void debeCalcularTotalCorrecto() {
	Pedido pedido = PedidoBuilder.unPedido().conCantidad(3).conPrecio(5.0).construir();
	assertEquals(15.0, pedido.total());
}
```
{% endraw %}

### Beneficios

* Claridad sem√°ntica en los tests.
* Independencia de constructores extensos.
* Facilita agregar nuevos atributos sin romper tests.

---

## üß™ 3. Patr√≥n: **Test Fixture Reutilizable**

Usar `@BeforeEach` o clases base de test para inicializar datos y mocks comunes.

{% raw %}
```java
abstract class BaseTest {
	protected ServicioUsuario servicio;
	protected RepositorioUsuario repo;

	@BeforeEach
	void setup() {
		repo = mock(RepositorioUsuario.class);
		servicio = new ServicioUsuario(repo);
	}
}

class ServicioUsuarioTest extends BaseTest {

	@Test
	void debeGuardarUsuario() {
		when(repo.save(any())).thenReturn(new Usuario("Juan"));
		assertEquals("Juan", servicio.crearUsuario("Juan").getNombre());
	}
}
```
{% endraw %}

### Ventajas

* Reutilizaci√≥n de configuraci√≥n.
* Menos repetici√≥n en suites grandes.
* Facilita migraci√≥n entre frameworks.

---

## ‚öôÔ∏è 4. Patr√≥n: **Fakes, Stubs, Mocks y Spies**

| Tipo     | Prop√≥sito                         | Ejemplo                     |
| -------- | --------------------------------- | --------------------------- |
| **Fake** | Implementaci√≥n simplificada real. | Fake DB en memoria          |
| **Stub** | Devuelve respuestas predefinidas. | `when(...).thenReturn(...)` |
| **Mock** | Verifica interacciones.           | `verify(...)`               |
| **Spy**  | Observa llamadas reales.          | `spy(new ServicioReal())`   |

Ejemplo:

{% raw %}
```java
@Test
void debeGuardarUsuarioConFakeRepositorio() {
	RepositorioUsuarioFake repo = new RepositorioUsuarioFake();
	ServicioUsuario servicio = new ServicioUsuario(repo);

	servicio.crearUsuario("Ana");
	assertEquals(1, repo.count());
}
```
{% endraw %}

---

## üîÑ 5. Patr√≥n: **Snapshot Testing en Java**

Permite comparar salidas complejas con una versi√≥n ‚Äúguardada‚Äù (snapshot).
Se usa en serializaci√≥n JSON o respuestas API.

Ejemplo con JSONAssert:

{% raw %}
```java
@Test
void debeCoincidirConSnapshotEsperado() throws Exception {
	String jsonActual = mapper.writeValueAsString(new Producto("Taza", 10.0));
	String jsonEsperado = Files.readString(Path.of("src/test/resources/snapshots/producto.json"));
	JSONAssert.assertEquals(jsonEsperado, jsonActual, false);
}
```
{% endraw %}

Ventajas:

* Detecta regresiones visuales.
* Facilita validar respuestas API.
* Documenta el estado esperado de objetos complejos.

---

## üß≠ 6. Patr√≥n: **Testing por Capas (Arquitectura Hexagonal)**

Separar tests seg√∫n el nivel de abstracci√≥n:

{% raw %}
```
src/test/java
‚îÇ
‚îú‚îÄ‚îÄ dominio/           ‚Üí l√≥gica pura
‚îú‚îÄ‚îÄ aplicacion/        ‚Üí casos de uso y servicios
‚îú‚îÄ‚îÄ infraestructura/   ‚Üí bases de datos, APIs, colas
‚îî‚îÄ‚îÄ presentacion/      ‚Üí controladores o endpoints
```
{% endraw %}

### Reglas

* Los tests de dominio no deben usar Spring ni dependencias externas.
* Los tests de infraestructura pueden usar Testcontainers.
* Los tests de aplicaci√≥n validan integraci√≥n entre capas.

---

## ‚ö° 7. Patr√≥n: **Given-When-Then (GWT)**

Estructura narrativa para describir casos de uso con claridad.

{% raw %}
```java
@Test
void debeAplicarDescuentoEnPedidoPremium() {
	// Given
	Pedido pedido = PedidoBuilder.unPedido().conPrecio(100).conCantidad(1).construir();

	// When
	pedido.aplicarDescuento(10);

	// Then
	assertEquals(90, pedido.total());
}
```
{% endraw %}

Beneficio: mejora la legibilidad y la trazabilidad de los escenarios.

---

## üß∞ 8. Estrategias de Mantenimiento de Suites de Tests

### üîπ Agrupaci√≥n l√≥gica por contexto

Usa `@Nested` para agrupar tests relacionados.

{% raw %}
```java
class ServicioPagoTest {

	@Nested
	class Validaciones {
		@Test void debeRechazarPagoInvalido() { ... }
	}

	@Nested
	class Procesamiento {
		@Test void debeConfirmarPago() { ... }
	}
}
```
{% endraw %}

### üîπ Nombres descriptivos

Usar `@DisplayName` o convenciones expresivas:

* `debeGenerarFacturaCuandoPedidoEsValido()`
* `shouldThrowExceptionWhenUserNotFound()`

### üîπ Evitar dependencias externas

Usar mocks o fakes, no llamadas reales.

### üîπ Minimizar fragilidad

Evita depender de datos de entorno, fechas, o aleatoriedad.

### üîπ Separar datos de configuraci√≥n

Usar archivos de recursos (`.json`, `.yml`, `.csv`) en `/src/test/resources`.

---

## üì¶ 9. Mantenimiento Continuo y Refactorizaci√≥n de Tests

* Revisar tests obsoletos cada sprint.
* Eliminar redundancias entre clases similares.
* Centralizar la l√≥gica de asserts repetitivos en helpers.

{% raw %}
```java
public class Asserts {
	public static void assertUsuarioActivo(Usuario u) {
		assertTrue(u.isActivo());
		assertNotNull(u.getFechaActivacion());
	}
}
```
{% endraw %}

Uso:

{% raw %}
```java
Asserts.assertUsuarioActivo(usuario);
```
{% endraw %}

---

## üîÅ 10. Estrategias de Ejecuci√≥n en CI/CD

* Ejecutar tests unitarios en cada push (`fast feedback`).
* Ejecutar tests de integraci√≥n en pipelines nocturnos.
* Generar reportes JUnit XML o HTML (con Allure o Surefire).
* Definir umbrales de cobertura m√≠nima con JaCoCo.
* Integrar con SonarQube para an√°lisis est√°tico.

Ejemplo de pipeline:

{% raw %}
```yaml
# .github/workflows/tests.yml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v3
        with:
          java-version: '21'
      - run: mvn test
      - run: mvn jacoco:report
```
{% endraw %}

---

## üßÆ 11. Patr√≥n: **Golden Master Testing**

Para sistemas legacy sin tests previos:

1. Captura la salida actual de funciones cr√≠ticas.
2. Usa esa salida como referencia.
3. Compara con futuras ejecuciones para detectar cambios inesperados.

Ideal cuando el comportamiento debe preservarse sin alterar la implementaci√≥n.

---

## üß© 12. Estrategias para Grandes Suites

| Estrategia               | Descripci√≥n                             | Herramienta sugerida                             |
| ------------------------ | --------------------------------------- | ------------------------------------------------ |
| **Parallel Tests**       | Ejecutar tests en hilos simult√°neos.    | `@Execution(CONCURRENT)`                         |
| **Tagging**              | Ejecutar subconjuntos (`@Tag("slow")`). | `mvn test -Dgroups=slow`                         |
| **Reportes Visuales**    | Reportes HTML interactivos.             | Allure, ExtentReports                    |
| **Test Impact Analysis** | Solo ejecuta tests afectados.           | Integraci√≥n con GitHub Actions o Jenkins |
|                          |                                         |                                                  |

---

## üß≠ 13. Anti-patrones comunes

* **Overmocking:** exceso de mocks que rompen la l√≥gica real.
* **Fragile tests:** dependen de implementaciones internas.
* **Huge Fixtures:** setups demasiado grandes o lentos.
* **Copy-paste testing:** duplicar casos similares sin sentido.
* **No asserts:** tests que no verifican nada relevante.

---

## üìö Recursos complementarios

* Arquitectura limpia en testing con JUnit
* Data Builders y Object Mothers en pr√°ctica
* Testing en entornos legacy con Golden Master
* Allure Report y m√©tricas de test en CI/CD
* Refactorizaci√≥n de suites de test grandes
* Testing maintainable codebases

