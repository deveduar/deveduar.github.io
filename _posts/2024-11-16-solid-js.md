---
date: 2024-11-16 22:26
title: solid.js
tags:
  - solidjs
  - JS
  - webcomponents
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Frontend
public_note: "true"
category: Frontend
---
# Solid.js
`$= dv.current().file.tags.join(" ")`

[Frontend](/uncategorized/frontend/)
[Web Components](/frontend/web-components/)

## Recursos y enlaces
- [Examples | SolidJS](https://www.solidjs.com/examples/counter)
- Curso: *Reactivity with SolidJS*
- Web Components manuales
- meteorjs
	- [Meteor.js](https://www.meteor.com/)
		- [GitHub - meteor/examples](https://github.com/meteor/examples)

## Conceptos fundamentales
- Librer√≠a orientada a la reactividad fina (fine-grained reactivity).
- Sistema reactivo sin Virtual DOM, basado en se√±ales.
- Enfoque declarativo, derivaciones y dependencias calculadas din√°micamente.
- Interoperabilidad con ecosistemas como [react](/frontend/react/) o integraciones con Web Components.

## Reactivity System
- **Fine Grained Signals**: actualizaci√≥n espec√≠fica de nodos reactivos.
	- `update`: cambia el valor.
	- `notify`: comunica dependencias.
	- `trigger`: ejecuta efectos derivados.
- **get / set**: acceso y mutaci√≥n controlada del estado.
- **Side effects**: ejecutados cuando las se√±ales cambian.
- **createSignal**: estado reactivo principal.
- **createEffect**: efectos derivados autom√°ticos.
- **createMemo**: derivaci√≥n basada en dependencias; optimiza c√°lculos costosos.
- **Dynamic Tracking**:
	- Seguimiento autom√°tico de dependencias.
	- `untrack`: evita tracking.
	- `batch`: agrupa cambios para evitar renders innecesarios.
- **Reactive Streams**: integraci√≥n conceptual con Rx pero usando se√±ales.
- **Dependences Graph**: grafo interno que optimiza propagaciones.

## Patrones comunes
- Minimizar renders mediante se√±ales at√≥micas.
- Modelar flujos complejos usando efectos encadenados.
- Dividir l√≥gica derivada en `createMemo` para mejorar rendimiento.
- Encapsular patrones reactivos en *custom hooks* (funciones reutilizables).

---

# Web Components y solid

### Se√±ales y efectos b√°sicos (Solid.js)
{% raw %}
```js
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
	console.log("El valor cambi√≥:", count());
});

setCount(count() + 1);
```
{% endraw %}`

### Memo y derivaciones

{% raw %}
```js
const [price, setPrice] = createSignal(10);
const [qty, setQty] = createSignal(2);

const total = createMemo(() => price() * qty());

console.log(total()); // 20
```
{% endraw %}

### Custom Element b√°sico

{% raw %}
```js
class MyElement extends HTMLElement {
	constructor() {
		super();
		const shadow = this.attachShadow({ mode: "open" });
		shadow.innerHTML = `<p>Hola Web Component</p>`;
	}
}

customElements.define("my-element", MyElement);
```
{% endraw %}

# Solid.js ‚Äî Conceptos avanzados y temas no cubiertos

## Nuevos temas necesarios
A continuaci√≥n se ampl√≠an √°reas que a√∫n no estaban presentes en tu nota anterior y que son esenciales para comprender Solid.js en profundidad sin repetir lo ya cubierto.

---

## Compilaci√≥n, Renderizado y Arquitectura Interna

### Rendering basado en *DOM Real*
- Solid ejecuta JSX en tiempo de compilaci√≥n, generando directamente nodos DOM.
- No usa Virtual DOM ni diffing; la reactividad dirige el update exacto.
- Las dependencias se vuelven nodos reactivos conectados a fragmentos concretos del DOM.

### Optimizaci√≥n por *dom expressions*
- El compilador transforma JSX en instrucciones DOM eficientes.
- Evita crear closures innecesarias.
- Minimiza re-renderizaciones actualizando solo las partes afectadas.

### Root, Dispose y Ciclos de Vida
- `createRoot(fn)` crea un contexto reactivo aislado.
- `onCleanup(fn)` permite ejecutar l√≥gica al destruir un efecto o componente.
- Evita fugas de memoria al trabajar con subscripciones, listeners o workers.

---

## Control de Flujo Reactivo
Solid reemplaza el cl√°sico control de flujo declarativo por uno *imperativo-reactivo*.

### Show / For / Switch
{% raw %}
```jsx
<Show when={loggedIn()} fallback={<p>Invitado</p>}>
	<p>Bienvenido!</p>
</Show>
```
{% endraw %}`

### Control granular

* Nada se vuelve a renderizar excepto el nodo dependiente.
* `For` optimiza listas mediante *reconciliation* individual basada en valores clave.

---

## Stores y Estado Estructurado

### createStore

* Estado anidado e inmutable por defecto, con actualizaciones profundas.
* Ideal para modelos complejos o estructuras JSON.

{% raw %}
```js
import { createStore } from "solid-js/store";

const [user, setUser] = createStore({ name: "ana", scores: [1,2,3] });
setUser("scores", 1, 99);
```
{% endraw %}

### Diferencias importantes respecto a Signals

* Signals = valores primitivos / at√≥micos.
* Stores = estado estructurado con proxies.

---

## Context API

* Sistema para compartir estado global sin pasar props.
* Similar a React Context pero reactivo y m√°s eficiente.

{% raw %}
```jsx
const UserContext = createContext();

<UserContext.Provider value={user}>
	<App />
</UserContext.Provider>
```
{% endraw %}

---

## Control de ejecuci√≥n y rendimiento

### batch

* Agrupa m√∫ltiples sets sin disparar efectos hasta el final.
* Similar a un *transaction*.

### untrack en profundidad

* Evita que un c√°lculo quede vinculado al grafo de dependencias.
* √ötil para c√°lculos puntuales, logs, mediciones.

### Suspense y recursos as√≠ncronos

* Manejo del estado de carga con `createResource`.
* Ideal para peticiones HTTP integradas en el flujo reactivo.

{% raw %}
```js
const [data] = createResource(fetchUser);
```
{% endraw %}

---

## Integraci√≥n con SSR e Islas

### SolidStart

* Framework oficial para SSR y routing.
* Soporta "islas" de interactividad con rehidrataci√≥n m√≠nima.
* Optimiza env√≠o de JS mediante *splitting* autom√°tico.

### Streaming SSR

* Se puede enviar HTML de forma progresiva.
* Reduce el TTFB y mejora la carga en conexiones lentas.

---

## Control de Eventos y Reactividad Estricta

### Delegation de eventos

* Solid hace *event delegation* autom√°tica al `document.body`.
* Menos listeners ‚Üí mejor rendimiento.

### Reactividad estable

* Nunca re-renderiza componentes completos.
* S√≥lo se actualizan los nodos dependientes.
* La UI siempre refleja exactamente el estado actual sin inconsistencias.

---

## Component Patterns avanzados

### Componentes sin estado

* Si un componente solo recibe se√±ales, no necesita su propio grafo.
* Menor coste de inicializaci√≥n.

### Custom primitives

Ejemplo de *hook* reactivo reutilizable:

{% raw %}
```js
function createCounter(initial = 0) {
	const [count, setCount] = createSignal(initial);
	const inc = () => setCount(c => c + 1);
	return { count, inc };
}
```
{% endraw %}

---

## Integraciones Externas y Edge Cases

### Con Web Components

* Solid puede renderizar dentro de *custom elements* sin conflictos.
* Se recomienda usar se√±ales para mapear props/atributos.

### Con React / Vue / Svelte

* Usar Solid para widgets aislados dentro de apps grandes.
* Comportamiento ideal en microfrontends.

### Integraciones gr√°ficas

* Solid funciona bien con Canvas/WebGL porque el DOM apenas se re-renderiza.
* Signals pueden disparar repaints manuales sin coste extra.

---

## Herramientas, pruebas y debugging

### Devtools de Solid

* Muestra grafo de dependencias.
* Se pueden inspeccionar se√±ales, efectos y memos individualmente.

### Testing

* `@solidjs/testing-library` similar a React Testing Library.
* Testea comportamiento observable sin centrarse en implementaci√≥n.

---

## Temas avanzados sugeridos para notas futuras

* **Hydration Fine-tuning**: hidrataci√≥n parcial y nodos inertes.
* **Concurrent Patterns**: control de latencia y prioridad (no es React Concurrent Mode).
* **Compiler Directives**: `/* @once */`, `/* @sample */` y optimizaciones internas.
* **Control de fugas de reacci√≥n** en subscripciones complejas.
* **Creaci√≥n de renders personalizados** para Canvas, SVG intensivo o motores 2D.

---

# Solid.js (2025) ‚Äî Panorama actualizado y recursos recomendados

## Qu√© es Solid.js hoy  
- Solid.js es una librer√≠a JavaScript para construir interfaces de usuario con reactividad fina (fine-grained reactivity), sin Virtual DOM: los templates se compilan a nodos reales del DOM y s√≥lo se actualizan las partes estrictamente necesarias.  
- Gracias a su dise√±o: alto rendimiento, bajo uso de memoria/CPU, actualizaciones precisas y m√≠nima sobrecarga, Solid sigue siendo considerada de las librer√≠as m√°s r√°pidas y eficientes en 2025.  

## Documentaci√≥n y recursos oficiales  
- [Documentaci√≥n oficial de Solid.js](https://docs.solidjs.com/) ‚Äî gu√≠a, tutoriales, referencia API.  
- Repositorio oficial: [solidjs/solid ¬∑ GitHub](https://github.com/solidjs/solid) ‚Äî c√≥digo fuente, ejemplos, plantilla de arranque.  
- Ecosistema, utilidades y librer√≠as complementarias: listadas en [Awesome Solid.js](https://sveltethemes.dev/one-aalam/awesome-solid-js) ‚Äî incluye tutoriales, paquetes, ejemplos y m√°s.  
- [GitHub - one-aalam/awesome-solid-js: Curated resources on building sites with SolidJS,](https://github.com/one-aalam/awesome-solid-js) 

## Tutoriales, cursos y recursos formativos actuales  
- Curso en espa√±ol: [Curso de SolidJS en Platzi](https://platzi.com/cursos/solidjs/) ‚Äî ideal para empezar con reactividad, se√±ales, efectos, memos, stores, etc.  
- Libro (en ingl√©s) actualizado en 2025: [SolidJS: The Complete Guide](https://leanpub.com/solid-js) ‚Äî cubre desde lo b√°sico hasta SSR, routing, integraci√≥n con SolidStart, desarrollo real de aplicaciones.  
- Art√≠culo contextual sobre su adopci√≥n en 2025: ‚ÄúThe JavaScript Framework Revolution‚Äù ‚Äî menciona Solid como alternativa a React por su rendimiento superior.  

## Caracter√≠sticas modernas y soporte t√©cnico  

### Qu√© ofrece Solid  
- Actualizaciones reactivas finas: se√±ales, efectos, memos, seguimiento autom√°tico de dependencias.  
- Renderizado directo al DOM real, con m√≠nima abstracci√≥n: componentes como funciones, ‚Äúrun-once + reactividad dependiente‚Äù.  
- Soporte para caracter√≠sticas modernas: Context API, stores, estado estructurado, JSX/TypeScript, render isom√≥rfico (cliente + servidor), Suspense, SSR, integraci√≥n con Web Components, renderizadores personalizados.  
- Ecosistema vivo: librer√≠as complementarias, utilidades, ejemplos, plantillas de inicio, comunidad activa.  

### Estado del proyecto y mantenimiento en 2025  
- Solid no sigue un esquema formal de ‚ÄúLTS / EOL‚Äù; no obstante, la librer√≠a core est√° bastante madura (versiones 1.x), con API estable.  
- El desarrollo activo se centra en meta-frameworks, herramientas, optimizaci√≥n y utilidades, m√°s que en cambios radicales del core.  

## Qu√© hace a Solid relevante en 2025  
- Alternativa real a frameworks basados en Virtual DOM: comparable a React en mental model + JSX, pero con rendimiento cercano al *vanilla JS*.  
- √ötil para proyectos que buscan rendimiento, experiencia fluida, bajo coste en renderizado y eficiencia, especialmente en aplicaciones grandes con mucha interactividad.  
- Con su ecosistema creciente, Solid permite crear SPAs, SSR, rutas, stores, apps isom√≥rficas ‚Äî completamente viable en producci√≥n en 2025.  

## Consejos para aprender y adoptar Solid.js hoy  
- Comienza por la documentaci√≥n oficial y prueba los ejemplos en el playground.  
- Usa un curso estructurado (como el de Platzi) o el libro ‚ÄúSolidJS: The Complete Guide‚Äù si vienes de React/Vue.  
- Explora el ecosistema antes de implementar utilidades desde cero.  
- Para proyectos medianos/grandes, considera usar meta-frameworks desde el inicio (SSR, routing, modularizaci√≥n).  

## En resumen  
Solid.js en 2025 es una librer√≠a moderna, madura y muy eficiente para el desarrollo frontend. Con documentaci√≥n s√≥lida, herramientas actuales, rendimiento sobresaliente y comunidad activa, es una opci√≥n excelente para proyectos nuevos que prioricen velocidad y claridad reactiva.
