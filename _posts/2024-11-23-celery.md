---
date: 2024-11-23 02:21
title: Celery
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
public_note: "true"
category: Automatizacion y Build
tags:
  - compilacion
  - testing
  - devops
  - runners
---
# Celery

- [devops](/devops/devops/)
- [python](/software%20engineering/python/)
- [Docker](/software%20engineering/docker/)
- [Backend](/backend/backend/)
- [Automatizacion y Build](/automatizacion%20y%20build/automatizacion-y-build/)
- [scraping](/automatizacion%20y%20build/scraping/)
- 
- conceptos
	- uso para produccion
	- tareas asincronas
	- task runner
	- balanceo de carga
	- task queues
	- multinube
- brokers
	- [redis](/databases/redis/)
	- [RabbitMQ](/backend/rabbitmq/)
- docs
	- [Celery Conceptos Avanzados y Configuraci√≥n Profesional](/uncategorized/celery-conceptos-avanzados-y-configuraci-n-profesional/)
	- [Celery Temas Avanzados Varios](/uncategorized/celery-temas-avanzados-varios/)
	- [Gu√≠a Pr√°ctica Completa de Celery](/uncategorized/gu-a-pr-ctica-completa-de-celery/)
	- **task queues**
		- Task Queues Temas Avanzados y Casos de Uso Especializados
		- Task Queues Patrones Empresariales y Optimizaciones
--- 
# Celery Task Queue para Aplicaciones Distribuidas

## Conceptos Fundamentales

### ¬øQu√© es Celery?
- **Task Runner** as√≠ncrono para Python
- Gestiona **colas de tareas** (task queues) en segundo plano
- Ideal para operaciones que no deben bloquear la respuesta principal
- Soporta **balanceo de carga** entre workers
- [Documentaci√≥n Oficial](https://docs.celeryq.dev/)
- [Docker Python Image](https://hub.docker.com/_/python/)
- [Gu√≠a Celery OpenWebinars](https://openwebinars.net/blog/que-es-celery-introduccion-y-primeros-pasos/) 
### Arquitectura Core
- **Client**: Aplicaci√≥n que env√≠a tareas
- **Broker**: Sistema de mensajer√≠a intermediario
- **Worker**: Procesa las tareas de la cola
- **Backend**: Almacena resultados de tareas

## Componentes Esenciales

### Brokers Soportados
- Redis: Popular para desarrollo y producci√≥n peque√±a/mediana
- [RabbitMQ](/backend/rabbitmq/): Robustez empresarial, m√°s caracter√≠sticas avanzadas
- Amazon SQS, Azure Service Bus para entornos **multinube**

### Caracter√≠sticas Clave
- **Tareas as√≠ncronas** para operaciones no cr√≠ticas en tiempo real
- **Programaci√≥n de tareas** con ejecuci√≥n diferida
- **Monitoreo** y administraci√≥n de workers
- **Retry autom√°tico** para fallos temporales
- **Agrupaci√≥n de tareas** (chords, chains)

## Monitoreo y Debugging

### Herramientas
- **Flower**: Monitor web para Celery
- **Logging** estructurado
- **M√©tricas** de rendimiento
- **Tracing** distribuido
## Casos de Uso Comunes

### Ejemplos Pr√°cticos
- Env√≠o de **correo tras registro** de usuario
- **Procesamiento de im√°genes/video** en segundo plano
- **An√°lisis de datos** pesados
- **Limpieza peri√≥dica** de bases de datos
- **Generaci√≥n de reportes** complejos
- **Web scraping** programado

## Configuraci√≥n en Producci√≥n

### Consideraciones para Producci√≥n
{% raw %}
```python
# Configuraci√≥n b√°sica para producci√≥n
app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='Europe/Madrid',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=30*60  # 30 minutos
)
```
{% endraw %}

### Escalabilidad
- M√∫ltiples **workers** para paralelizaci√≥n
- **Prefetching** configurable para optimizar recursos
- **Routing** de tareas a colas espec√≠ficas
- **Prioridades** en procesamiento

## Dockerizaci√≥n

### Configuraci√≥n con [Docker](/software%20engineering/docker/)
{% raw %}
```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
CMD ["celery", "-A", "proyecto", "worker", "--loglevel=info"]
```
{% endraw %}

### Orquestaci√≥n
- **Supervisord** para gesti√≥n de procesos
- **Docker Compose** para desarrollo local
- **Kubernetes** para escalabilidad en producci√≥n

## Automatizaci√≥n

### Integraci√≥n con [Automatizacion y Build](/automatizacion%20y%20build/automatizacion-y-build/)
- **CI/CD** pipelines que ejecutan tareas Celery
- **Despliegue autom√°tico** de workers
- **Health checks** para monitoreo
- **Escalado autom√°tico** basado en carga

## Patrones Avanzados

### Workflows Complejos
{% raw %}
```python
# Cadenas de tareas
chain(task1.s() | task2.s() | task3.s()).apply_async()

# Grupos paralelos
group([task1.s(i) for i in range(10)]).apply_async()

# Chord (grupo + callback)
chord(header=[task1.s(), task2.s()])(callback.s()).apply_async()
```
{% endraw %}

### Seguridad y Robustez
- **Acknowledgment** de tareas procesadas
- **Dead letter queues** para tareas fallidas
- **Rate limiting** para control de recursos
- **Autenticaci√≥n** en brokers

# Task Runners: Concepto y Diferencias con Task Queues

## ¬øQu√© es un Task Runner?

Un **Task Runner** es una herramienta o framework que automatiza la ejecuci√≥n de tareas, scripts y comandos. A diferencia de las Task Queues, los Task Runners se enfocan en la orquestaci√≥n y ejecuci√≥n secuencial/paralela de tareas definidas, generalmente en el mismo entorno o m√°quina.

## Diferencias Clave: Task Runners vs Task Queues

### Task Runners
- **Ejecuci√≥n local o directa**
- **Orquestaci√≥n de tareas** definidas
- **Dependencias entre tasks**
- **Build processes** y automatizaci√≥n
- **Desarrollo y deployment**

### Task Queues
- **Ejecuci√≥n as√≠ncrona distribuida**
- **Procesamiento en background**
- **Mensajer√≠a y colas**
- **Workers distribuidos**
- **Escalabilidad horizontal**

## Task Runners Populares

### 1. Make (El Cl√°sico)
{% raw %}
```makefile
# Makefile ejemplo
.PHONY: test build deploy

install:
	pip install -r requirements.txt

test:
	pytest tests/ -v

build:
	docker build -t mi-app .

deploy: test build
	docker push mi-app:latest

clean:
	rm -rf __pycache__ *.pyc
```
{% endraw %}

### 2. Invoke (Python)
{% raw %}
```python
# tasks.py
from invoke import task

@task
def test(c, coverage=False):
    """Ejecutar tests"""
    cmd = "pytest tests/"
    if coverage:
        cmd += " --cov=app"
    c.run(cmd)

@task
def deploy(c, environment='staging'):
    """Desplegar aplicaci√≥n"""
    c.run(f"ansible-playbook deploy.yml -i {environment}")

@task
def setup(c):
    """Setup completo del proyecto"""
    test(c)
    c.run("docker-compose build")
    c.run("docker-compose up -d")
```
{% endraw %}

### 3. NPM Scripts (JavaScript)
{% raw %}
```json
{
  "scripts": {
    "dev": "webpack serve --mode development",
    "build": "webpack --mode production",
    "test": "jest",
    "lint": "eslint src/",
    "deploy": "npm run build && npm run test && aws s3 sync dist/ s3://my-bucket"
  }
}
```
{% endraw %}

### 4. Rake (Ruby)
{% raw %}
```ruby
# Rakefile
desc "Ejecutar tests"
task :test do
  sh "bundle exec rspec"
end

desc "Desplegar a producci√≥n"
task :deploy => :test do
  sh "cap production deploy"
end

desc "Setup del ambiente"
task :setup do
  sh "bundle install"
  sh "rails db:setup"
end
```
{% endraw %}

## Casos de Uso T√≠picos

### Desarrollo Local
{% raw %}
```python
# tasks/dev_tasks.py
@task
def dev_server(c, port=8000):
    """Iniciar servidor de desarrollo"""
    c.run(f"python manage.py runserver {port}")

@task
def migrations(c):
    """Crear y aplicar migraciones"""
    c.run("python manage.py makemigrations")
    c.run("python manage.py migrate")

@task
def seed_data(c):
    """Poblar base de datos con datos de prueba"""
    c.run("python manage.py loaddata fixtures/*.json")
```
{% endraw %}

### Build y Compilaci√≥n
{% raw %}
```python
@task
def build_frontend(c):
    """Compilar assets frontend"""
    c.run("npm run build")
    c.run("python manage.py collectstatic --noinput")

@task
def build_docker(c, tag="latest"):
    """Construir imagen Docker"""
    c.run(f"docker build -t myapp:{tag} .")
    c.run(f"docker tag myapp:{tag} registry.company.com/myapp:{tag}")
```
{% endraw %}

### CI/CD Pipelines
{% raw %}
```python
@task
def ci_full(c):
    """Pipeline completo de CI"""
    test(c)
    lint(c)
    security_scan(c)
    build_docker(c)
    push_docker(c)

@task
def lint(c):
    """An√°lisis de c√≥digo"""
    c.run("flake8 app/")
    c.run("black --check app/")
    c.run("mypy app/")

@task
def security_scan(c):
    """Escaneo de seguridad"""
    c.run("bandit -r app/")
    c.run("safety check")
```
{% endraw %}

## Caracter√≠sticas Avanzadas

### Dependencias entre Tareas
{% raw %}
```python
@task
def clean(c):
    """Limpiar archivos temporales"""
    c.run("rm -rf build/ dist/ *.egg-info")

@task(pre=[clean])
def build(c):
    """Construir paquete"""
    c.run("python setup.py sdist bdist_wheel")

@task(post=[build])
def release(c):
    """Crear release completo"""
    c.run("git tag v1.0.0")
    c.run("git push --tags")
```
{% endraw %}

### Ejecuci√≥n Condicional
{% raw %}
```python
@task
def deploy(c, environment=None):
    """Despliegue condicional por ambiente"""
    if not environment:
        environment = 'staging'
    if environment == 'production':
        confirm = input("¬øDesplegar a producci√≥n? (y/n): ")
        if confirm.lower() != 'y':
            return
    c.run(f"ansible-playbook deploy-{environment}.yml")
```
{% endraw %}

### Parallel Execution
{% raw %}
```python
from invoke import run

@task
def test_parallel(c):
    """Ejecutar tests en paralelo"""
    commands = [
        "pytest tests/unit/",
        "pytest tests/integration/", 
        "pytest tests/api/"
    ]
    # Ejecuci√≥n paralela (depende del task runner)
    for cmd in commands:
        run(cmd, asynchronous=True)
```
{% endraw %}

## Integraci√≥n con Herramientas

### Docker Integration
{% raw %}
```python
@task
def docker_compose(c, command="up"):
    """Gestionar Docker Compose"""
    if command == "build":
        c.run("docker-compose build")
    elif command == "up":
        c.run("docker-compose up -d")
    elif command == "down":
        c.run("docker-compose down")
    elif command == "logs":
        c.run("docker-compose logs -f")

@task
def db_migrate(c):
    """Migrar base de datos en contenedor"""
    c.run("docker-compose exec web python manage.py migrate")
```
{% endraw %}

### Cloud Integration
{% raw %}
```python
@task
def deploy_aws(c, stack_name="my-app"):
    """Desplegar a AWS"""
    c.run(f"aws cloudformation deploy --stack-name {stack_name} --template-file template.yml")
    c.run(f"aws s3 sync dist/ s3://{stack_name}-bucket/")

@task
def kubernetes_deploy(c, namespace="default"):
    """Desplegar a Kubernetes"""
    c.run(f"kubectl apply -f k8s/ -n {namespace}")
    c.run(f"kubectl rollout status deployment/app -n {namespace}")
```
{% endraw %}

## Task Runners Especializados

### Para Data Science
{% raw %}
```python
# tasks/ds_tasks.py
@task
def download_dataset(c, dataset_name):
    """Descargar dataset"""
    c.run(f"kaggle datasets download {dataset_name}")
    c.run(f"unzip {dataset_name}.zip")

@task
def train_model(c, model_type="random_forest"):
    """Entrenar modelo de ML"""
    c.run(f"python src/train.py --model {model_type}")

@task
def evaluate_model(c):
    """Evaluar modelo entrenado"""
    c.run("python src/evaluate.py")
    c.run("python src/generate_metrics.py")
```
{% endraw %}

### Para Documentaci√≥n
{% raw %}
```python
@task
def docs_build(c):
    """Construir documentaci√≥n"""
    c.run("sphinx-build docs/ build/docs")
    c.run("cp -r build/docs/ public/")

@task
def docs_serve(c, port=8000):
    """Servir documentaci√≥n localmente"""
    c.run(f"python -m http.server {port} --directory public/")
```
{% endraw %}

## Buenas Pr√°cticas

### Task Naming Conventions
{% raw %}
```python
# ‚úÖ Nombres descriptivos y acciones
@task
def database_backup(c): ...

@task 
def deploy_staging(c): ...

@task
def run_migrations(c): ...

# ‚ùå Nombres ambiguos
@task
def do_stuff(c): ...

@task
def thing(c): ...
```
{% endraw %}

### Error Handling
{% raw %}
```python
@task
def safe_deploy(c):
    """Despliegue con manejo de errores"""
    try:
        c.run("git pull origin main")
        c.run("docker-compose build")
        c.run("docker-compose up -d")
        print("‚úÖ Despliegue exitoso")
    except Exception as e:
        print(f"‚ùå Error en despliegue: {e}")
        # Rollback autom√°tico
        c.run("docker-compose down")
        raise
```
{% endraw %}

### Configuration Management
{% raw %}
```python
from invoke import Config

# Configuraci√≥n por ambiente
config = Config({
    'dev': {
        'database_url': 'sqlite:///dev.db',
        'debug': True
    },
    'prod': {
        'database_url': 'postgresql://...',
        'debug': False
    }
})

@task
def run_app(c, env='dev'):
    """Ejecutar app con configuraci√≥n espec√≠fica"""
    env_config = config[env]
    c.run(f"DATABASE_URL={env_config['database_url']} python app.py")
```
{% endraw %}

## Integraci√≥n con Task Queues

### Combinando Ambos Patrones
{% raw %}
```python
@task
def schedule_maintenance(c):
    """Programar tareas de mantenimiento v√≠a task queue"""
    # Usar task runner para orquestar
    c.run("python manage.py collectstatic --noinput")
    # Programar tareas as√≠ncronas
    from celery_app import app
    app.send_task('cleanup_old_files')
    app.send_task('generate_reports')
    app.send_task('update_search_index')
```
{% endraw %}

### Hybrid Approach
{% raw %}
```python
@task
def data_pipeline(c):
    """Pipeline h√≠brido: task runner + task queues"""
    # Fase 1: Task runner (preparaci√≥n)
    c.run("python scripts/download_data.py")
    c.run("python scripts/validate_schema.py")
    # Fase 2: Task queues (procesamiento distribuido)
    from celery_app import app
    chain(
        process_raw_data.s(),
        train_models.s(),
        evaluate_results.s()
    ).delay()
```
{% endraw %}

Los Task Runners son esenciales para automatizar flujos de trabajo de desarrollo, build y deployment, complementando (no reemplazando) a las Task Queues en el ecosistema de automatizaci√≥n moderno.

