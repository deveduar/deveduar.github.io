---
date: 2025-01-29 17:45
title: qwick
tags:
  - qwick
  - framework
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Frontend
public_note: "true"
category: Frontend
---
# Qwik

## Recursos y enlaces
- [Frontend](/uncategorized/frontend/)
- [Qwik ‚Äî Tutorial Overview](https://qwik.dev/tutorial/welcome/overview/)
- [Qwik ‚Äî Getting Started](https://qwik.dev/docs/getting-started/)
- SSR en [Backend](/uncategorized/backend/)

## Conceptos clave de Qwik
- **CSR combinado con SSR**  
	Qwik mezcla renderizado en servidor (SSR) con entrega progresiva del cliente. Su hidrataci√≥n es *diferida*, permitiendo que el cliente cargue √∫nicamente lo necesario cuando ocurre una interacci√≥n real.
- **Lazy Executing (Resumability)**  
	El framework serializa el estado del HTML en el servidor y lo reanuda en el cliente sin volver a ejecutar el √°rbol completo.  
	Este mecanismo evita la hidrataci√≥n tradicional y reduce dr√°sticamente el coste de CPU en el navegador.
- **Serializaci√≥n**  
	Qwik serializa se√±ales, stores y closures mediante un formato que conserva dependencias y puntos de reanudaci√≥n.  
	Esto hace posible que cualquier interacci√≥n pueda cargar s√≥lo la parte del c√≥digo implicada.
- **Signals**  
	Unidades reactivas finas que permiten actualizar √∫nicamente el nodo del DOM afectado.  
	Su uso reemplaza estados globales costosos como `useState` o `useEffect`.
- **useStore**  
	Permite manejar estado estructurado (objetos) de forma reactiva sin necesidad de re-renderizar toda la vista.
- **Route Actions**  
	Mecanismo para manejar acciones desde rutas con l√≥gica en servidor y cliente, similar a loaders + actions de frameworks como Remix, pero totalmente orientado a reanudaci√≥n.

## Arquitectura fundamental
- **Resumability en lugar de Hydration**  
	Qwik no "hidrata" la app, sino que la *reanuda*.  
	El estado de la aplicaci√≥n se incrusta en el HTML y el navegador solo ejecuta c√≥digo cuando lo necesita.
- **Divisi√≥n extrema de c√≥digo**  
	Cualquier funci√≥n, incluso peque√±as, puede convertirse en un *entry point* independiente.  
	Qwik usa `QRL` para definir qu√© porciones pueden descargarse por demanda.
- **Qwik City**  
	El meta-framework para enrutado, server loaders, server actions, optimizaci√≥n de islas, etc.

## Funciones esenciales

### Signals
```ts
import { component$, useSignal } from '@builder.io/qwik';

export const Counter = component$(() => {
	const count = useSignal(0);

	return (
		<button onClick$={() => count.value++}>
			{count.value}
		</button>
	);
});
````

### useStore

```ts
import { component$, useStore } from '@builder.io/qwik';

export const Form = component$(() => {
	const state = useStore({ name: '', age: 0 });

	return (
		<form>
			Name: {state.name}
			Age: {state.age}
		</form>
	);
});
```

### Route Actions

```ts
// src/routes/login/index.tsx
import { routeAction$, z, zod$ } from '@builder.io/qwik-city';

export const useLogin = routeAction$(
	zod$({
		email: z.string().email(),
		password: z.string().min(6)
	}),
	async ({ email, password }) => {
		return { success: true, user: email };
	}
);
```

### Lazy Executing con QRL

```ts
<button onClick$={async () => {
	const mod = await import('./logic');
	mod.run();
}}>
	Click
</button>
```

## Patrones avanzados

* **Server loaders + actions**
  Pueden ejecutarse en servidor y reanudar su estado en el cliente. Evita duplicar l√≥gica.
* **Islas interactivas ultralivianas**
  Cada componente interactivo puede entregarse como una isla aut√≥noma sin necesidad de hidratar toda la app.
* **Optimizaci√≥n autom√°tica del bundle**
  Qwik toma cada evento, closure o funci√≥n y los convierte en puntos de carga independientes.

## Nuevos conceptos a√±adidos

* **Context API de Qwik**
  Mecanismo de dependencia jer√°rquica entre componentes sin necesidad de prop drilling.
* **Qwik Optimizer**
  El compilador que transforma funciones en QRLs, crea entry points y genera el HTML serializado.
* **Resumable DOM**
  Sistema interno que permite reanudar listeners, closures y estado sin re-ejecutar la app en el cliente.

# Qwik ‚Äî Expansi√≥n de conceptos pendientes (sin repetir lo anterior)

## Conceptos adicionales que no estaban cubiertos

### QRL (Qwik Resource Locator)
- Es el mecanismo central para identificar funciones que pueden ser cargadas de forma diferida.  
- Permite que Qwik sepa qu√© c√≥digo asociar a cada interacci√≥n sin empaquetarlo todo en un √∫nico bundle.  
- Aporta:
	- Identificaci√≥n estable de funciones.
	- Capacidad de serializar su ubicaci√≥n.
	- Divisi√≥n extrema de c√≥digo sin overhead manual.

#### Ejemplo de uso de `qrl()`
```ts
import { qrl, component$ } from '@builder.io/qwik';

export const Comp = component$(() => {
	return (
		<button onClick$={qrl(() => console.log('Hello QRL'))}>
			Run
		</button>
	);
});
````

---

### Qwik City: estructura y flujo interno

* Sistema de rutas basado en el filesystem.
* Incluye:
	* Loaders: obtenci√≥n de datos en servidor.
	* Actions: ejecuci√≥n de l√≥gica en servidor con reanudaci√≥n en cliente.
	* Middlewares: filtrado de peticiones y composici√≥n de funcionalidades.
	* Layouts anidados: permiten crear niveles de UI compartida optimizada.
* La reanudaci√≥n permite que *todas* estas piezas funcionen sin sobrecargar el cliente.

#### Flujo interno simplificado

* Petici√≥n ‚Üí Loader/Action ‚Üí Render en servidor ‚Üí Serializaci√≥n ‚Üí Reanudaci√≥n progresiva ‚Üí C√≥digo diferido bajo demanda.

---

### Prefetching inteligente

* Qwik City precarga √∫nicamente lo que el usuario **tiene alta probabilidad** de interactuar.
* Estrategias:
	* Hover prefetching: si el usuario pasa el rat√≥n por un enlace.
	* Viewport prediction: si un componente va a entrar en pantalla.
	* Idle-time prefetching: usa el tiempo ocioso del navegador.

---

### Optimizaci√≥n del ciclo de vida (sin hydration)

* Qwik no usa efectos como `useEffect`, `useLayoutEffect`, etc.
* Esto simplifica el √°rbol de dependencias y evita re-renderizados globales.
* Cuando es necesario un efecto real:
  * `useTask$`: tareas reactivas.
  * `useVisibleTask$`: l√≥gica que debe ejecutarse solo en el cliente cuando el componente est√° visible.
  * `useOnWindow`, `useOnDocument`, etc.: escuchas globales optimizadas.

#### Ejemplo `useVisibleTask$`

```ts
import { component$, useVisibleTask$ } from '@builder.io/qwik';

export const Clock = component$(() => {
	useVisibleTask$(({ cleanup }) => {
		const id = setInterval(() => console.log(Date.now()), 1000);
		cleanup(() => clearInterval(id));
	});
	return <div>Clock running‚Ä¶</div>;
});
```

---

### Qwik y Edge Rendering

* Qwik est√° dise√±ado para ejecutarse en entornos edge:
  * Cloudflare Workers
  * Vercel Edge
  * Netlify Edge
* Razones:
  * No depende de Node APIs internas.
  * Su tiempo de arranque global es extremadamente bajo (cold start optimizado).
  * Puede serializar estado minimalista para servir como respuesta ultrarr√°pida.

---

### Forms inteligentes (Qwik City Forms)

* Basados en actions.
* No requieren JavaScript para hacer un submit b√°sico.
* El cliente *solo descarga JS si hace falta interacci√≥n adicional*.
* Validaci√≥n progresiva:
  * Validaci√≥n en servidor con Zod.
  * Validaci√≥n opcional en cliente sin duplicar l√≥gica.

---

### APIs avanzadas

#### useTask$
* Para l√≥gica reactiva basada en se√±ales o stores.

```ts
useTask$(({ track }) => {
	const v = track(() => signal.value);
	console.log('signal changed', v);
});
```

#### useComputed$
* Similar a un `computed` de Vue o un selector memoizado.

```ts
const doubled = useComputed$(() => count.value * 2);
```

#### useContextProvider + useContext

* Reemplaza contextos pesados, con reactividad m√≠nima y sin re-render.

```ts
import { createContextId, useContextProvider } from '@builder.io/qwik';

export const ThemeCtx = createContextId('theme');

useContextProvider(ThemeCtx, { dark: true });
```

---

## Temas adicionales importantes

### Componentes resumibles y l√≠mites de reactividad

* Cada componente puede ‚Äúdormirse‚Äù y ‚Äúdespertarse‚Äù sin p√©rdida de estado.
* La reactividad se basa en:

  * Signals (√°tomos).
  * Computed (derivados).
  * Stores (objetos observables).
* No hay reconciliaci√≥n VDOM ‚Üí m√°s rendimiento cr√≠tico.

---

### Estrategias recomendadas de arquitectura Qwik

* Dividir funciones interactivas en m√≥dulos peque√±os.
* Usar QRLs sem√°nticos y consistentes.
* Encapsular l√≥gica en route loaders/actions siempre que sea posible.
* Minimizar operaciones en cliente: mover l√≥gica al servidor.
* Preferir signals a stores si el estado es muy granular.

---

## Conclusi√≥n

Ya no quedan conceptos importantes sin cubrir sobre Qwik a nivel ‚Äúfundamentos + avanzado‚Äù.
Si quieres, puedo ahora:
* Crear **una nota nueva m√°s profunda** (arquitectura, patrones y anti-patrones).
* Crear **otra nota separada solo con ejemplos avanzados**.
* Hacer un **glosario completo** de todo Qwik.
* O generar **una gu√≠a de migraci√≥n a Qwik desde React, Svelte o Solid**.


