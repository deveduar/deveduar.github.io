---
date: 2024-11-22 17:31
title: java EE
tags:
  - java
  - EE5
  - javaEE
keywords:
source:
status: üåü
Parent: "[[Area-Prog]]"
cssclasses:
  - hide-embedded-header1
  - wide
categories:
  - Backend
public_note: "true"
category: Backend
---
# Java EE 5
``$= dv.current().file.tags.join(" ")``

## Contexto General
- [Backend](/uncategorized/backend/)
- [java](/software%20engineering/java/)
- Plataforma orientada al desarrollo de **aplicaciones empresariales y web distribuidas**
- Enfocada en **escalabilidad, portabilidad, mantenibilidad y estandarizaci√≥n**
- EE5 marca un punto de consolidaci√≥n y simplificaci√≥n respecto a versiones anteriores
- [JAX-WS](/backend/jax-ws/)
## ¬øQu√© es Java EE 5?
- **Java EE 5 (Enterprise Edition)** es una plataforma est√°ndar para construir aplicaciones empresariales sobre Java
- Introduce una **programaci√≥n m√°s declarativa** mediante anotaciones, reduciendo XML
- Dise√±ada para ejecutarse sobre **servidores de aplicaciones** compatibles con el est√°ndar
- Base de lo que hoy evolucion√≥ hacia **Jakarta EE**

## Arquitectura de la Plataforma
- Modelo **multicapa**:
	- Capa de presentaci√≥n
	- Capa de negocio
	- Capa de persistencia
	- Capa de integraci√≥n
- Separaci√≥n clara de responsabilidades
- Comunicaci√≥n entre capas mediante **APIs estandarizadas**

## Contenedores Java EE
- Los **contenedores** gestionan el ciclo de vida y servicios comunes de los componentes
- Tipos principales:
	- Contenedor Web
	- Contenedor EJB
- Servicios proporcionados por el contenedor:
	- Gesti√≥n de transacciones
	- Seguridad
	- Inyecci√≥n de dependencias
	- Pooling de recursos
	- Concurrencia controlada

## Componentes Principales
- **Componentes Web**
	- Servlets
	- JSP
	- JSF
- **Componentes de Negocio**
	- EJB (Session Beans, Message-Driven Beans)
- **Componentes de Persistencia**
	- Entidades JPA
- **Componentes de Integraci√≥n**
	- Web Services
	- Mensajer√≠a (JMS)

## Est√°ndares y APIs Clave
- **JPA (Java Persistence API)**
	- Mapeo objeto-relacional (ORM)
	- Abstracci√≥n sobre bases de datos relacionales
- [JAX-WS](/backend/jax-ws/) vs  **JAX-RS**  
	- Desarrollo de APIs RESTful
- **CDI (Contexts and Dependency Injection)**
	- Inyecci√≥n de dependencias
	- Gesti√≥n de contexto y ciclo de vida
- **JSF (JavaServer Faces)**
	- Framework MVC para interfaces web
- **JSP y Servlets**
	- Base del desarrollo web en Java EE
- **JMS (Java Message Service)**
	- Comunicaci√≥n as√≠ncrona basada en mensajes

## Especificaciones y APIs
- Java EE se define mediante un conjunto de **especificaciones formales**
- Cada especificaci√≥n tiene:
	- Un contrato (API)
	- Un comportamiento esperado
- Los proveedores implementan estas especificaciones en servidores compatibles

## Servidores de Aplicaciones
- Implementan la especificaci√≥n Java EE
- Ejemplos hist√≥ricos y actuales:
	- GlassFish
	- JBoss / WildFly
	- WebLogic
	- WebSphere
- Permiten desplegar aplicaciones **portables entre proveedores**

## Ventajas de Java EE 5
- Reducci√≥n significativa de configuraci√≥n XML
- Programaci√≥n basada en anotaciones
- Mayor productividad para aplicaciones empresariales
- Ecosistema maduro y estandarizado
- Integraci√≥n nativa de m√∫ltiples tecnolog√≠as

## Limitaciones y Contexto Actual
- Curva de aprendizaje elevada
- Infraestructura pesada comparada con enfoques modernos
- Evolucion√≥ hacia **Jakarta EE** y arquitecturas m√°s ligeras
- Muchas ideas influyeron directamente en frameworks como Spring

## Recursos y Documentaci√≥n
- [Java EE 5: Visi√≥n general - Documentaci√≥n de IBM](https://www.ibm.com/docs/es/rsas/7.5.0?topic=applications-java-ee-overview)
- [2.1 Introduction to the Java EE Platform (Release 7)](https://docs.oracle.com/javaee/7/firstcup/java-ee001.htm)

# Java EE 5 y el Ecosistema Empresarial Java en 2025

## Estado en 2025: Evoluci√≥n y Relevancia
- Java EE como especificaci√≥n hist√≥rica ha sido **reemplazada y evolucionada por Jakarta EE** tras trasladarse a la Eclipse Foundation, con un enfoque moderno y comunitario para aplicaciones empresariales y nativas en la nube.  
	- [Eclipse Foundation ‚Äî Jakarta EE overview](https://jakarta.ee/about/)
- En 2025 la comunidad Java enfatiza **Jakarta EE sobre Java EE tradicional**, centr√°ndose en la adopci√≥n de est√°ndares modernos como **Jakarta EE 11** y perfiles nativos cloud.  
	- [Jakarta EE 11 Announcement](https://jakarta.ee/release/11/)
- El informe de desarrolladores Jakarta EE 2025 muestra un crecimiento sostenido de adopci√≥n frente a otros frameworks del ecosistema Java.  
	- [Jakarta EE Developer Survey 2025](https://newsroom.eclipse.org/news/announcements/eclipse-foundation-releases-2025-jakarta-ee-developer-survey-report)

## ¬øQu√© Significa Java EE 5 Hoy?
- Java EE 5 fue una versi√≥n clave que introdujo:
	- Simplificaci√≥n mediante **anotaciones y reducci√≥n de XML**
	- Integraci√≥n inicial de tecnolog√≠as como **EJB 3.0, JPA, JSF, Servlets, JSP**
		- [Oracle ‚Äî Java EE Technologies Overview](https://www.oracle.com/java/technologies/javaee/javaeetechnologies.html)
- En 2025 se considera principalmente **referencia hist√≥rica y conceptual**
- Sus principios siguen vigentes en Jakarta EE y frameworks modernos

## Relaci√≥n con Jakarta EE
- **Jakarta EE** es la continuaci√≥n oficial de Java EE bajo la **Eclipse Foundation**
	- [Jakarta EE ‚Äî Project Home](https://jakarta.ee/)
- Jakarta EE 11 es la versi√≥n estable y dominante en 2025
	- Alineada con Java moderno
	- Enfoque cloud-native y microservicios
	- [Jakarta EE 11 Release Details](https://projects.eclipse.org/projects/ee4j.jakartaee-platform/releases/11)
- Migraci√≥n de namespaces:
	- De `javax.*` a `jakarta.*`
	- Permite evoluci√≥n independiente del JDK
	- [Jakarta EE ‚Äî Namespace Change Guide](https://jakarta.ee/specifications/platform/)

## Recursos Oficiales y Documentaci√≥n
- **Java EE 5 (hist√≥rico)**
	- Documentaci√≥n, APIs y tutoriales originales
		- [Oracle Docs ‚Äî Java EE 5](https://docs.oracle.com/javaee/5/)
- **Eclipse Foundation**
	- Reportes, encuestas y gobernanza del est√°ndar
		- [Eclipse EE4J Project](https://projects.eclipse.org/projects/ee4j)

## Servidores de Aplicaciones y Soporte
- Implementaciones modernas compatibles con Jakarta EE:
	- **WildFly (JBoss)**
		- Servidor de aplicaciones empresarial activo en 2025
		- [WildFly Official Site](https://www.wildfly.org/)
	- **GlassFish**
		- Implementaci√≥n de referencia hist√≥rica y de pruebas
		- [GlassFish Project](https://glassfish.org/)

## Formaci√≥n y Aprendizaje Actualizado (2025)
- Formaci√≥n orientada a Jakarta EE y ecosistema moderno:
	- APIs REST (JAX-RS)
	- Persistencia con JPA
	- Inyecci√≥n con CDI
	- Frontend con JSF
- Plataformas educativas:
	- [OpenWebinars ‚Äî Java EE / Jakarta EE](https://openwebinars.net/cursos/desarrollo-web-java-ee/)
	- [Jakarta EE Tutorials](https://jakarta.ee/learn/)

## Comparativas con Tecnolog√≠as y Tendencias
- Influencia directa de:
	- Cloud native
	- Microservicios
	- Contenedores y Kubernetes
- Comparaciones frecuentes en 2025:
	- Jakarta EE vs Spring
	- Jakarta EE vs Quarkus
	- Jakarta EE + MicroProfile
		- [Eclipse MicroProfile](https://microprofile.io/)

## Recursos Relevantes (2025)
- **Documentaci√≥n Java EE 5 (Oracle)**  
	- [https://docs.oracle.com/javaee/5/](https://docs.oracle.com/javaee/5/)
- **Jakarta EE Developer Survey 2025**  
	- [https://newsroom.eclipse.org/news/announcements/eclipse-foundation-releases-2025-jakarta-ee-developer-survey-report](https://newsroom.eclipse.org/news/announcements/eclipse-foundation-releases-2025-jakarta-ee-developer-survey-report)
- **Jakarta EE 11 Release**  
	- [https://jakarta.ee/release/11/](https://jakarta.ee/release/11/)
- **WildFly Application Server**  
	- [https://www.wildfly.org/](https://www.wildfly.org/)
- **Formaci√≥n Jakarta EE**  
	- [https://jakarta.ee/learn/](https://jakarta.ee/learn/)

# Java EE / Jakarta EE ‚Äî Conceptos Avanzados y Temas No Cubiertos (2025)

## Perfiles de Plataforma
- Jakarta EE se divide en **perfiles** para distintos tipos de aplicaciones
- Permiten reducir complejidad y dependencias
- Principales perfiles:
	- **Jakarta EE Web Profile**
		- Enfocado en aplicaciones web tradicionales y APIs REST
		- Incluye Servlets, JAX-RS, CDI, JPA, Bean Validation
	- **Jakarta EE Core Profile**
		- Pensado para microservicios y runtimes ligeros
		- Compatible con ejecuci√≥n en contenedores
	- **Jakarta EE Full Platform**
		- Incluye todas las especificaciones empresariales

## Jakarta EE y MicroProfile
- **Eclipse MicroProfile** complementa Jakarta EE
- Aporta APIs orientadas a microservicios:
	- Configuraci√≥n externa
	- Health checks
	- M√©tricas
	- Trazabilidad distribuida
	- Tolerancia a fallos
- Uso com√∫n:
	- Jakarta EE para el core
	- MicroProfile para capacidades cloud-native
- Integraci√≥n directa en servidores como WildFly, Payara y Open Liberty

## Modelos de Despliegue Modernos
- Evoluci√≥n del despliegue tradicional EAR/WAR:
	- WAR auto-contenidos
	- Uber-JAR con runtime embebido
- Enfoques actuales:
	- Docker + Kubernetes
	- CI/CD orientado a despliegues frecuentes
	- Infraestructura declarativa
- Jakarta EE se adapta a:
	- Contenedores
	- Orquestadores
	- Entornos h√≠bridos

## Seguridad Empresarial
- APIs modernas de seguridad:
	- Jakarta Security
	- Jakarta Authentication
	- Jakarta Authorization
- Integraci√≥n con:
	- OAuth2
	- OpenID Connect
	- JWT
- Uso t√≠pico:
	- Seguridad declarativa
	- Autenticaci√≥n delegada
	- Autorizaci√≥n basada en roles

## Observabilidad y Operaci√≥n
- Conceptos clave en 2025:
	- Logging estructurado
	- M√©tricas
	- Trazas distribuidas
- Integraci√≥n con:
	- Prometheus
	- OpenTelemetry
	- Grafana
- MicroProfile Metrics y Telemetry como est√°ndar de facto

## Persistencia Avanzada
- JPA m√°s all√° del CRUD:
	- Caching de segundo nivel
	- Estrategias de fetch
	- Control de transacciones finas
- Integraci√≥n con:
	- Bases de datos relacionales
	- Bases de datos distribuidas
- Uso combinado con:
	- CQRS
	- Event-driven architectures

## Mensajer√≠a y Arquitecturas As√≠ncronas
- Jakarta Messaging (JMS):
	- Comunicaci√≥n desacoplada
	- Procesamiento as√≠ncrono
- Casos habituales:
	- Event-driven systems
	- Integraci√≥n entre sistemas
	- Procesamiento en segundo plano
- Integraci√≥n con brokers modernos:
	- ActiveMQ
	- Kafka (mediante adaptadores)

## Testing en el Ecosistema Jakarta EE
- Testing m√°s all√° de unit tests:
	- Integration testing
	- Container-based testing
- Herramientas comunes:
	- Arquillian
	- Testcontainers
	- JUnit 5
- Beneficios:
	- Tests cercanos al entorno real
	- Validaci√≥n de configuraciones y contenedores

## Gobernanza y Est√°ndares
- Jakarta EE es gobernado por:
	- Eclipse Foundation
	- Working Groups abiertos
- Ventajas del modelo:
	- Transparencia
	- Evoluci√≥n independiente del JDK
	- Participaci√≥n de m√∫ltiples vendors
- Diferencia clave frente a frameworks propietarios

## Casos de Uso Reales en 2025
- Sistemas legacy modernizados
- Backends empresariales de larga vida
- APIs REST estables y estandarizadas
- Plataformas que requieren:
	- Portabilidad
	- Longevidad
	- Vendor lock-in m√≠nimo

## Relaci√≥n con Frameworks Modernos
- Jakarta EE no compite directamente con:
	- Spring Boot
	- Quarkus
- Se complementa seg√∫n el contexto:
	- Jakarta EE: est√°ndares y portabilidad
	- Frameworks: productividad y abstracci√≥n
- Decisi√≥n basada en:
	- Tama√±o del equipo
	- Requisitos de mantenimiento
	- Ciclo de vida del proyecto

## Futuro del Ecosistema
- Tendencias claras:
	- Menos XML, m√°s c√≥digo declarativo
	- Perfiles m√°s peque√±os
	- Mejor integraci√≥n cloud-native
- Jakarta EE se posiciona como:
	- Base estable y estandarizada
	- Alternativa a soluciones propietarias
	- Plataforma de largo plazo para empresas

# Jakarta EE / Java EE ‚Äî Gu√≠a Pr√°ctica con Casos de Uso y Ejemplos de C√≥digo

## Caso de Uso: API REST Empresarial
- Exposici√≥n de servicios backend estables
- Uso t√≠pico en:
	- Frontends web
	- Apps m√≥viles
	- Integraciones entre sistemas

### Ejemplo JAX-RS ‚Äî Recurso REST
```java
@Path("/clientes")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class ClienteResource {

	@Inject
	private ClienteService service;

	@GET
	public List<Cliente> listar() {
		return service.obtenerTodos();
	}

	@POST
	public Response crear(Cliente cliente) {
		service.guardar(cliente);
		return Response.status(Response.Status.CREATED).build();
	}
}
````

## Caso de Uso: L√≥gica de Negocio Transaccional

* Encapsulaci√≥n de reglas de negocio
* Manejo autom√°tico de transacciones
* Ideal para procesos cr√≠ticos

### Ejemplo EJB ‚Äî Servicio de Negocio

```java
@Stateless
public class ClienteService {

	@PersistenceContext
	private EntityManager em;

	public List<Cliente> obtenerTodos() {
		return em.createQuery("SELECT c FROM Cliente c", Cliente.class)
			.getResultList();
	}

	public void guardar(Cliente cliente) {
		em.persist(cliente);
	}
}
```

## Caso de Uso: Persistencia con JPA

* Abstracci√≥n de base de datos
* Portabilidad entre proveedores
* Modelo orientado a entidades

### Ejemplo JPA ‚Äî Entidad

```java
@Entity
@Table(name = "clientes")
public class Cliente {

	@Id
	@GeneratedValue
	private Long id;

	private String nombre;
	private String email;

	// getters y setters
}
```

## Caso de Uso: Inyecci√≥n de Dependencias

* Desacoplar componentes
* Facilitar testing y mantenimiento
* Gesti√≥n autom√°tica del ciclo de vida

### Ejemplo CDI ‚Äî Bean Inyectable

```java
@ApplicationScoped
public class EmailService {

	public void enviar(String destino, String mensaje) {
		System.out.println("Enviando email a " + destino);
	}
}
```

## Caso de Uso: Integraci√≥n de Servicios

* Comunicaci√≥n entre sistemas
* Procesos desacoplados
* Arquitecturas orientadas a eventos

### Ejemplo JMS ‚Äî Productor de Mensajes

```java
@Stateless
public class NotificacionProducer {

	@Resource(lookup = "jms/Queue")
	private Queue queue;

	@Resource
	private JMSContext context;

	public void enviar(String mensaje) {
		context.createProducer().send(queue, mensaje);
	}
}
```

## Caso de Uso: Procesamiento As√≠ncrono

* Tareas de larga duraci√≥n
* Evitar bloqueos en peticiones HTTP
* Escalabilidad

### Ejemplo EJB ‚Äî M√©todo As√≠ncrono

```java
@Stateless
public class ReporteService {

	@Asynchronous
	public void generarReporte() {
		// l√≥gica pesada
	}
}
```

## Caso de Uso: Seguridad Declarativa

* Control de acceso basado en roles
* Menos c√≥digo imperativo
* Integraci√≥n con proveedores externos

### Ejemplo Jakarta Security

```java
@RolesAllowed("ADMIN")
@GET
@Path("/admin")
public Response zonaAdmin() {
	return Response.ok("Acceso concedido").build();
}
```

## Caso de Uso: Validaci√≥n de Datos

* Validaciones autom√°ticas
* Reglas declarativas
* Menos l√≥gica manual

### Ejemplo Bean Validation

```java
public class UsuarioDTO {

	@NotNull
	@Email
	private String email;

	@Size(min = 8)
	private String password;
}
```

## Caso de Uso: Aplicaci√≥n Web Tradicional

* Backoffice
* Sistemas internos
* Formularios y flujos complejos

### Ejemplo JSF ‚Äî Managed Bean

```java
@Named
@RequestScoped
public class ClienteBean {

	private Cliente cliente = new Cliente();

	public void guardar() {
		// persistir cliente
	}

	public Cliente getCliente() {
		return cliente;
	}
}
```

## Caso de Uso: Configuraci√≥n Externa (MicroProfile)

* Separar configuraci√≥n del c√≥digo
* Adaptaci√≥n por entorno
* Cloud-native

### Ejemplo MicroProfile Config

```java
@ApplicationScoped
public class ConfigService {

	@Inject
	@ConfigProperty(name = "app.nombre")
	String nombreApp;

	public String obtenerNombre() {
		return nombreApp;
	}
}
```

## Caso de Uso: Observabilidad

* Monitoreo en producci√≥n
* M√©tricas y salud del sistema
* Diagn√≥stico r√°pido

### Ejemplo MicroProfile Health

```java
@Readiness
@ApplicationScoped
public class HealthCheckServicio implements HealthCheck {

	@Override
	public HealthCheckResponse call() {
		return HealthCheckResponse.up("servicio-activo");
	}
}
```

## Caso de Uso: Testing de Integraci√≥n

* Validar comportamiento real
* Entorno cercano a producci√≥n
* Detectar errores de configuraci√≥n

### Ejemplo Testcontainers + JUnit

```java
@Testcontainers
public class ClienteIT {

	@Container
	static PostgreSQLContainer<?> db =
		new PostgreSQLContainer<>("postgres:15");

	@Test
	void contextoArranca() {
		assertTrue(db.isRunning());
	}
}
```

## Caso de Uso: Despliegue Empresarial

* Aplicaciones de larga vida
* Portabilidad entre servidores
* Control operacional

### Ejemplo Estructura WAR

```text
app.war
‚îú‚îÄ WEB-INF
‚îÇ  ‚îú‚îÄ web.xml
‚îÇ  ‚îî‚îÄ beans.xml
‚îú‚îÄ index.xhtml
‚îî‚îÄ resources
```

```
```

# JAX-RS vs [JAX-WS](/backend/jax-ws/)

## Visi√≥n General
- **JAX-RS** y **[JAX-WS](/backend/jax-ws/)** son especificaciones de Java EE / Jakarta EE para exponer servicios
- Resuelven el mismo problema general (comunicaci√≥n entre sistemas), pero con **enfoques muy distintos**
- En 2025 su uso y relevancia son claramente diferentes

## Enfoque Arquitect√≥nico
- **JAX-RS**
	- Orientado a **REST**
	- Basado en recursos
	- Comunicaci√≥n ligera sobre HTTP
	- Usa verbos HTTP de forma sem√°ntica
- **[JAX-WS](/backend/jax-ws/)**
	- Orientado a **SOAP**
	- Basado en contratos estrictos
	- Comunicaci√≥n basada en mensajes XML
	- Enfoque m√°s formal y protocolizado

## Modelo de Comunicaci√≥n
- **JAX-RS**
	- Resource-oriented
	- URLs representan recursos
	- Estado transferido mediante representaciones (JSON, XML)
- **[JAX-WS](/backend/jax-ws/)**
	- Operation-oriented
	- M√©todos expuestos como operaciones remotas
	- Mensajes SOAP encapsulan la llamada

## Protocolos y Formatos
- **JAX-RS**
	- Protocolo principal: HTTP
	- Formatos comunes:
		- JSON
		- XML
		- Plain text
- **[JAX-WS](/backend/jax-ws/)**
	- Protocolo SOAP sobre:
		- HTTP
		- HTTPS
		- JMS
	- Formato:
		- XML (SOAP Envelope)

## Contrato y Tipado
- **JAX-RS**
	- Contrato impl√≠cito
	- Documentaci√≥n mediante OpenAPI / Swagger
	- Mayor flexibilidad
- **[JAX-WS](/backend/jax-ws/)**
	- Contrato expl√≠cito mediante **WSDL**
	- Tipado fuerte y estricto
	- Generaci√≥n autom√°tica de clientes y stubs

## Complejidad
- **JAX-RS**
	- Curva de aprendizaje baja
	- Menos configuraci√≥n
	- Menor sobrecarga
- **[JAX-WS](/backend/jax-ws/)**
	- Curva de aprendizaje alta
	- Mayor verbosidad
	- Configuraci√≥n compleja

## Casos de Uso T√≠picos
- **JAX-RS**
	- APIs REST p√∫blicas
	- Backends para frontend
	- Microservicios
	- Integraciones modernas
	- Arquitecturas cloud-native
- **[JAX-WS](/backend/jax-ws/)**
	- Integraciones empresariales legacy
	- Sistemas bancarios y gubernamentales
	- Entornos con contratos estrictos
	- Integraciones B2B tradicionales

## Ejemplo B√°sico JAX-RS
### Recurso REST
```java
@Path("/pedidos")
@Produces(MediaType.APPLICATION_JSON)
public class PedidoResource {

	@GET
	public List<Pedido> listar() {
		return List.of();
	}
}
````

## Ejemplo B√°sico JAX-WS

### Servicio SOAP

```java
@WebService
public class PedidoService {

	@WebMethod
	public List<Pedido> listarPedidos() {
		return List.of();
	}
}
```

## Manejo de Errores

* **JAX-RS**

  * C√≥digos HTTP est√°ndar
  * Responses sem√°nticas (404, 400, 500)
* **[JAX-WS](/backend/jax-ws/)**

  * SOAP Faults
  * Errores encapsulados en XML

## Seguridad

* **JAX-RS**

  * JWT
  * OAuth2
  * OpenID Connect
  * Seguridad alineada con HTTP
* **[JAX-WS](/backend/jax-ws/)**

  * WS-Security
  * Firmas digitales
  * Encriptaci√≥n a nivel mensaje

## Rendimiento y Escalabilidad

* **JAX-RS**

  * Ligero
  * Mejor para alta concurrencia
  * Ideal para microservicios
* **[JAX-WS](/backend/jax-ws/)**

  * Mayor sobrecarga
  * Menor rendimiento relativo
  * Adecuado para integraciones cr√≠ticas pero estables

## Estado en 2025

* **JAX-RS**

  * Est√°ndar dominante en Jakarta EE
  * Uso activo y recomendado
  * Integrado con MicroProfile y OpenAPI
* **[JAX-WS](/backend/jax-ws/)**

  * Uso decreciente
  * Mayormente en sistemas legacy
  * Mantenido por compatibilidad

## Cu√°ndo Elegir Cada Uno

* Elegir **JAX-RS** si:

  * Dise√±as una API nueva
  * Necesitas REST y JSON
  * Buscas simplicidad y escalabilidad
* Elegir **[JAX-WS](/backend/jax-ws/)** si:

  * Debes integrarte con sistemas SOAP existentes
  * Requieres contratos WSDL estrictos
  * Operas en entornos enterprise legacy

## Resumen R√°pido

* **JAX-RS** ‚Üí moderno, REST, ligero, flexible
* **[JAX-WS](/backend/jax-ws/)** ‚Üí formal, SOAP, robusto, legacy
